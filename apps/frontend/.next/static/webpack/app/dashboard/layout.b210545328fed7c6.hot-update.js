"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/layout",{

/***/ "(app-pages-browser)/./src/context/auth-context.tsx":
/*!**************************************!*\
  !*** ./src/context/auth-context.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useAuth,AuthProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst defaultContext = {\n    user: null,\n    availableGuilds: [],\n    token: null,\n    loading: true,\n    isAuthenticated: false,\n    login: ()=>{},\n    logout: async ()=>{},\n    refreshSession: async ()=>{}\n};\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(defaultContext);\nconst useAuth = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s1();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [internalAvailableGuilds, setInternalAvailableGuilds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [token, setToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.usePathname)();\n    // --- Stabile Funktionen ---\n    const handleLogout = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[handleLogout]\": async function() {\n            let redirect = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n            console.log('handleLogout: Starting logout...');\n            const currentPath = window.location.pathname;\n            setUser(null);\n            setInternalAvailableGuilds([]);\n            setToken(null);\n            setIsAuthenticated(false);\n            setLoading(false);\n            const tokenKey = \"chimera_auth_token\" || 0;\n            localStorage.removeItem(tokenKey);\n            localStorage.removeItem('selectedGuildId');\n            try {\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.auth.signOut();\n                if (error) console.error('handleLogout: Supabase signOut error:', error);\n                else console.log('handleLogout: Supabase signOut successful.');\n            } catch (error) {\n                console.error('handleLogout: Unexpected signOut error:', error);\n            }\n            if (redirect && !currentPath.startsWith('/auth/login')) {\n                console.log('handleLogout: Redirecting to /auth/login');\n                router.push('/auth/login');\n            }\n        }\n    }[\"AuthProvider.useCallback[handleLogout]\"], [\n        router\n    ]);\n    const fetchBackendSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[fetchBackendSession]\": async (supabaseToken)=>{\n            console.log('[AuthContext] fetchBackendSession: Fetching backend session...');\n            // Set loading true ONLY if not already authenticated maybe? Or always? Let's keep it simple for now.\n            // setLoading(true); // Avoid setting loading true here if called from listener? Might cause flicker.\n            try {\n                var _sessionData_user;\n                const apiUrl = \"http://localhost:3000\" || 0;\n                const response = await fetch(\"\".concat(apiUrl, \"/api/v1/auth/session\"), {\n                    headers: {\n                        Authorization: \"Bearer \".concat(supabaseToken)\n                    }\n                });\n                if (!response.ok) {\n                    const errorText = await response.text().catch({\n                        \"AuthProvider.useCallback[fetchBackendSession]\": ()=>\"Status \".concat(response.status)\n                    }[\"AuthProvider.useCallback[fetchBackendSession]\"]);\n                    console.error(\"[AuthContext] fetchBackendSession: Error \".concat(response.status, \": \").concat(errorText));\n                    await handleLogout(false);\n                    return null;\n                }\n                const sessionData = await response.json();\n                console.log('[AuthContext] fetchBackendSession: Success. User:', (_sessionData_user = sessionData.user) === null || _sessionData_user === void 0 ? void 0 : _sessionData_user.username);\n                setToken({\n                    \"AuthProvider.useCallback[fetchBackendSession]\": (prev)=>prev === supabaseToken ? prev : supabaseToken\n                }[\"AuthProvider.useCallback[fetchBackendSession]\"]);\n                setUser({\n                    \"AuthProvider.useCallback[fetchBackendSession]\": (prev)=>JSON.stringify(prev) === JSON.stringify(sessionData.user) ? prev : sessionData.user\n                }[\"AuthProvider.useCallback[fetchBackendSession]\"]);\n                setInternalAvailableGuilds({\n                    \"AuthProvider.useCallback[fetchBackendSession]\": (prev)=>JSON.stringify(prev) === JSON.stringify(sessionData.availableGuilds) ? prev : sessionData.availableGuilds\n                }[\"AuthProvider.useCallback[fetchBackendSession]\"]);\n                setIsAuthenticated(true);\n                const tokenKey = \"chimera_auth_token\" || 0;\n                localStorage.setItem(tokenKey, supabaseToken);\n                return sessionData;\n            } catch (error) {\n                console.error('[AuthContext] fetchBackendSession: Unexpected error:', error);\n                await handleLogout(false);\n                return null;\n            } finally{\n                // Ensure loading is false after attempting fetch\n                setLoading(false);\n            }\n        }\n    }[\"AuthProvider.useCallback[fetchBackendSession]\"], [\n        handleLogout\n    ]);\n    // --- Auth State Listener ---\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            console.log('[AuthContext] Setting up onAuthStateChange listener');\n            setLoading(true); // Set loading true when listener starts\n            const { data: authListener } = _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.auth.onAuthStateChange({\n                \"AuthProvider.useEffect\": async (event, session)=>{\n                    console.log('[AuthContext] Event:', event, 'Session present:', !!session);\n                    if (event === 'INITIAL_SESSION') {\n                        if (session === null || session === void 0 ? void 0 : session.access_token) {\n                            await fetchBackendSession(session.access_token);\n                        } else {\n                            // No initial session, we are not authenticated\n                            await handleLogout(false); // Reset state without redirect\n                        }\n                    } else if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {\n                        if (session === null || session === void 0 ? void 0 : session.access_token) {\n                            await fetchBackendSession(session.access_token);\n                        } else {\n                            // Should not happen for SIGNED_IN/TOKEN_REFRESHED, but handle defensively\n                            await handleLogout(false);\n                        }\n                    } else if (event === 'SIGNED_OUT') {\n                        await handleLogout(true); // Logout with redirect\n                    }\n                // setLoading(false) is now handled in fetchBackendSession/handleLogout\n                }\n            }[\"AuthProvider.useEffect\"]);\n            return ({\n                \"AuthProvider.useEffect\": ()=>{\n                    var _authListener_subscription;\n                    console.log('[AuthContext] Removing onAuthStateChange listener');\n                    authListener === null || authListener === void 0 ? void 0 : (_authListener_subscription = authListener.subscription) === null || _authListener_subscription === void 0 ? void 0 : _authListener_subscription.unsubscribe();\n                }\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], [\n        fetchBackendSession,\n        handleLogout\n    ]); // Stable dependencies\n    // --- Other Functions ---\n    const login = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[login]\": async ()=>{\n            console.log('Login: Starting Supabase Discord OAuth Flow...');\n            localStorage.removeItem(\"chimera_auth_token\" || 0);\n            localStorage.removeItem('selectedGuildId');\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.auth.signInWithOAuth({\n                provider: 'discord',\n                options: {\n                    redirectTo: \"\".concat(window.location.protocol, \"//\").concat(window.location.host, \"/auth/callback\"),\n                    scopes: 'identify guilds'\n                }\n            });\n            if (error) console.error('Login Error:', error);\n        }\n    }[\"AuthProvider.useCallback[login]\"], []);\n    const refreshSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[refreshSession]\": async ()=>{\n            console.log('[AuthContext] refreshSession called...');\n            const { data: { session } } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.auth.getSession();\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await fetchBackendSession(session.access_token);\n            } else {\n                console.warn('[AuthContext] refreshSession: No valid Supabase session found.');\n                await handleLogout(true);\n            }\n        }\n    }[\"AuthProvider.useCallback[refreshSession]\"], [\n        fetchBackendSession,\n        handleLogout\n    ]);\n    // --- Redirect Effect ---\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            console.log(\"[AuthContext Redirect Check] loading: \".concat(loading, \", isAuthenticated: \").concat(isAuthenticated, \", pathname: \").concat(pathname));\n            if (!loading && isAuthenticated && !pathname.startsWith('/dashboard') && !pathname.startsWith('/auth/callback')) {\n                console.log('[AuthContext Redirect Action] Redirecting to /dashboard...');\n                router.replace('/dashboard');\n            }\n        }\n    }[\"AuthProvider.useEffect\"], [\n        loading,\n        isAuthenticated,\n        pathname,\n        router\n    ]);\n    // --- Memoized Context Value ---\n    // Memoize availableGuilds separately only if it changes significantly\n    const memoizedAvailableGuilds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"AuthProvider.useMemo[memoizedAvailableGuilds]\": ()=>{\n            console.log('[AuthContext] Memoizing availableGuilds...');\n            return internalAvailableGuilds;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"AuthProvider.useMemo[memoizedAvailableGuilds]\"], [\n        JSON.stringify(internalAvailableGuilds)\n    ]); // Use deep comparison, less efficient but safer for now\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"AuthProvider.useMemo[contextValue]\": ()=>{\n            console.log('[AuthContext] Recalculating context value.');\n            return {\n                user,\n                availableGuilds: memoizedAvailableGuilds,\n                token,\n                loading,\n                isAuthenticated,\n                login,\n                logout: handleLogout,\n                refreshSession\n            };\n        }\n    }[\"AuthProvider.useMemo[contextValue]\"], [\n        user,\n        memoizedAvailableGuilds,\n        token,\n        loading,\n        isAuthenticated,\n        login,\n        handleLogout,\n        refreshSession\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\info\\\\Documents\\\\Discord Bot\\\\Chimera\\\\apps\\\\frontend\\\\src\\\\context\\\\auth-context.tsx\",\n        lineNumber: 205,\n        columnNumber: 5\n    }, this);\n}\n_s1(AuthProvider, \"b5usR34X+AuueXdxe8jBnhLwVto=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter,\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.usePathname\n    ];\n});\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L2F1dGgtY29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRW9HO0FBQzNDO0FBQ2Y7QUFpQjFDLE1BQU1VLGlCQUFrQztJQUN0Q0MsTUFBTTtJQUNOQyxpQkFBaUIsRUFBRTtJQUNuQkMsT0FBTztJQUNQQyxTQUFTO0lBQ1RDLGlCQUFpQjtJQUNqQkMsT0FBTyxLQUFPO0lBQ2RDLFFBQVEsV0FBYTtJQUNyQkMsZ0JBQWdCLFdBQWE7QUFDL0I7QUFFQSxNQUFNQyw0QkFBY2xCLG9EQUFhQSxDQUFrQlM7QUFFNUMsTUFBTVUsVUFBVTs7SUFBTWxCLE9BQUFBLGlEQUFVQSxDQUFDaUI7QUFBVyxFQUFFO0dBQXhDQztBQUVOLFNBQVNDLGFBQWEsS0FBMkM7UUFBM0MsRUFBRUMsUUFBUSxFQUFpQyxHQUEzQzs7SUFDM0IsTUFBTSxDQUFDWCxNQUFNWSxRQUFRLEdBQUduQiwrQ0FBUUEsQ0FBYztJQUM5QyxNQUFNLENBQUNvQix5QkFBeUJDLDJCQUEyQixHQUFHckIsK0NBQVFBLENBQTBCLEVBQUU7SUFDbEcsTUFBTSxDQUFDUyxPQUFPYSxTQUFTLEdBQUd0QiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDVSxTQUFTYSxXQUFXLEdBQUd2QiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNXLGlCQUFpQmEsbUJBQW1CLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNeUIsU0FBU3RCLDBEQUFTQTtJQUN4QixNQUFNdUIsV0FBV3RCLDREQUFXQTtJQUU1Qiw2QkFBNkI7SUFDN0IsTUFBTXVCLGVBQWV6QixrREFBV0E7a0RBQUM7Z0JBQU8wQiw0RUFBVztZQUNqREMsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTUMsY0FBY0MsT0FBT0MsUUFBUSxDQUFDUCxRQUFRO1lBQzVDUCxRQUFRO1lBQ1JFLDJCQUEyQixFQUFFO1lBQzdCQyxTQUFTO1lBQ1RFLG1CQUFtQjtZQUNuQkQsV0FBVztZQUVYLE1BQU1XLFdBQVdDLG9CQUFzQyxJQUFJLENBQW9CO1lBQy9FRyxhQUFhQyxVQUFVLENBQUNMO1lBQ3hCSSxhQUFhQyxVQUFVLENBQUM7WUFFeEIsSUFBSTtnQkFDRixNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1uQyxtREFBUUEsQ0FBQ29DLElBQUksQ0FBQ0MsT0FBTztnQkFDN0MsSUFBSUYsT0FBT1gsUUFBUVcsS0FBSyxDQUFDLHlDQUF5Q0E7cUJBQzdEWCxRQUFRQyxHQUFHLENBQUM7WUFDbkIsRUFBRSxPQUFPVSxPQUFPO2dCQUNkWCxRQUFRVyxLQUFLLENBQUMsMkNBQTJDQTtZQUMzRDtZQUVBLElBQUlaLFlBQVksQ0FBQ0csWUFBWVksVUFBVSxDQUFDLGdCQUFnQjtnQkFDdERkLFFBQVFDLEdBQUcsQ0FBQztnQkFDWkwsT0FBT21CLElBQUksQ0FBQztZQUNkO1FBQ0Y7aURBQUc7UUFBQ25CO0tBQU87SUFFWCxNQUFNb0Isc0JBQXNCM0Msa0RBQVdBO3lEQUFDLE9BQU80QztZQUM3Q2pCLFFBQVFDLEdBQUcsQ0FBQztZQUNaLHFHQUFxRztZQUNyRyxxR0FBcUc7WUFDckcsSUFBSTtvQkFjK0RpQjtnQkFiakUsTUFBTUMsU0FBU2IsdUJBQStCLElBQUksQ0FBdUI7Z0JBQ3pFLE1BQU1lLFdBQVcsTUFBTUMsTUFBTSxHQUFVLE9BQVBILFFBQU8seUJBQXVCO29CQUM1REksU0FBUzt3QkFBRUMsZUFBZSxVQUF3QixPQUFkUDtvQkFBZ0I7Z0JBQ3REO2dCQUVBLElBQUksQ0FBQ0ksU0FBU0ksRUFBRSxFQUFFO29CQUNoQixNQUFNQyxZQUFZLE1BQU1MLFNBQVNNLElBQUksR0FBR0MsS0FBSzt5RUFBQyxJQUFNLFVBQTBCLE9BQWhCUCxTQUFTUSxNQUFNOztvQkFDN0U3QixRQUFRVyxLQUFLLENBQUMsNENBQWdFZSxPQUFwQkwsU0FBU1EsTUFBTSxFQUFDLE1BQWMsT0FBVkg7b0JBQzlFLE1BQU01QixhQUFhO29CQUNuQixPQUFPO2dCQUNUO2dCQUVBLE1BQU1vQixjQUEwQixNQUFNRyxTQUFTUyxJQUFJO2dCQUNuRDlCLFFBQVFDLEdBQUcsQ0FBQyxzREFBcURpQixvQkFBQUEsWUFBWXhDLElBQUksY0FBaEJ3Qyx3Q0FBQUEsa0JBQWtCYSxRQUFRO2dCQUUzRnRDO3FFQUFTdUMsQ0FBQUEsT0FBUUEsU0FBU2YsZ0JBQWdCZSxPQUFPZjs7Z0JBQ2pEM0I7cUVBQVEwQyxDQUFBQSxPQUFRQyxLQUFLQyxTQUFTLENBQUNGLFVBQVVDLEtBQUtDLFNBQVMsQ0FBQ2hCLFlBQVl4QyxJQUFJLElBQUlzRCxPQUFPZCxZQUFZeEMsSUFBSTs7Z0JBQ25HYztxRUFBMkJ3QyxDQUFBQSxPQUFRQyxLQUFLQyxTQUFTLENBQUNGLFVBQVVDLEtBQUtDLFNBQVMsQ0FBQ2hCLFlBQVl2QyxlQUFlLElBQUlxRCxPQUFPZCxZQUFZdkMsZUFBZTs7Z0JBQzVJZ0IsbUJBQW1CO2dCQUVuQixNQUFNVSxXQUFXQyxvQkFBc0MsSUFBSSxDQUFvQjtnQkFDL0VHLGFBQWEwQixPQUFPLENBQUM5QixVQUFVWTtnQkFDL0IsT0FBT0M7WUFDVCxFQUFFLE9BQU9QLE9BQU87Z0JBQ2RYLFFBQVFXLEtBQUssQ0FBQyx3REFBd0RBO2dCQUN0RSxNQUFNYixhQUFhO2dCQUNuQixPQUFPO1lBQ1QsU0FBVTtnQkFDTixpREFBaUQ7Z0JBQ2pESixXQUFXO1lBQ2Y7UUFDRjt3REFBRztRQUFDSTtLQUFhO0lBRWpCLDhCQUE4QjtJQUM5QjVCLGdEQUFTQTtrQ0FBQztZQUNSOEIsUUFBUUMsR0FBRyxDQUFDO1lBQ1pQLFdBQVcsT0FBTyx3Q0FBd0M7WUFFMUQsTUFBTSxFQUFFMEMsTUFBTUMsWUFBWSxFQUFFLEdBQUc3RCxtREFBUUEsQ0FBQ29DLElBQUksQ0FBQzBCLGlCQUFpQjswQ0FDNUQsT0FBT0MsT0FBT0M7b0JBQ1p4QyxRQUFRQyxHQUFHLENBQUMsd0JBQXdCc0MsT0FBTyxvQkFBb0IsQ0FBQyxDQUFDQztvQkFDakUsSUFBSUQsVUFBVSxtQkFBbUI7d0JBQzdCLElBQUlDLG9CQUFBQSw4QkFBQUEsUUFBU0MsWUFBWSxFQUFFOzRCQUN2QixNQUFNekIsb0JBQW9Cd0IsUUFBUUMsWUFBWTt3QkFDbEQsT0FBTzs0QkFDSCwrQ0FBK0M7NEJBQy9DLE1BQU0zQyxhQUFhLFFBQVEsK0JBQStCO3dCQUM5RDtvQkFDSixPQUFPLElBQUl5QyxVQUFVLGVBQWVBLFVBQVUsbUJBQW1CO3dCQUM3RCxJQUFJQyxvQkFBQUEsOEJBQUFBLFFBQVNDLFlBQVksRUFBRTs0QkFDeEIsTUFBTXpCLG9CQUFvQndCLFFBQVFDLFlBQVk7d0JBQ2pELE9BQU87NEJBQ0osMEVBQTBFOzRCQUMxRSxNQUFNM0MsYUFBYTt3QkFDdEI7b0JBQ0osT0FBTyxJQUFJeUMsVUFBVSxjQUFjO3dCQUNqQyxNQUFNekMsYUFBYSxPQUFPLHVCQUF1QjtvQkFDbkQ7Z0JBQ0EsdUVBQXVFO2dCQUN6RTs7WUFHRjswQ0FBTzt3QkFFTHVDO29CQURBckMsUUFBUUMsR0FBRyxDQUFDO29CQUNab0MseUJBQUFBLG9DQUFBQSw2QkFBQUEsYUFBY0ssWUFBWSxjQUExQkwsaURBQUFBLDJCQUE0Qk0sV0FBVztnQkFDekM7O1FBQ0Y7aUNBQUc7UUFBQzNCO1FBQXFCbEI7S0FBYSxHQUFHLHNCQUFzQjtJQUUvRCwwQkFBMEI7SUFDMUIsTUFBTWYsUUFBUVYsa0RBQVdBOzJDQUFDO1lBQ3hCMkIsUUFBUUMsR0FBRyxDQUFDO1lBQ1pRLGFBQWFDLFVBQVUsQ0FBQ0osb0JBQXNDLElBQUksQ0FBb0I7WUFDdEZHLGFBQWFDLFVBQVUsQ0FBQztZQUN4QixNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1uQyxtREFBUUEsQ0FBQ29DLElBQUksQ0FBQ2dDLGVBQWUsQ0FBQztnQkFDcERDLFVBQVU7Z0JBQ1ZDLFNBQVM7b0JBQ1BDLFlBQVksR0FBZ0M1QyxPQUE3QkEsT0FBT0MsUUFBUSxDQUFDNEMsUUFBUSxFQUFDLE1BQXlCLE9BQXJCN0MsT0FBT0MsUUFBUSxDQUFDNkMsSUFBSSxFQUFDO29CQUNqRUMsUUFBUTtnQkFDVjtZQUNGO1lBQ0EsSUFBSXZDLE9BQU9YLFFBQVFXLEtBQUssQ0FBQyxnQkFBZ0JBO1FBQzNDOzBDQUFHLEVBQUU7SUFFTCxNQUFNMUIsaUJBQWlCWixrREFBV0E7b0RBQUM7WUFDakMyQixRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUVtQyxNQUFNLEVBQUVJLE9BQU8sRUFBRSxFQUFFLEdBQUcsTUFBTWhFLG1EQUFRQSxDQUFDb0MsSUFBSSxDQUFDdUMsVUFBVTtZQUM1RCxJQUFJWCxvQkFBQUEsOEJBQUFBLFFBQVNDLFlBQVksRUFBRTtnQkFDekIsTUFBTXpCLG9CQUFvQndCLFFBQVFDLFlBQVk7WUFDaEQsT0FBTztnQkFDTHpDLFFBQVFvRCxJQUFJLENBQUM7Z0JBQ2IsTUFBTXRELGFBQWE7WUFDckI7UUFDRjttREFBRztRQUFDa0I7UUFBcUJsQjtLQUFhO0lBRXRDLDBCQUEwQjtJQUMxQjVCLGdEQUFTQTtrQ0FBQztZQUNSOEIsUUFBUUMsR0FBRyxDQUFDLHlDQUFzRW5CLE9BQTdCRCxTQUFRLHVCQUFtRGdCLE9BQTlCZixpQkFBZ0IsZ0JBQXVCLE9BQVRlO1lBQ2hILElBQUksQ0FBQ2hCLFdBQVdDLG1CQUFtQixDQUFDZSxTQUFTaUIsVUFBVSxDQUFDLGlCQUFpQixDQUFDakIsU0FBU2lCLFVBQVUsQ0FBQyxtQkFBbUI7Z0JBQy9HZCxRQUFRQyxHQUFHLENBQUM7Z0JBQ1pMLE9BQU95RCxPQUFPLENBQUM7WUFDakI7UUFDRjtpQ0FBRztRQUFDeEU7UUFBU0M7UUFBaUJlO1FBQVVEO0tBQU87SUFFL0MsaUNBQWlDO0lBQ2pDLHNFQUFzRTtJQUN0RSxNQUFNMEQsMEJBQTBCbEYsOENBQU9BO3lEQUFDO1lBQ3BDNEIsUUFBUUMsR0FBRyxDQUFDO1lBQ1osT0FBT1Y7UUFDWCx1REFBdUQ7UUFDdkQ7d0RBQUc7UUFBQzBDLEtBQUtDLFNBQVMsQ0FBQzNDO0tBQXlCLEdBQUcsd0RBQXdEO0lBRXZHLE1BQU1nRSxlQUFlbkYsOENBQU9BOzhDQUFDO1lBQzNCNEIsUUFBUUMsR0FBRyxDQUFDO1lBQ1osT0FBTztnQkFDTHZCO2dCQUNBQyxpQkFBaUIyRTtnQkFDakIxRTtnQkFDQUM7Z0JBQ0FDO2dCQUNBQztnQkFDQUMsUUFBUWM7Z0JBQ1JiO1lBQ0Y7UUFDRjs2Q0FBRztRQUFDUDtRQUFNNEU7UUFBeUIxRTtRQUFPQztRQUFTQztRQUFpQkM7UUFBT2U7UUFBY2I7S0FBZTtJQUV4RyxxQkFDRSw4REFBQ0MsWUFBWXNFLFFBQVE7UUFBQ0MsT0FBT0Y7a0JBQzFCbEU7Ozs7OztBQUdQO0lBNUtnQkQ7O1FBTUNkLHNEQUFTQTtRQUNQQyx3REFBV0E7OztLQVBkYSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxpbmZvXFxEb2N1bWVudHNcXERpc2NvcmQgQm90XFxDaGltZXJhXFxhcHBzXFxmcm9udGVuZFxcc3JjXFxjb250ZXh0XFxhdXRoLWNvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUm91dGVyLCB1c2VQYXRobmFtZSB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcbmltcG9ydCB7IFNlc3Npb25EdG8sIEd1aWxkU2VsZWN0aW9uSW5mb0R0bywgVXNlclByb2ZpbGVEdG8gfSBmcm9tICdzaGFyZWQtdHlwZXMnO1xuXG4vLyBUeXBkZWZpbml0aW9uZW5cbmV4cG9ydCB0eXBlIFVzZXIgPSBPbWl0PFVzZXJQcm9maWxlRHRvLCAnY3JlYXRlZF9hdCcgfCAndXBkYXRlZF9hdCc+O1xuXG5pbnRlcmZhY2UgQXV0aENvbnRleHRUeXBlIHtcbiAgdXNlcjogVXNlciB8IG51bGw7XG4gIGF2YWlsYWJsZUd1aWxkczogR3VpbGRTZWxlY3Rpb25JbmZvRHRvW107XG4gIHRva2VuOiBzdHJpbmcgfCBudWxsO1xuICBsb2FkaW5nOiBib29sZWFuO1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIGxvZ2luOiAoKSA9PiB2b2lkO1xuICBsb2dvdXQ6IChyZWRpcmVjdD86IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD47XG4gIHJlZnJlc2hTZXNzaW9uOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuXG5jb25zdCBkZWZhdWx0Q29udGV4dDogQXV0aENvbnRleHRUeXBlID0ge1xuICB1c2VyOiBudWxsLFxuICBhdmFpbGFibGVHdWlsZHM6IFtdLFxuICB0b2tlbjogbnVsbCxcbiAgbG9hZGluZzogdHJ1ZSxcbiAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgbG9naW46ICgpID0+IHt9LFxuICBsb2dvdXQ6IGFzeW5jICgpID0+IHt9LFxuICByZWZyZXNoU2Vzc2lvbjogYXN5bmMgKCkgPT4ge30sXG59O1xuXG5jb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8QXV0aENvbnRleHRUeXBlPihkZWZhdWx0Q29udGV4dCk7XG5cbmV4cG9ydCBjb25zdCB1c2VBdXRoID0gKCkgPT4gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBBdXRoUHJvdmlkZXIoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxVc2VyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpbnRlcm5hbEF2YWlsYWJsZUd1aWxkcywgc2V0SW50ZXJuYWxBdmFpbGFibGVHdWlsZHNdID0gdXNlU3RhdGU8R3VpbGRTZWxlY3Rpb25JbmZvRHRvW10+KFtdKTtcbiAgY29uc3QgW3Rva2VuLCBzZXRUb2tlbl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtpc0F1dGhlbnRpY2F0ZWQsIHNldElzQXV0aGVudGljYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCBwYXRobmFtZSA9IHVzZVBhdGhuYW1lKCk7XG5cbiAgLy8gLS0tIFN0YWJpbGUgRnVua3Rpb25lbiAtLS1cbiAgY29uc3QgaGFuZGxlTG9nb3V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKHJlZGlyZWN0ID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdoYW5kbGVMb2dvdXQ6IFN0YXJ0aW5nIGxvZ291dC4uLicpO1xuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHNldFVzZXIobnVsbCk7XG4gICAgc2V0SW50ZXJuYWxBdmFpbGFibGVHdWlsZHMoW10pO1xuICAgIHNldFRva2VuKG51bGwpO1xuICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XG5cbiAgICBjb25zdCB0b2tlbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FVVEhfVE9LRU5fS0VZIHx8ICdjaGltZXJhX2F1dGhfdG9rZW4nO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRva2VuS2V5KTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnc2VsZWN0ZWRHdWlsZElkJyk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduT3V0KCk7XG4gICAgICBpZiAoZXJyb3IpIGNvbnNvbGUuZXJyb3IoJ2hhbmRsZUxvZ291dDogU3VwYWJhc2Ugc2lnbk91dCBlcnJvcjonLCBlcnJvcik7XG4gICAgICBlbHNlIGNvbnNvbGUubG9nKCdoYW5kbGVMb2dvdXQ6IFN1cGFiYXNlIHNpZ25PdXQgc3VjY2Vzc2Z1bC4nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignaGFuZGxlTG9nb3V0OiBVbmV4cGVjdGVkIHNpZ25PdXQgZXJyb3I6JywgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChyZWRpcmVjdCAmJiAhY3VycmVudFBhdGguc3RhcnRzV2l0aCgnL2F1dGgvbG9naW4nKSkge1xuICAgICAgY29uc29sZS5sb2coJ2hhbmRsZUxvZ291dDogUmVkaXJlY3RpbmcgdG8gL2F1dGgvbG9naW4nKTtcbiAgICAgIHJvdXRlci5wdXNoKCcvYXV0aC9sb2dpbicpO1xuICAgIH1cbiAgfSwgW3JvdXRlcl0pO1xuXG4gIGNvbnN0IGZldGNoQmFja2VuZFNlc3Npb24gPSB1c2VDYWxsYmFjayhhc3luYyAoc3VwYWJhc2VUb2tlbjogc3RyaW5nKTogUHJvbWlzZTxTZXNzaW9uRHRvIHwgbnVsbD4gPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbQXV0aENvbnRleHRdIGZldGNoQmFja2VuZFNlc3Npb246IEZldGNoaW5nIGJhY2tlbmQgc2Vzc2lvbi4uLicpO1xuICAgIC8vIFNldCBsb2FkaW5nIHRydWUgT05MWSBpZiBub3QgYWxyZWFkeSBhdXRoZW50aWNhdGVkIG1heWJlPyBPciBhbHdheXM/IExldCdzIGtlZXAgaXQgc2ltcGxlIGZvciBub3cuXG4gICAgLy8gc2V0TG9hZGluZyh0cnVlKTsgLy8gQXZvaWQgc2V0dGluZyBsb2FkaW5nIHRydWUgaGVyZSBpZiBjYWxsZWQgZnJvbSBsaXN0ZW5lcj8gTWlnaHQgY2F1c2UgZmxpY2tlci5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYXBpVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwJztcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7YXBpVXJsfS9hcGkvdjEvYXV0aC9zZXNzaW9uYCwge1xuICAgICAgICBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtzdXBhYmFzZVRva2VufWAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBgU3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbQXV0aENvbnRleHRdIGZldGNoQmFja2VuZFNlc3Npb246IEVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvclRleHR9YCk7XG4gICAgICAgIGF3YWl0IGhhbmRsZUxvZ291dChmYWxzZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXNzaW9uRGF0YTogU2Vzc2lvbkR0byA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdbQXV0aENvbnRleHRdIGZldGNoQmFja2VuZFNlc3Npb246IFN1Y2Nlc3MuIFVzZXI6Jywgc2Vzc2lvbkRhdGEudXNlcj8udXNlcm5hbWUpO1xuXG4gICAgICBzZXRUb2tlbihwcmV2ID0+IHByZXYgPT09IHN1cGFiYXNlVG9rZW4gPyBwcmV2IDogc3VwYWJhc2VUb2tlbik7XG4gICAgICBzZXRVc2VyKHByZXYgPT4gSlNPTi5zdHJpbmdpZnkocHJldikgPT09IEpTT04uc3RyaW5naWZ5KHNlc3Npb25EYXRhLnVzZXIpID8gcHJldiA6IHNlc3Npb25EYXRhLnVzZXIpO1xuICAgICAgc2V0SW50ZXJuYWxBdmFpbGFibGVHdWlsZHMocHJldiA9PiBKU09OLnN0cmluZ2lmeShwcmV2KSA9PT0gSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbkRhdGEuYXZhaWxhYmxlR3VpbGRzKSA/IHByZXYgOiBzZXNzaW9uRGF0YS5hdmFpbGFibGVHdWlsZHMpO1xuICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xuXG4gICAgICBjb25zdCB0b2tlbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FVVEhfVE9LRU5fS0VZIHx8ICdjaGltZXJhX2F1dGhfdG9rZW4nO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odG9rZW5LZXksIHN1cGFiYXNlVG9rZW4pO1xuICAgICAgcmV0dXJuIHNlc3Npb25EYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbQXV0aENvbnRleHRdIGZldGNoQmFja2VuZFNlc3Npb246IFVuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgYXdhaXQgaGFuZGxlTG9nb3V0KGZhbHNlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIEVuc3VyZSBsb2FkaW5nIGlzIGZhbHNlIGFmdGVyIGF0dGVtcHRpbmcgZmV0Y2hcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbaGFuZGxlTG9nb3V0XSk7XG5cbiAgLy8gLS0tIEF1dGggU3RhdGUgTGlzdGVuZXIgLS0tXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1tBdXRoQ29udGV4dF0gU2V0dGluZyB1cCBvbkF1dGhTdGF0ZUNoYW5nZSBsaXN0ZW5lcicpO1xuICAgIHNldExvYWRpbmcodHJ1ZSk7IC8vIFNldCBsb2FkaW5nIHRydWUgd2hlbiBsaXN0ZW5lciBzdGFydHNcblxuICAgIGNvbnN0IHsgZGF0YTogYXV0aExpc3RlbmVyIH0gPSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKFxuICAgICAgYXN5bmMgKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQXV0aENvbnRleHRdIEV2ZW50OicsIGV2ZW50LCAnU2Vzc2lvbiBwcmVzZW50OicsICEhc2Vzc2lvbik7XG4gICAgICAgIGlmIChldmVudCA9PT0gJ0lOSVRJQUxfU0VTU0lPTicpIHtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZXRjaEJhY2tlbmRTZXNzaW9uKHNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gaW5pdGlhbCBzZXNzaW9uLCB3ZSBhcmUgbm90IGF1dGhlbnRpY2F0ZWRcbiAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2dvdXQoZmFsc2UpOyAvLyBSZXNldCBzdGF0ZSB3aXRob3V0IHJlZGlyZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdTSUdORURfSU4nIHx8IGV2ZW50ID09PSAnVE9LRU5fUkVGUkVTSEVEJykge1xuICAgICAgICAgICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgYXdhaXQgZmV0Y2hCYWNrZW5kU2Vzc2lvbihzZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4gZm9yIFNJR05FRF9JTi9UT0tFTl9SRUZSRVNIRUQsIGJ1dCBoYW5kbGUgZGVmZW5zaXZlbHlcbiAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvZ291dChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJykge1xuICAgICAgICAgIGF3YWl0IGhhbmRsZUxvZ291dCh0cnVlKTsgLy8gTG9nb3V0IHdpdGggcmVkaXJlY3RcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXRMb2FkaW5nKGZhbHNlKSBpcyBub3cgaGFuZGxlZCBpbiBmZXRjaEJhY2tlbmRTZXNzaW9uL2hhbmRsZUxvZ291dFxuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1tBdXRoQ29udGV4dF0gUmVtb3Zpbmcgb25BdXRoU3RhdGVDaGFuZ2UgbGlzdGVuZXInKTtcbiAgICAgIGF1dGhMaXN0ZW5lcj8uc3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtmZXRjaEJhY2tlbmRTZXNzaW9uLCBoYW5kbGVMb2dvdXRdKTsgLy8gU3RhYmxlIGRlcGVuZGVuY2llc1xuXG4gIC8vIC0tLSBPdGhlciBGdW5jdGlvbnMgLS0tXG4gIGNvbnN0IGxvZ2luID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdMb2dpbjogU3RhcnRpbmcgU3VwYWJhc2UgRGlzY29yZCBPQXV0aCBGbG93Li4uJyk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVVUSF9UT0tFTl9LRVkgfHwgJ2NoaW1lcmFfYXV0aF90b2tlbicpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzZWxlY3RlZEd1aWxkSWQnKTtcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhPQXV0aCh7XG4gICAgICBwcm92aWRlcjogJ2Rpc2NvcmQnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICByZWRpcmVjdFRvOiBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0fS9hdXRoL2NhbGxiYWNrYCxcbiAgICAgICAgc2NvcGVzOiAnaWRlbnRpZnkgZ3VpbGRzJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKGVycm9yKSBjb25zb2xlLmVycm9yKCdMb2dpbiBFcnJvcjonLCBlcnJvcik7XG4gIH0sIFtdKTtcblxuICBjb25zdCByZWZyZXNoU2Vzc2lvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0F1dGhDb250ZXh0XSByZWZyZXNoU2Vzc2lvbiBjYWxsZWQuLi4nKTtcbiAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKTtcbiAgICBpZiAoc2Vzc2lvbj8uYWNjZXNzX3Rva2VuKSB7XG4gICAgICBhd2FpdCBmZXRjaEJhY2tlbmRTZXNzaW9uKHNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdbQXV0aENvbnRleHRdIHJlZnJlc2hTZXNzaW9uOiBObyB2YWxpZCBTdXBhYmFzZSBzZXNzaW9uIGZvdW5kLicpO1xuICAgICAgYXdhaXQgaGFuZGxlTG9nb3V0KHRydWUpO1xuICAgIH1cbiAgfSwgW2ZldGNoQmFja2VuZFNlc3Npb24sIGhhbmRsZUxvZ291dF0pO1xuXG4gIC8vIC0tLSBSZWRpcmVjdCBFZmZlY3QgLS0tXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coYFtBdXRoQ29udGV4dCBSZWRpcmVjdCBDaGVja10gbG9hZGluZzogJHtsb2FkaW5nfSwgaXNBdXRoZW50aWNhdGVkOiAke2lzQXV0aGVudGljYXRlZH0sIHBhdGhuYW1lOiAke3BhdGhuYW1lfWApO1xuICAgIGlmICghbG9hZGluZyAmJiBpc0F1dGhlbnRpY2F0ZWQgJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoJy9kYXNoYm9hcmQnKSAmJiAhcGF0aG5hbWUuc3RhcnRzV2l0aCgnL2F1dGgvY2FsbGJhY2snKSkge1xuICAgICAgY29uc29sZS5sb2coJ1tBdXRoQ29udGV4dCBSZWRpcmVjdCBBY3Rpb25dIFJlZGlyZWN0aW5nIHRvIC9kYXNoYm9hcmQuLi4nKTtcbiAgICAgIHJvdXRlci5yZXBsYWNlKCcvZGFzaGJvYXJkJyk7XG4gICAgfVxuICB9LCBbbG9hZGluZywgaXNBdXRoZW50aWNhdGVkLCBwYXRobmFtZSwgcm91dGVyXSk7XG5cbiAgLy8gLS0tIE1lbW9pemVkIENvbnRleHQgVmFsdWUgLS0tXG4gIC8vIE1lbW9pemUgYXZhaWxhYmxlR3VpbGRzIHNlcGFyYXRlbHkgb25seSBpZiBpdCBjaGFuZ2VzIHNpZ25pZmljYW50bHlcbiAgY29uc3QgbWVtb2l6ZWRBdmFpbGFibGVHdWlsZHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdbQXV0aENvbnRleHRdIE1lbW9pemluZyBhdmFpbGFibGVHdWlsZHMuLi4nKTtcbiAgICAgIHJldHVybiBpbnRlcm5hbEF2YWlsYWJsZUd1aWxkcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbSlNPTi5zdHJpbmdpZnkoaW50ZXJuYWxBdmFpbGFibGVHdWlsZHMpXSk7IC8vIFVzZSBkZWVwIGNvbXBhcmlzb24sIGxlc3MgZWZmaWNpZW50IGJ1dCBzYWZlciBmb3Igbm93XG5cbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1tBdXRoQ29udGV4dF0gUmVjYWxjdWxhdGluZyBjb250ZXh0IHZhbHVlLicpO1xuICAgIHJldHVybiB7XG4gICAgICB1c2VyLFxuICAgICAgYXZhaWxhYmxlR3VpbGRzOiBtZW1vaXplZEF2YWlsYWJsZUd1aWxkcyxcbiAgICAgIHRva2VuLFxuICAgICAgbG9hZGluZyxcbiAgICAgIGlzQXV0aGVudGljYXRlZCxcbiAgICAgIGxvZ2luLFxuICAgICAgbG9nb3V0OiBoYW5kbGVMb2dvdXQsXG4gICAgICByZWZyZXNoU2Vzc2lvbixcbiAgICB9O1xuICB9LCBbdXNlciwgbWVtb2l6ZWRBdmFpbGFibGVHdWlsZHMsIHRva2VuLCBsb2FkaW5nLCBpc0F1dGhlbnRpY2F0ZWQsIGxvZ2luLCBoYW5kbGVMb2dvdXQsIHJlZnJlc2hTZXNzaW9uXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8QXV0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRWYWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9BdXRoQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwidXNlUm91dGVyIiwidXNlUGF0aG5hbWUiLCJzdXBhYmFzZSIsImRlZmF1bHRDb250ZXh0IiwidXNlciIsImF2YWlsYWJsZUd1aWxkcyIsInRva2VuIiwibG9hZGluZyIsImlzQXV0aGVudGljYXRlZCIsImxvZ2luIiwibG9nb3V0IiwicmVmcmVzaFNlc3Npb24iLCJBdXRoQ29udGV4dCIsInVzZUF1dGgiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInNldFVzZXIiLCJpbnRlcm5hbEF2YWlsYWJsZUd1aWxkcyIsInNldEludGVybmFsQXZhaWxhYmxlR3VpbGRzIiwic2V0VG9rZW4iLCJzZXRMb2FkaW5nIiwic2V0SXNBdXRoZW50aWNhdGVkIiwicm91dGVyIiwicGF0aG5hbWUiLCJoYW5kbGVMb2dvdXQiLCJyZWRpcmVjdCIsImNvbnNvbGUiLCJsb2ciLCJjdXJyZW50UGF0aCIsIndpbmRvdyIsImxvY2F0aW9uIiwidG9rZW5LZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVVUSF9UT0tFTl9LRVkiLCJsb2NhbFN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwiZXJyb3IiLCJhdXRoIiwic2lnbk91dCIsInN0YXJ0c1dpdGgiLCJwdXNoIiwiZmV0Y2hCYWNrZW5kU2Vzc2lvbiIsInN1cGFiYXNlVG9rZW4iLCJzZXNzaW9uRGF0YSIsImFwaVVybCIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJjYXRjaCIsInN0YXR1cyIsImpzb24iLCJ1c2VybmFtZSIsInByZXYiLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0SXRlbSIsImRhdGEiLCJhdXRoTGlzdGVuZXIiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImV2ZW50Iiwic2Vzc2lvbiIsImFjY2Vzc190b2tlbiIsInN1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlIiwic2lnbkluV2l0aE9BdXRoIiwicHJvdmlkZXIiLCJvcHRpb25zIiwicmVkaXJlY3RUbyIsInByb3RvY29sIiwiaG9zdCIsInNjb3BlcyIsImdldFNlc3Npb24iLCJ3YXJuIiwicmVwbGFjZSIsIm1lbW9pemVkQXZhaWxhYmxlR3VpbGRzIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/auth-context.tsx\n"));

/***/ })

});