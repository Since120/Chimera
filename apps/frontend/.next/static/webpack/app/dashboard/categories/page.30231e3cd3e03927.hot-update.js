"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/categories/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/category-management/hooks/useZones.ts":
/*!************************************************************************!*\
  !*** ./src/components/dashboard/category-management/hooks/useZones.ts ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useZones: () => (/* binding */ useZones)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/core/toaster */ \"(app-pages-browser)/./src/components/core/toaster.tsx\");\n/* harmony import */ var _services_zones__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/services/zones */ \"(app-pages-browser)/./src/services/zones.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useZones auto */ \n\n// import { formatDate } from '../utils/formatters'; // Wahrscheinlich nicht benötigt\n// import { useGuild } from '@/context/guild-context'; // Nicht direkt benötigt\n\n\nconst useZones = (categoryId)=>{\n    // guildId wird hier nicht direkt benötigt\n    const [zones, setZones] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const realtimeChannelRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadedCategoryIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)('');\n    // --- Memoized Ladefunktion ---\n    const loadZones = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[loadZones]\": async (categoryIdToLoad)=>{\n            if (!categoryIdToLoad) {\n                console.log('[useZones] loadZones: Keine Kategorie ID.');\n                setZones([]);\n                return;\n            }\n            console.log(\"[useZones] loadZones aufgerufen f\\xfcr Kategorie: \".concat(categoryIdToLoad));\n            setLoading(true);\n            setError(null);\n            try {\n                const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_2__.getZonesByCategory(categoryIdToLoad);\n                const enhancedZones = zonesData.map({\n                    \"useZones.useCallback[loadZones].enhancedZones\": (zone)=>({\n                            id: zone.id,\n                            name: zone.name,\n                            zoneKey: zone.zoneKey,\n                            minutesRequired: zone.intervalMinutes,\n                            pointsGranted: zone.pointsPerInterval,\n                            lastActive: '-',\n                            totalTimeSpent: 0,\n                            totalUsers: 0\n                        })\n                }[\"useZones.useCallback[loadZones].enhancedZones\"]);\n                setZones(enhancedZones);\n                loadedCategoryIdRef.current = categoryIdToLoad;\n                console.log(\"[useZones] loadZones: \".concat(enhancedZones.length, \" Zonen geladen f\\xfcr \").concat(categoryIdToLoad));\n            } catch (err) {\n                console.error(\"[useZones] Fehler beim Laden der Zonen f\\xfcr \".concat(categoryIdToLoad, \":\"), err);\n                setError('Fehler beim Laden der Zonen');\n                setZones([]);\n                loadedCategoryIdRef.current = categoryIdToLoad; // Trotz Fehler als geladen markieren\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useZones.useCallback[loadZones]\"], []); // Keine Abhängigkeiten\n    // --- Memoized Realtime Handler ---\n    const handleZoneChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[handleZoneChange]\": (payload)=>{\n            console.log('[HANDLER CALLED] handleZoneChange', payload); // <-- Logging hinzufügen\n            console.log(\"[useZones Realtime] Zonen-\\xc4nderung erkannt:\", payload);\n            const { eventType, new: newRecord, old: oldRecord, table, schema } = payload;\n            // Filterung: Nur auf 'zones' Tabelle und korrektes Schema reagieren\n            if (schema !== 'public' || table !== 'zones') return;\n            // Filterung: Nur auf Änderungen reagieren, die die aktuelle categoryId betreffen\n            const newRecordCategoryId = newRecord ? newRecord.category_id : null;\n            const oldRecordCategoryId = oldRecord ? oldRecord.category_id : null;\n            if (newRecordCategoryId !== categoryId && oldRecordCategoryId !== categoryId) {\n                console.log(\"[useZones Realtime] Event ignoriert, falsche Category ID.\");\n                return;\n            }\n            const record = newRecord || oldRecord;\n            if (!record || !record.id) return;\n            const zoneId = record.id;\n            switch(eventType){\n                case 'INSERT':\n                case 'UPDATE':\n                    try {\n                        console.log(\"[Handler Logic START] \".concat(eventType, \" Zone\"));\n                        // Direkte Verwendung der Payload-Daten ohne API-Call\n                        if (!newRecord) {\n                            console.error(\"[useZones Realtime] Fehler: Keine newRecord-Daten f\\xfcr \".concat(eventType));\n                            return;\n                        }\n                        // Mapping aus den Payload-Daten\n                        const enhancedZone = {\n                            id: newRecord.id,\n                            name: newRecord.name,\n                            zoneKey: newRecord.zone_key,\n                            minutesRequired: newRecord.interval_minutes,\n                            pointsGranted: newRecord.points_per_interval,\n                            lastActive: '-',\n                            totalTimeSpent: 0,\n                            totalUsers: 0\n                        };\n                        console.log('[Zones State BEFORE update]', zones);\n                        setZones({\n                            \"useZones.useCallback[handleZoneChange]\": (prev)=>{\n                                const index = prev.findIndex({\n                                    \"useZones.useCallback[handleZoneChange].index\": (z)=>z.id === zoneId\n                                }[\"useZones.useCallback[handleZoneChange].index\"]);\n                                let newState;\n                                if (index !== -1) {\n                                    console.log(\"[Zone \".concat(eventType, \"] Updating existing zone at index \").concat(index));\n                                    newState = [\n                                        ...prev\n                                    ];\n                                    newState[index] = enhancedZone;\n                                } else {\n                                    // Nur hinzufügen, wenn es wirklich zu dieser Kategorie gehört\n                                    if (newRecord.category_id === categoryId) {\n                                        console.log(\"[Zone \".concat(eventType, \"] Adding new zone to category \").concat(categoryId));\n                                        newState = [\n                                            ...prev,\n                                            enhancedZone\n                                        ];\n                                    } else {\n                                        console.log(\"[Zone \".concat(eventType, \"] Zone belongs to different category, ignoring\"));\n                                        newState = prev;\n                                    }\n                                }\n                                console.log('[Zones State AFTER update (calculated)]', newState);\n                                return newState;\n                            }\n                        }[\"useZones.useCallback[handleZoneChange]\"]);\n                        // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                        setTimeout({\n                            \"useZones.useCallback[handleZoneChange]\": ()=>{\n                                console.log('[Zones State AFTER update (actual)]', zones);\n                            }\n                        }[\"useZones.useCallback[handleZoneChange]\"], 0);\n                        console.log(\"[Handler Logic END] \".concat(eventType, \" Zone\"));\n                    } catch (error) {\n                        console.error(\"[useZones Realtime] Fehler beim Verarbeiten \".concat(eventType, \":\"), error);\n                    }\n                    break;\n                case 'DELETE':\n                    if (oldRecord === null || oldRecord === void 0 ? void 0 : oldRecord.id) {\n                        console.log(\"[Handler Logic START] DELETE Zone \".concat(oldRecord.id));\n                        console.log('[Zones State BEFORE delete]', zones);\n                        setZones({\n                            \"useZones.useCallback[handleZoneChange]\": (prev)=>{\n                                console.log(\"[Zone DELETE] Removing zone with id \".concat(oldRecord.id));\n                                const newState = prev.filter({\n                                    \"useZones.useCallback[handleZoneChange].newState\": (zone)=>zone.id !== oldRecord.id\n                                }[\"useZones.useCallback[handleZoneChange].newState\"]);\n                                console.log('[Zones State AFTER delete (calculated)]', newState);\n                                return newState;\n                            }\n                        }[\"useZones.useCallback[handleZoneChange]\"]);\n                        // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                        setTimeout({\n                            \"useZones.useCallback[handleZoneChange]\": ()=>{\n                                console.log('[Zones State AFTER delete (actual)]', zones);\n                            }\n                        }[\"useZones.useCallback[handleZoneChange]\"], 0);\n                        console.log(\"[Handler Logic END] DELETE Zone \".concat(oldRecord.id));\n                    }\n                    break;\n                default:\n                    console.log(\"[useZones Realtime] Unbekannter Event-Typ f\\xfcr zones: \".concat(eventType));\n            }\n        }\n    }[\"useZones.useCallback[handleZoneChange]\"], [\n        categoryId,\n        zones,\n        setZones\n    ]); // Abhängigkeiten für korrekte Aktualisierung\n    // --- Haupt-useEffect ---\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useZones.useEffect\": ()=>{\n            console.log(\"[useZones Effect] Running for categoryId: \".concat(categoryId || 'none'));\n            if (!categoryId) {\n                console.log('[useZones Effect] No categoryId, resetting.');\n                setZones([]);\n                loadedCategoryIdRef.current = '';\n                if (realtimeChannelRef.current) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.removeChannel(realtimeChannelRef.current).then({\n                        \"useZones.useEffect\": ()=>{\n                            console.log('[useZones Effect] Removed old channel on categoryId clear.');\n                            realtimeChannelRef.current = null;\n                        }\n                    }[\"useZones.useEffect\"]);\n                }\n                return;\n            }\n            if (loadedCategoryIdRef.current !== categoryId) {\n                loadZones(categoryId);\n            }\n            // Subscription Logik\n            let channel = realtimeChannelRef.current;\n            const channelName = \"zones:\".concat(categoryId);\n            if (!channel || channel.topic !== \"realtime:\".concat(channelName)) {\n                if (channel) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.removeChannel(channel).then({\n                        \"useZones.useEffect\": ()=>{\n                            console.log('[useZones Effect] Removed previous channel.');\n                            realtimeChannelRef.current = null;\n                        }\n                    }[\"useZones.useEffect\"]);\n                }\n                console.log(\"[useZones Effect] Setting up channel: \".concat(channelName));\n                channel = _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.channel(channelName);\n                channel.on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'zones',\n                    filter: \"category_id=eq.\".concat(categoryId) // Filter auf Server-Seite!\n                }, {\n                    \"useZones.useEffect\": (payload)=>{\n                        console.log('[useZones RAW EVENT zones]', payload); // <-- Logging hinzufügen\n                        handleZoneChange(payload);\n                    }\n                }[\"useZones.useEffect\"]).subscribe({\n                    \"useZones.useEffect\": (status, err)=>{\n                        console.log(\"[useZones Effect] Sub status \".concat(channelName, \":\"), status, err || '');\n                        if (status === 'SUBSCRIBED') {\n                            realtimeChannelRef.current = channel;\n                            if (loadedCategoryIdRef.current !== categoryId) {\n                                loadZones(categoryId); // Erneutes Laden nach erfolgreicher Subscription\n                            }\n                        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {\n                            console.error(\"[useZones Effect] Subscription failed for \".concat(channelName, \":\"), err);\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }[\"useZones.useEffect\"]);\n            }\n            // Cleanup\n            return ({\n                \"useZones.useEffect\": ()=>{\n                    console.log(\"[useZones Effect] Cleanup for categoryId: \".concat(categoryId));\n                    if (channel && (!realtimeChannelRef.current || realtimeChannelRef.current === channel)) {\n                        console.log(\"[useZones Effect] Removing channel \".concat(channel.topic));\n                        _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.removeChannel(channel);\n                        if (realtimeChannelRef.current === channel) {\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }\n            })[\"useZones.useEffect\"];\n        }\n    }[\"useZones.useEffect\"], [\n        categoryId,\n        loadZones,\n        handleZoneChange\n    ]); // Korrekte Abhängigkeiten\n    // --- Restliche Funktionen (weitgehend unverändert) ---\n    const saveZone = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[saveZone]\": async (zoneData)=>{\n            if (!categoryId) {\n                return false;\n            }\n            setLoading(true);\n            try {\n                if (zoneData.id) {} else {}\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Zone gespeichert.');\n                return true;\n            } catch (err) {\n                return false;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useZones.useCallback[saveZone]\"], [\n        categoryId\n    ]);\n    const deleteZone = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[deleteZone]\": async (zoneId)=>{\n            setLoading(true);\n            try {\n                const result = await _services_zones__WEBPACK_IMPORTED_MODULE_2__.deleteZone(zoneId);\n                if (result.success) _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Zone gelöscht.');\n                return result;\n            } catch (err) {\n                return {\n                    success: false,\n                    message: 'Fehler'\n                };\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useZones.useCallback[deleteZone]\"], []);\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[refetch]\": ()=>{\n            console.log('[useZones] refetch: Starte Neuladen');\n            if (categoryId) {\n                loadedCategoryIdRef.current = '';\n                loadZones(categoryId);\n            }\n        }\n    }[\"useZones.useCallback[refetch]\"], [\n        categoryId,\n        loadZones\n    ]);\n    return {\n        zones,\n        loading,\n        error,\n        saveZone,\n        deleteZone,\n        refetch\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9jYXRlZ29yeS1tYW5hZ2VtZW50L2hvb2tzL3VzZVpvbmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs4REFFaUU7QUFDZjtBQUVsRCxxRkFBcUY7QUFDckYsK0VBQStFO0FBQzlCO0FBR1A7QUFXbkMsTUFBTU8sV0FBVyxDQUFDQztJQUN2QiwwQ0FBMEM7SUFDMUMsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdWLCtDQUFRQSxDQUFpQixFQUFFO0lBQ3JELE1BQU0sQ0FBQ1csU0FBU0MsV0FBVyxHQUFHWiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNhLE9BQU9DLFNBQVMsR0FBR2QsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU1lLHFCQUFxQlosNkNBQU1BLENBQXlCO0lBQzFELE1BQU1hLHNCQUFzQmIsNkNBQU1BLENBQVM7SUFFM0MsZ0NBQWdDO0lBQ2hDLE1BQU1jLFlBQVlmLGtEQUFXQTsyQ0FBQyxPQUFPZ0I7WUFDbkMsSUFBSSxDQUFDQSxrQkFBa0I7Z0JBQ3JCQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1pWLFNBQVMsRUFBRTtnQkFDWDtZQUNGO1lBQ0FTLFFBQVFDLEdBQUcsQ0FBQyxxREFBbUUsT0FBakJGO1lBQzlETixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxJQUFJO2dCQUNGLE1BQU1PLFlBQVksTUFBTWhCLCtEQUErQixDQUFDYTtnQkFDeEQsTUFBTUssZ0JBQWdDRixVQUFVRyxHQUFHO3FFQUFDQyxDQUFBQSxPQUFTOzRCQUMzREMsSUFBSUQsS0FBS0MsRUFBRTs0QkFDWEMsTUFBTUYsS0FBS0UsSUFBSTs0QkFDZkMsU0FBU0gsS0FBS0csT0FBTzs0QkFDckJDLGlCQUFpQkosS0FBS0ssZUFBZTs0QkFDckNDLGVBQWVOLEtBQUtPLGlCQUFpQjs0QkFDckNDLFlBQVk7NEJBQ1pDLGdCQUFnQjs0QkFDaEJDLFlBQVk7d0JBQ2Q7O2dCQUVBekIsU0FBU2E7Z0JBQ1RQ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O3lDQUFHO1FBQUNKO0tBQVc7SUFFZixNQUFNb0UsYUFBYTFFLGtEQUFXQTs0Q0FBQyxPQUFPa0Q7WUFDbEN4QyxXQUFXO1lBQ1gsSUFBSTtnQkFDRCxNQUFNaUUsU0FBUyxNQUFNeEUsdURBQXVCLENBQUMrQztnQkFDN0MsSUFBSXlCLE9BQU9GLE9BQU8sRUFBRXZFLDJEQUFLQSxDQUFDdUUsT0FBTyxDQUFDO2dCQUNsQyxPQUFPRTtZQUNWLEVBQUUsT0FBT3ZDLEtBQVU7Z0JBQXVCLE9BQU87b0JBQUVxQyxTQUFTO29CQUFPRyxTQUFTO2dCQUFTO1lBQUcsU0FDaEY7Z0JBQUVsRSxXQUFXO1lBQVE7UUFDakM7MkNBQUcsRUFBRTtJQUVMLE1BQU1tRSxVQUFVN0Usa0RBQVdBO3lDQUFDO1lBQzFCaUIsUUFBUUMsR0FBRyxDQUFDO1lBQ1osSUFBSVosWUFBWTtnQkFDZFEsb0JBQW9Cb0IsT0FBTyxHQUFHO2dCQUM5Qm5CLFVBQVVUO1lBQ1o7UUFDRjt3Q0FBRztRQUFDQTtRQUFZUztLQUFVO0lBRzFCLE9BQU87UUFBRVI7UUFBT0U7UUFBU0U7UUFBTzREO1FBQVVHO1FBQVlHO0lBQVE7QUFDaEUsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxpbmZvXFxEb2N1bWVudHNcXERpc2NvcmQgQm90XFxDaGltZXJhXFxhcHBzXFxmcm9udGVuZFxcc3JjXFxjb21wb25lbnRzXFxkYXNoYm9hcmRcXGNhdGVnb3J5LW1hbmFnZW1lbnRcXGhvb2tzXFx1c2Vab25lcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ0AvY29tcG9uZW50cy9jb3JlL3RvYXN0ZXInO1xuaW1wb3J0IHsgRW5oYW5jZWRab25lIH0gZnJvbSAnLi91c2VDYXRlZ29yaWVzJzsgLy8gVHlwIGltcG9ydGllcmVuXG4vLyBpbXBvcnQgeyBmb3JtYXREYXRlIH0gZnJvbSAnLi4vdXRpbHMvZm9ybWF0dGVycyc7IC8vIFdhaHJzY2hlaW5saWNoIG5pY2h0IGJlbsO2dGlndFxuLy8gaW1wb3J0IHsgdXNlR3VpbGQgfSBmcm9tICdAL2NvbnRleHQvZ3VpbGQtY29udGV4dCc7IC8vIE5pY2h0IGRpcmVrdCBiZW7DtnRpZ3RcbmltcG9ydCAqIGFzIHpvbmVzU2VydmljZSBmcm9tICdAL3NlcnZpY2VzL3pvbmVzJztcbi8vIE51ciBkaWUgdGF0c8OkY2hsaWNoIHZlcndlbmRldGVuIFR5cGVuIGltcG9ydGllcmVuXG5pbXBvcnQgeyBSZWFsdGltZUNoYW5uZWwsIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcblxuLy8gSW50ZXJmYWNlIGJsZWlidCBnbGVpY2guLi5cbmV4cG9ydCBpbnRlcmZhY2UgWm9uZUlucHV0IHtcbiAgaWQ/OiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgem9uZUtleTogc3RyaW5nO1xuICBtaW51dGVzUmVxdWlyZWQ6IG51bWJlcjtcbiAgcG9pbnRzR3JhbnRlZDogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgdXNlWm9uZXMgPSAoY2F0ZWdvcnlJZD86IHN0cmluZykgPT4ge1xuICAvLyBndWlsZElkIHdpcmQgaGllciBuaWNodCBkaXJla3QgYmVuw7Z0aWd0XG4gIGNvbnN0IFt6b25lcywgc2V0Wm9uZXNdID0gdXNlU3RhdGU8RW5oYW5jZWRab25lW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCByZWFsdGltZUNoYW5uZWxSZWYgPSB1c2VSZWY8UmVhbHRpbWVDaGFubmVsIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGxvYWRlZENhdGVnb3J5SWRSZWYgPSB1c2VSZWY8c3RyaW5nPignJyk7XG5cbiAgLy8gLS0tIE1lbW9pemVkIExhZGVmdW5rdGlvbiAtLS1cbiAgY29uc3QgbG9hZFpvbmVzID0gdXNlQ2FsbGJhY2soYXN5bmMgKGNhdGVnb3J5SWRUb0xvYWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghY2F0ZWdvcnlJZFRvTG9hZCkge1xuICAgICAgY29uc29sZS5sb2coJ1t1c2Vab25lc10gbG9hZFpvbmVzOiBLZWluZSBLYXRlZ29yaWUgSUQuJyk7XG4gICAgICBzZXRab25lcyhbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGBbdXNlWm9uZXNdIGxvYWRab25lcyBhdWZnZXJ1ZmVuIGbDvHIgS2F0ZWdvcmllOiAke2NhdGVnb3J5SWRUb0xvYWR9YCk7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB6b25lc0RhdGEgPSBhd2FpdCB6b25lc1NlcnZpY2UuZ2V0Wm9uZXNCeUNhdGVnb3J5KGNhdGVnb3J5SWRUb0xvYWQpO1xuICAgICAgY29uc3QgZW5oYW5jZWRab25lczogRW5oYW5jZWRab25lW10gPSB6b25lc0RhdGEubWFwKHpvbmUgPT4gKHtcbiAgICAgICAgaWQ6IHpvbmUuaWQsXG4gICAgICAgIG5hbWU6IHpvbmUubmFtZSxcbiAgICAgICAgem9uZUtleTogem9uZS56b25lS2V5LFxuICAgICAgICBtaW51dGVzUmVxdWlyZWQ6IHpvbmUuaW50ZXJ2YWxNaW51dGVzLFxuICAgICAgICBwb2ludHNHcmFudGVkOiB6b25lLnBvaW50c1BlckludGVydmFsLFxuICAgICAgICBsYXN0QWN0aXZlOiAnLScsXG4gICAgICAgIHRvdGFsVGltZVNwZW50OiAwLFxuICAgICAgICB0b3RhbFVzZXJzOiAwXG4gICAgICB9KSk7XG5cbiAgICAgIHNldFpvbmVzKGVuaGFuY2VkWm9uZXMpO1xuICAgICAgbG9hZGVkQ2F0ZWdvcnlJZFJlZi5jdXJyZW50ID0gY2F0ZWdvcnlJZFRvTG9hZDtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlWm9uZXNdIGxvYWRab25lczogJHtlbmhhbmNlZFpvbmVzLmxlbmd0aH0gWm9uZW4gZ2VsYWRlbiBmw7xyICR7Y2F0ZWdvcnlJZFRvTG9hZH1gKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFt1c2Vab25lc10gRmVobGVyIGJlaW0gTGFkZW4gZGVyIFpvbmVuIGbDvHIgJHtjYXRlZ29yeUlkVG9Mb2FkfTpgLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoJ0ZlaGxlciBiZWltIExhZGVuIGRlciBab25lbicpO1xuICAgICAgc2V0Wm9uZXMoW10pO1xuICAgICAgbG9hZGVkQ2F0ZWdvcnlJZFJlZi5jdXJyZW50ID0gY2F0ZWdvcnlJZFRvTG9hZDsgLy8gVHJvdHogRmVobGVyIGFscyBnZWxhZGVuIG1hcmtpZXJlblxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtdKTsgLy8gS2VpbmUgQWJow6RuZ2lna2VpdGVuXG5cbiAgLy8gLS0tIE1lbW9pemVkIFJlYWx0aW1lIEhhbmRsZXIgLS0tXG4gIGNvbnN0IGhhbmRsZVpvbmVDaGFuZ2UgPSB1c2VDYWxsYmFjaygocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPGFueT4pID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0hBTkRMRVIgQ0FMTEVEXSBoYW5kbGVab25lQ2hhbmdlJywgcGF5bG9hZCk7IC8vIDwtLSBMb2dnaW5nIGhpbnp1ZsO8Z2VuXG4gICAgY29uc29sZS5sb2coYFt1c2Vab25lcyBSZWFsdGltZV0gWm9uZW4tw4RuZGVydW5nIGVya2FubnQ6YCwgcGF5bG9hZCk7XG4gICAgY29uc3QgeyBldmVudFR5cGUsIG5ldzogbmV3UmVjb3JkLCBvbGQ6IG9sZFJlY29yZCwgdGFibGUsIHNjaGVtYSB9ID0gcGF5bG9hZDtcblxuICAgIC8vIEZpbHRlcnVuZzogTnVyIGF1ZiAnem9uZXMnIFRhYmVsbGUgdW5kIGtvcnJla3RlcyBTY2hlbWEgcmVhZ2llcmVuXG4gICAgaWYgKHNjaGVtYSAhPT0gJ3B1YmxpYycgfHwgdGFibGUgIT09ICd6b25lcycpIHJldHVybjtcbiAgICAvLyBGaWx0ZXJ1bmc6IE51ciBhdWYgw4RuZGVydW5nZW4gcmVhZ2llcmVuLCBkaWUgZGllIGFrdHVlbGxlIGNhdGVnb3J5SWQgYmV0cmVmZmVuXG4gICAgY29uc3QgbmV3UmVjb3JkQ2F0ZWdvcnlJZCA9IG5ld1JlY29yZCA/IChuZXdSZWNvcmQgYXMgYW55KS5jYXRlZ29yeV9pZCA6IG51bGw7XG4gICAgY29uc3Qgb2xkUmVjb3JkQ2F0ZWdvcnlJZCA9IG9sZFJlY29yZCA/IChvbGRSZWNvcmQgYXMgYW55KS5jYXRlZ29yeV9pZCA6IG51bGw7XG5cbiAgICBpZiAobmV3UmVjb3JkQ2F0ZWdvcnlJZCAhPT0gY2F0ZWdvcnlJZCAmJiBvbGRSZWNvcmRDYXRlZ29yeUlkICE9PSBjYXRlZ29yeUlkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlWm9uZXMgUmVhbHRpbWVdIEV2ZW50IGlnbm9yaWVydCwgZmFsc2NoZSBDYXRlZ29yeSBJRC5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgY29uc3QgcmVjb3JkID0gbmV3UmVjb3JkIHx8IG9sZFJlY29yZDtcbiAgICBpZiAoIXJlY29yZCB8fCAhcmVjb3JkLmlkKSByZXR1cm47XG5cbiAgICBjb25zdCB6b25lSWQgPSByZWNvcmQuaWQ7XG5cbiAgICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgICAgY2FzZSAnSU5TRVJUJzpcbiAgICAgIGNhc2UgJ1VQREFURSc6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljIFNUQVJUXSAke2V2ZW50VHlwZX0gWm9uZWApO1xuXG4gICAgICAgICAgLy8gRGlyZWt0ZSBWZXJ3ZW5kdW5nIGRlciBQYXlsb2FkLURhdGVuIG9obmUgQVBJLUNhbGxcbiAgICAgICAgICBpZiAoIW5ld1JlY29yZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW3VzZVpvbmVzIFJlYWx0aW1lXSBGZWhsZXI6IEtlaW5lIG5ld1JlY29yZC1EYXRlbiBmw7xyICR7ZXZlbnRUeXBlfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1hcHBpbmcgYXVzIGRlbiBQYXlsb2FkLURhdGVuXG4gICAgICAgICAgY29uc3QgZW5oYW5jZWRab25lOiBFbmhhbmNlZFpvbmUgPSB7XG4gICAgICAgICAgICBpZDogbmV3UmVjb3JkLmlkLFxuICAgICAgICAgICAgbmFtZTogbmV3UmVjb3JkLm5hbWUsXG4gICAgICAgICAgICB6b25lS2V5OiBuZXdSZWNvcmQuem9uZV9rZXksXG4gICAgICAgICAgICBtaW51dGVzUmVxdWlyZWQ6IG5ld1JlY29yZC5pbnRlcnZhbF9taW51dGVzLFxuICAgICAgICAgICAgcG9pbnRzR3JhbnRlZDogbmV3UmVjb3JkLnBvaW50c19wZXJfaW50ZXJ2YWwsXG4gICAgICAgICAgICBsYXN0QWN0aXZlOiAnLScsXG4gICAgICAgICAgICB0b3RhbFRpbWVTcGVudDogMCxcbiAgICAgICAgICAgIHRvdGFsVXNlcnM6IDBcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc29sZS5sb2coJ1tab25lcyBTdGF0ZSBCRUZPUkUgdXBkYXRlXScsIHpvbmVzKTtcbiAgICAgICAgICBzZXRab25lcyhwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcHJldi5maW5kSW5kZXgoeiA9PiB6LmlkID09PSB6b25lSWQpO1xuICAgICAgICAgICAgbGV0IG5ld1N0YXRlO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbWm9uZSAke2V2ZW50VHlwZX1dIFVwZGF0aW5nIGV4aXN0aW5nIHpvbmUgYXQgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbLi4ucHJldl07XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2luZGV4XSA9IGVuaGFuY2VkWm9uZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE51ciBoaW56dWbDvGdlbiwgd2VubiBlcyB3aXJrbGljaCB6dSBkaWVzZXIgS2F0ZWdvcmllIGdlaMO2cnRcbiAgICAgICAgICAgICAgaWYgKG5ld1JlY29yZC5jYXRlZ29yeV9pZCA9PT0gY2F0ZWdvcnlJZCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtab25lICR7ZXZlbnRUeXBlfV0gQWRkaW5nIG5ldyB6b25lIHRvIGNhdGVnb3J5ICR7Y2F0ZWdvcnlJZH1gKTtcbiAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gWy4uLnByZXYsIGVuaGFuY2VkWm9uZV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1pvbmUgJHtldmVudFR5cGV9XSBab25lIGJlbG9uZ3MgdG8gZGlmZmVyZW50IGNhdGVnb3J5LCBpZ25vcmluZ2ApO1xuICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBwcmV2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbWm9uZXMgU3RhdGUgQUZURVIgdXBkYXRlIChjYWxjdWxhdGVkKV0nLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBMb2dnZSBkZW4gU3RhdGUgbmFjaCBkZXIgQWt0dWFsaXNpZXJ1bmcgKGltIG7DpGNoc3RlbiBSZW5kZXItWnlrbHVzKVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tab25lcyBTdGF0ZSBBRlRFUiB1cGRhdGUgKGFjdHVhbCldJywgem9uZXMpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFuZGxlciBMb2dpYyBFTkRdICR7ZXZlbnRUeXBlfSBab25lYCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW3VzZVpvbmVzIFJlYWx0aW1lXSBGZWhsZXIgYmVpbSBWZXJhcmJlaXRlbiAke2V2ZW50VHlwZX06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnREVMRVRFJzpcbiAgICAgICAgaWYgKG9sZFJlY29yZD8uaWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0hhbmRsZXIgTG9naWMgU1RBUlRdIERFTEVURSBab25lICR7b2xkUmVjb3JkLmlkfWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbWm9uZXMgU3RhdGUgQkVGT1JFIGRlbGV0ZV0nLCB6b25lcyk7XG5cbiAgICAgICAgICBzZXRab25lcyhwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbWm9uZSBERUxFVEVdIFJlbW92aW5nIHpvbmUgd2l0aCBpZCAke29sZFJlY29yZC5pZH1gKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gcHJldi5maWx0ZXIoem9uZSA9PiB6b25lLmlkICE9PSBvbGRSZWNvcmQuaWQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tab25lcyBTdGF0ZSBBRlRFUiBkZWxldGUgKGNhbGN1bGF0ZWQpXScsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIExvZ2dlIGRlbiBTdGF0ZSBuYWNoIGRlciBBa3R1YWxpc2llcnVuZyAoaW0gbsOkY2hzdGVuIFJlbmRlci1aeWtsdXMpXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1pvbmVzIFN0YXRlIEFGVEVSIGRlbGV0ZSAoYWN0dWFsKV0nLCB6b25lcyk7XG4gICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0hhbmRsZXIgTG9naWMgRU5EXSBERUxFVEUgWm9uZSAke29sZFJlY29yZC5pZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlWm9uZXMgUmVhbHRpbWVdIFVuYmVrYW5udGVyIEV2ZW50LVR5cCBmw7xyIHpvbmVzOiAke2V2ZW50VHlwZX1gKTtcbiAgICB9XG4gIH0sIFtjYXRlZ29yeUlkLCB6b25lcywgc2V0Wm9uZXNdKTsgLy8gQWJow6RuZ2lna2VpdGVuIGbDvHIga29ycmVrdGUgQWt0dWFsaXNpZXJ1bmdcblxuICAvLyAtLS0gSGF1cHQtdXNlRWZmZWN0IC0tLVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBbdXNlWm9uZXMgRWZmZWN0XSBSdW5uaW5nIGZvciBjYXRlZ29yeUlkOiAke2NhdGVnb3J5SWQgfHwgJ25vbmUnfWApO1xuXG4gICAgaWYgKCFjYXRlZ29yeUlkKSB7XG4gICAgICBjb25zb2xlLmxvZygnW3VzZVpvbmVzIEVmZmVjdF0gTm8gY2F0ZWdvcnlJZCwgcmVzZXR0aW5nLicpO1xuICAgICAgc2V0Wm9uZXMoW10pO1xuICAgICAgbG9hZGVkQ2F0ZWdvcnlJZFJlZi5jdXJyZW50ID0gJyc7XG4gICAgICBpZiAocmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc3VwYWJhc2UucmVtb3ZlQ2hhbm5lbChyZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZVpvbmVzIEVmZmVjdF0gUmVtb3ZlZCBvbGQgY2hhbm5lbCBvbiBjYXRlZ29yeUlkIGNsZWFyLicpO1xuICAgICAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobG9hZGVkQ2F0ZWdvcnlJZFJlZi5jdXJyZW50ICE9PSBjYXRlZ29yeUlkKSB7XG4gICAgICBsb2FkWm9uZXMoY2F0ZWdvcnlJZCk7XG4gICAgfVxuXG4gICAgLy8gU3Vic2NyaXB0aW9uIExvZ2lrXG4gICAgbGV0IGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCB8IG51bGwgPSByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudDtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IGB6b25lczoke2NhdGVnb3J5SWR9YDtcblxuICAgIGlmICghY2hhbm5lbCB8fCBjaGFubmVsLnRvcGljICE9PSBgcmVhbHRpbWU6JHtjaGFubmVsTmFtZX1gKSB7XG4gICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZVpvbmVzIEVmZmVjdF0gUmVtb3ZlZCBwcmV2aW91cyBjaGFubmVsLicpO1xuICAgICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW3VzZVpvbmVzIEVmZmVjdF0gU2V0dGluZyB1cCBjaGFubmVsOiAke2NoYW5uZWxOYW1lfWApO1xuICAgICAgY2hhbm5lbCA9IHN1cGFiYXNlLmNoYW5uZWwoY2hhbm5lbE5hbWUpO1xuXG4gICAgICBjaGFubmVsXG4gICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHtcbiAgICAgICAgICBldmVudDogJyonLCAvLyBMYXVzY2hlIGF1ZiBhbGxlIEV2ZW50c1xuICAgICAgICAgIHNjaGVtYTogJ3B1YmxpYycsXG4gICAgICAgICAgdGFibGU6ICd6b25lcycsXG4gICAgICAgICAgZmlsdGVyOiBgY2F0ZWdvcnlfaWQ9ZXEuJHtjYXRlZ29yeUlkfWAgLy8gRmlsdGVyIGF1ZiBTZXJ2ZXItU2VpdGUhXG4gICAgICAgIH0sIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1t1c2Vab25lcyBSQVcgRVZFTlQgem9uZXNdJywgcGF5bG9hZCk7IC8vIDwtLSBMb2dnaW5nIGhpbnp1ZsO8Z2VuXG4gICAgICAgICAgaGFuZGxlWm9uZUNoYW5nZShwYXlsb2FkKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnN1YnNjcmliZSgoc3RhdHVzLCBlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZVpvbmVzIEVmZmVjdF0gU3ViIHN0YXR1cyAke2NoYW5uZWxOYW1lfTpgLCBzdGF0dXMsIGVyciB8fCAnJyk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ1NVQlNDUklCRUQnKSB7XG4gICAgICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IGNoYW5uZWw7XG4gICAgICAgICAgICBpZiAobG9hZGVkQ2F0ZWdvcnlJZFJlZi5jdXJyZW50ICE9PSBjYXRlZ29yeUlkKSB7XG4gICAgICAgICAgICAgIGxvYWRab25lcyhjYXRlZ29yeUlkKTsgLy8gRXJuZXV0ZXMgTGFkZW4gbmFjaCBlcmZvbGdyZWljaGVyIFN1YnNjcmlwdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAnQ0hBTk5FTF9FUlJPUicgfHwgc3RhdHVzID09PSAnVElNRURfT1VUJykge1xuICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFt1c2Vab25lcyBFZmZlY3RdIFN1YnNjcmlwdGlvbiBmYWlsZWQgZm9yICR7Y2hhbm5lbE5hbWV9OmAsIGVycik7XG4gICAgICAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZVpvbmVzIEVmZmVjdF0gQ2xlYW51cCBmb3IgY2F0ZWdvcnlJZDogJHtjYXRlZ29yeUlkfWApO1xuICAgICAgaWYgKGNoYW5uZWwgJiYgKCFyZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCB8fCByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9PT0gY2hhbm5lbCkpIHtcbiAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlWm9uZXMgRWZmZWN0XSBSZW1vdmluZyBjaGFubmVsICR7Y2hhbm5lbC50b3BpY31gKTtcbiAgICAgICAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwoY2hhbm5lbCk7XG4gICAgICAgICBpZiAocmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPT09IGNoYW5uZWwpIHtcbiAgICAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtjYXRlZ29yeUlkLCBsb2FkWm9uZXMsIGhhbmRsZVpvbmVDaGFuZ2VdKTsgLy8gS29ycmVrdGUgQWJow6RuZ2lna2VpdGVuXG5cbiAgLy8gLS0tIFJlc3RsaWNoZSBGdW5rdGlvbmVuICh3ZWl0Z2VoZW5kIHVudmVyw6RuZGVydCkgLS0tXG4gIGNvbnN0IHNhdmVab25lID0gdXNlQ2FsbGJhY2soYXN5bmMgKHpvbmVEYXRhOiBab25lSW5wdXQpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgIGlmICghY2F0ZWdvcnlJZCkgeyAvKiAuLi4gRmVobGVyIC4uLiAqLyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICB0cnkge1xuICAgICAgICAgaWYgKHpvbmVEYXRhLmlkKSB7IC8qIC4uLiBVcGRhdGUgLi4uICovIH1cbiAgICAgICAgIGVsc2UgeyAvKiAuLi4gQ3JlYXRlIC4uLiAqLyB9XG4gICAgICAgICB0b2FzdC5zdWNjZXNzKCdab25lIGdlc3BlaWNoZXJ0LicpO1xuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnI6IGFueSkgeyAvKiAuLi4gRmVobGVyIC4uLiAqLyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGZpbmFsbHkgeyBzZXRMb2FkaW5nKGZhbHNlKTsgfVxuICB9LCBbY2F0ZWdvcnlJZF0pO1xuXG4gIGNvbnN0IGRlbGV0ZVpvbmUgPSB1c2VDYWxsYmFjayhhc3luYyAoem9uZUlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZT86IHN0cmluZyB9PiA9PiB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHpvbmVzU2VydmljZS5kZWxldGVab25lKHpvbmVJZCk7XG4gICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHRvYXN0LnN1Y2Nlc3MoJ1pvbmUgZ2Vsw7ZzY2h0LicpO1xuICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7IC8qIC4uLiBGZWhsZXIgLi4uICovIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiAnRmVobGVyJyB9OyB9XG4gICAgICBmaW5hbGx5IHsgc2V0TG9hZGluZyhmYWxzZSk7IH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlZmV0Y2ggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1c2Vab25lc10gcmVmZXRjaDogU3RhcnRlIE5ldWxhZGVuJyk7XG4gICAgaWYgKGNhdGVnb3J5SWQpIHtcbiAgICAgIGxvYWRlZENhdGVnb3J5SWRSZWYuY3VycmVudCA9ICcnO1xuICAgICAgbG9hZFpvbmVzKGNhdGVnb3J5SWQpO1xuICAgIH1cbiAgfSwgW2NhdGVnb3J5SWQsIGxvYWRab25lc10pO1xuXG5cbiAgcmV0dXJuIHsgem9uZXMsIGxvYWRpbmcsIGVycm9yLCBzYXZlWm9uZSwgZGVsZXRlWm9uZSwgcmVmZXRjaCB9O1xufTsiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsInRvYXN0Iiwiem9uZXNTZXJ2aWNlIiwic3VwYWJhc2UiLCJ1c2Vab25lcyIsImNhdGVnb3J5SWQiLCJ6b25lcyIsInNldFpvbmVzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwicmVhbHRpbWVDaGFubmVsUmVmIiwibG9hZGVkQ2F0ZWdvcnlJZFJlZiIsImxvYWRab25lcyIsImNhdGVnb3J5SWRUb0xvYWQiLCJjb25zb2xlIiwibG9nIiwiem9uZXNEYXRhIiwiZ2V0Wm9uZXNCeUNhdGVnb3J5IiwiZW5oYW5jZWRab25lcyIsIm1hcCIsInpvbmUiLCJpZCIsIm5hbWUiLCJ6b25lS2V5IiwibWludXRlc1JlcXVpcmVkIiwiaW50ZXJ2YWxNaW51dGVzIiwicG9pbnRzR3JhbnRlZCIsInBvaW50c1BlckludGVydmFsIiwibGFzdEFjdGl2ZSIsInRvdGFsVGltZVNwZW50IiwidG90YWxVc2VycyIsImN1cnJlbnQiLCJsZW5ndGgiLCJlcnIiLCJoYW5kbGVab25lQ2hhbmdlIiwicGF5bG9hZCIsImV2ZW50VHlwZSIsIm5ldyIsIm5ld1JlY29yZCIsIm9sZCIsIm9sZFJlY29yZCIsInRhYmxlIiwic2NoZW1hIiwibmV3UmVjb3JkQ2F0ZWdvcnlJZCIsImNhdGVnb3J5X2lkIiwib2xkUmVjb3JkQ2F0ZWdvcnlJZCIsInJlY29yZCIsInpvbmVJZCIsImVuaGFuY2VkWm9uZSIsInpvbmVfa2V5IiwiaW50ZXJ2YWxfbWludXRlcyIsInBvaW50c19wZXJfaW50ZXJ2YWwiLCJwcmV2IiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJ6IiwibmV3U3RhdGUiLCJzZXRUaW1lb3V0IiwiZmlsdGVyIiwicmVtb3ZlQ2hhbm5lbCIsInRoZW4iLCJjaGFubmVsIiwiY2hhbm5lbE5hbWUiLCJ0b3BpYyIsIm9uIiwiZXZlbnQiLCJzdWJzY3JpYmUiLCJzdGF0dXMiLCJzYXZlWm9uZSIsInpvbmVEYXRhIiwic3VjY2VzcyIsImRlbGV0ZVpvbmUiLCJyZXN1bHQiLCJtZXNzYWdlIiwicmVmZXRjaCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/category-management/hooks/useZones.ts\n"));

/***/ })

});