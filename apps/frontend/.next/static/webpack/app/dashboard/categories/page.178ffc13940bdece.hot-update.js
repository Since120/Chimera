"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/categories/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts":
/*!*****************************************************************************!*\
  !*** ./src/components/dashboard/category-management/hooks/useCategories.ts ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCategories: () => (/* binding */ useCategories)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/core/toaster */ \"(app-pages-browser)/./src/components/core/toaster.tsx\");\n/* harmony import */ var _context_guild_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/context/guild-context */ \"(app-pages-browser)/./src/context/guild-context.tsx\");\n/* harmony import */ var _services_categories__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/categories */ \"(app-pages-browser)/./src/services/categories.ts\");\n/* harmony import */ var _services_zones__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/zones */ \"(app-pages-browser)/./src/services/zones.ts\");\n/* harmony import */ var shared_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! shared-types */ \"(app-pages-browser)/../../packages/shared-types/src/index.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useCategories auto */ \n\n\n\n\n\n\nconst mapToEnhancedZone = (zone)=>{\n    var _zone_interval_minutes, _zone_points_per_interval;\n    return {\n        id: zone.id,\n        name: zone.name,\n        zoneKey: zone.zone_key || zone.zoneKey,\n        minutesRequired: (_zone_interval_minutes = zone.interval_minutes) !== null && _zone_interval_minutes !== void 0 ? _zone_interval_minutes : zone.intervalMinutes,\n        pointsGranted: (_zone_points_per_interval = zone.points_per_interval) !== null && _zone_points_per_interval !== void 0 ? _zone_points_per_interval : zone.pointsPerInterval,\n        lastActive: '-',\n        totalTimeSpent: 0,\n        totalUsers: 0\n    };\n};\nconst mapToEnhancedCategory = (category, guildId, zones)=>{\n    var _category_is_visible_default, _category_setup_flow_enabled, _category_default_tracking_enabled, _category_setup_channel_id, _category_warteraum_channel_id;\n    return {\n        id: category.id,\n        name: category.name,\n        guild_id: guildId,\n        allowedRoles: category.allowedRoles || [],\n        isVisible: (_category_is_visible_default = category.is_visible_default) !== null && _category_is_visible_default !== void 0 ? _category_is_visible_default : category.isVisibleDefault,\n        sendSetup: (_category_setup_flow_enabled = category.setup_flow_enabled) !== null && _category_setup_flow_enabled !== void 0 ? _category_setup_flow_enabled : category.setupFlowEnabled,\n        trackingActive: (_category_default_tracking_enabled = category.default_tracking_enabled) !== null && _category_default_tracking_enabled !== void 0 ? _category_default_tracking_enabled : category.defaultTrackingEnabled,\n        setupTextChannel: (_category_setup_channel_id = category.setup_channel_id) !== null && _category_setup_channel_id !== void 0 ? _category_setup_channel_id : category.setupChannelId,\n        waitingRoomName: (_category_warteraum_channel_id = category.warteraum_channel_id) !== null && _category_warteraum_channel_id !== void 0 ? _category_warteraum_channel_id : category.warteraumChannelId,\n        lastActive: '-',\n        totalTimeSpent: 0,\n        totalUsers: 0,\n        discordCategoryId: category.discord_category_id || category.discordCategoryId || null,\n        deletedInDiscord: !(category.discord_category_id || category.discordCategoryId),\n        createdAt: new Date(category.created_at || category.createdAt),\n        updatedAt: new Date(category.updated_at || category.updatedAt),\n        zones: zones\n    };\n};\nconst useCategories = ()=>{\n    const { currentGuild } = (0,_context_guild_context__WEBPACK_IMPORTED_MODULE_2__.useGuild)();\n    const guildId = (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) || '';\n    const [categories, setCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [expandedCategories, setExpandedCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [searchQuery, setSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const realtimeChannelRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadedGuildIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)('');\n    const initialLoadCompleteRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const loadCategories = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[loadCategories]\": async (guildIdToLoad)=>{\n            if (!guildIdToLoad) return;\n            if (loading && loadedGuildIdRef.current === guildIdToLoad) return;\n            console.log(\"[useCategories] loadCategories: Loading for Guild: \".concat(guildIdToLoad));\n            setLoading(true);\n            setError(null);\n            initialLoadCompleteRef.current = false;\n            try {\n                const categoriesData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategories(shared_types__WEBPACK_IMPORTED_MODULE_5__.ScopeType.GUILD, guildIdToLoad);\n                const enhancedCategoriesPromises = categoriesData.map({\n                    \"useCategories.useCallback[loadCategories].enhancedCategoriesPromises\": async (category)=>{\n                        const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(category.id);\n                        const enhancedZones = zonesData.map(mapToEnhancedZone);\n                        // Explicitly fetch roles here as they are not in the categories payload\n                        const rolesData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryRolePermissions(category.id);\n                        const allowedRoles = rolesData.map({\n                            \"useCategories.useCallback[loadCategories].enhancedCategoriesPromises.allowedRoles\": (p)=>p.discordRoleId\n                        }[\"useCategories.useCallback[loadCategories].enhancedCategoriesPromises.allowedRoles\"]);\n                        const mappedCategory = mapToEnhancedCategory(category, guildIdToLoad, enhancedZones);\n                        mappedCategory.allowedRoles = allowedRoles; // Add fetched roles\n                        return mappedCategory;\n                    }\n                }[\"useCategories.useCallback[loadCategories].enhancedCategoriesPromises\"]);\n                const enhancedCategories = await Promise.all(enhancedCategoriesPromises);\n                setCategories(enhancedCategories);\n                loadedGuildIdRef.current = guildIdToLoad;\n                initialLoadCompleteRef.current = true;\n                console.log(\"[useCategories] loadCategories: \".concat(enhancedCategories.length, \" categories loaded for \").concat(guildIdToLoad));\n            } catch (err) {\n                console.error(\"[useCategories] Error loading categories for \".concat(guildIdToLoad, \":\"), err);\n                setError('Fehler beim Laden der Kategorien');\n                setCategories([]);\n                loadedGuildIdRef.current = guildIdToLoad;\n                initialLoadCompleteRef.current = true;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[loadCategories]\"], [\n        loading\n    ]);\n    const handleRealtimeEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[handleRealtimeEvent]\": (payload)=>{\n            console.log('[useCategories RAW EVENT]', payload);\n            const { eventType, new: newRecord, old: oldRecord, table, schema } = payload;\n            if (schema !== 'public') return;\n            const record = newRecord || oldRecord;\n            if (!record) return;\n            const affectedCategoryId = table === 'categories' ? record.id : record.category_id;\n            if (!affectedCategoryId) return;\n            // Basic check if the event might belong to the current guild (can be improved with RLS/filters)\n            // This assumes the payload *might* contain guild_id indirectly (needs schema knowledge)\n            // For now, we optimistically process if category matches one in state\n            const isRelevantCategory = {\n                \"useCategories.useCallback[handleRealtimeEvent].isRelevantCategory\": (catId)=>categories.some({\n                        \"useCategories.useCallback[handleRealtimeEvent].isRelevantCategory\": (c)=>c.id === catId && c.guild_id === guildId\n                    }[\"useCategories.useCallback[handleRealtimeEvent].isRelevantCategory\"])\n            }[\"useCategories.useCallback[handleRealtimeEvent].isRelevantCategory\"];\n            console.log(\"[HANDLER CALLED] Table: \".concat(table, \", Event: \").concat(eventType, \", Affected Category: \").concat(affectedCategoryId));\n            if (table === 'categories') {\n                // Ensure event is for the current guild if possible (payload structure dependent)\n                // If record.guild_id exists and record.guild_id !== guildId, return.\n                // Since it might not exist, we rely on the subscription filter for now.\n                if (eventType === 'INSERT' && newRecord) {\n                    console.log(\"[Realtime] Category INSERT: \".concat(newRecord.id));\n                    // Assume new category belongs to current guild if no guild_id in payload\n                    const newCategory = mapToEnhancedCategory(newRecord, guildId, []);\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>{\n                            if (!prev.some({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newCategory.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])) {\n                                return [\n                                    ...prev,\n                                    newCategory\n                                ];\n                            }\n                            return prev;\n                        }\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                    _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(newRecord.id).then({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (zonesData)=>{\n                            const enhancedZones = zonesData.map(mapToEnhancedZone);\n                            setCategories({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                        \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newRecord.id ? {\n                                                ...c,\n                                                zones: enhancedZones\n                                            } : c\n                                    }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        }\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]).catch({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (err)=>console.error(\"[Realtime] Failed fetch zones for new cat \".concat(newRecord.id), err)\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                    _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryRolePermissions(newRecord.id).then({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (rolesData)=>{\n                            const allowedRoles = rolesData.map({\n                                \"useCategories.useCallback[handleRealtimeEvent].allowedRoles\": (p)=>p.discordRoleId\n                            }[\"useCategories.useCallback[handleRealtimeEvent].allowedRoles\"]);\n                            setCategories({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                        \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newRecord.id ? {\n                                                ...c,\n                                                allowedRoles: allowedRoles\n                                            } : c\n                                    }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        }\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]).catch({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (err)=>console.error(\"[Realtime] Failed fetch roles for new cat \".concat(newRecord.id), err)\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                } else if (eventType === 'UPDATE' && newRecord) {\n                    console.log(\"[Realtime] Category UPDATE: \".concat(newRecord.id));\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newRecord.id ? mapToEnhancedCategory(newRecord, guildId, c.zones) // Use helper, keep existing zones\n                                     : c\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                    // If roles might have changed implicitly, refetch them\n                    _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryRolePermissions(newRecord.id).then({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (rolesData)=>{\n                            const allowedRoles = rolesData.map({\n                                \"useCategories.useCallback[handleRealtimeEvent].allowedRoles\": (p)=>p.discordRoleId\n                            }[\"useCategories.useCallback[handleRealtimeEvent].allowedRoles\"]);\n                            setCategories({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                        \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newRecord.id ? {\n                                                ...c,\n                                                allowedRoles: allowedRoles\n                                            } : c\n                                    }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        }\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]).catch({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (err)=>console.error(\"[Realtime] Failed fetch roles for updated cat \".concat(newRecord.id), err)\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                } else if (eventType === 'DELETE' && oldRecord) {\n                    console.log(\"[Realtime] Category DELETE: \".concat(oldRecord.id));\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.filter({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id !== oldRecord.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                }\n            } else if (table === 'zones') {\n                console.log(\"[Realtime] Zone \".concat(eventType, \" for Category \").concat(affectedCategoryId));\n                // Refetch zones for the affected category for simplicity and accuracy\n                if (categories.some({\n                    \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === affectedCategoryId\n                }[\"useCategories.useCallback[handleRealtimeEvent]\"])) {\n                    ({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": async ()=>{\n                            try {\n                                const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(affectedCategoryId);\n                                const enhancedZones = zonesData.map(mapToEnhancedZone);\n                                setCategories({\n                                    \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                            \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === affectedCategoryId ? {\n                                                    ...c,\n                                                    zones: enhancedZones\n                                                } : c\n                                        }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                                }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                            } catch (error) {\n                                console.error(\"[Realtime] Error refetching zones for category \".concat(affectedCategoryId, \":\"), error);\n                            }\n                        }\n                    })[\"useCategories.useCallback[handleRealtimeEvent]\"]();\n                }\n            } else if (table === 'category_discord_role_permissions') {\n                console.log(\"[Realtime] Roles \".concat(eventType, \" for Category \").concat(affectedCategoryId));\n                // Refetch roles for the affected category\n                if (categories.some({\n                    \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === affectedCategoryId\n                }[\"useCategories.useCallback[handleRealtimeEvent]\"])) {\n                    ({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": async ()=>{\n                            try {\n                                const rolesData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryRolePermissions(affectedCategoryId);\n                                const allowedRoles = rolesData.map({\n                                    \"useCategories.useCallback[handleRealtimeEvent].allowedRoles\": (p)=>p.discordRoleId\n                                }[\"useCategories.useCallback[handleRealtimeEvent].allowedRoles\"]);\n                                setCategories({\n                                    \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                            \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === affectedCategoryId ? {\n                                                    ...c,\n                                                    allowedRoles: allowedRoles\n                                                } : c\n                                        }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                                }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                            } catch (error) {\n                                console.error(\"[Realtime] Error refetching roles for category \".concat(affectedCategoryId, \":\"), error);\n                            }\n                        }\n                    })[\"useCategories.useCallback[handleRealtimeEvent]\"]();\n                }\n            }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useCategories.useCallback[handleRealtimeEvent]\"], [\n        guildId,\n        setCategories,\n        categories\n    ]); // 'categories' added as dep because we check against it\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCategories.useEffect\": ()=>{\n            const currentGuildId = currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id;\n            console.log(\"[useCategories Effect] Running for guildId: \".concat(currentGuildId || 'none'));\n            if (!currentGuildId) {\n                setCategories([]);\n                loadedGuildIdRef.current = '';\n                initialLoadCompleteRef.current = false;\n                if (realtimeChannelRef.current) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(realtimeChannelRef.current);\n                    realtimeChannelRef.current = null;\n                }\n                return;\n            }\n            if (loadedGuildIdRef.current !== currentGuildId) {\n                loadCategories(currentGuildId);\n            }\n            let channel = realtimeChannelRef.current;\n            const channelName = \"db-changes\"; // Listen to all changes on one channel\n            if (!channel || !channel.isSubscribed()) {\n                if (channel) _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(channel);\n                console.log(\"[useCategories Effect] Setting up channel: \".concat(channelName));\n                channel = _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.channel(channelName);\n                channel.on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'categories'\n                }, handleRealtimeEvent).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'zones'\n                }, handleRealtimeEvent).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'category_discord_role_permissions'\n                }, handleRealtimeEvent).subscribe({\n                    \"useCategories.useEffect\": (status, err)=>{\n                        console.log(\"[useCategories Effect] Sub status \".concat(channelName, \":\"), status, err || '');\n                        if (status === 'SUBSCRIBED') {\n                            realtimeChannelRef.current = channel;\n                            if (!initialLoadCompleteRef.current) {\n                                console.log('[useCategories Effect] Re-fetching data after successful subscription.');\n                                loadCategories(currentGuildId);\n                            }\n                        } else {\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }[\"useCategories.useEffect\"]);\n            } else {\n                console.log(\"[useCategories Effect] Already subscribed to \".concat(channelName));\n            }\n            // Cleanup\n            return ({\n                \"useCategories.useEffect\": ()=>{\n                    console.log(\"[useCategories Effect] Cleanup for guildId: \".concat(currentGuildId));\n                // Don't remove the channel here if it's a shared channel\n                // Supabase handles channel cleanup on unmount/disconnect automatically\n                // if (realtimeChannelRef.current) {\n                //   supabase.removeChannel(realtimeChannelRef.current);\n                //   realtimeChannelRef.current = null;\n                // }\n                }\n            })[\"useCategories.useEffect\"];\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useCategories.useEffect\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories,\n        handleRealtimeEvent\n    ]); // Dependencies updated\n    const toggleCategoryExpand = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[toggleCategoryExpand]\": (categoryId)=>{\n            setExpandedCategories({\n                \"useCategories.useCallback[toggleCategoryExpand]\": (prev)=>prev.includes(categoryId) ? prev.filter({\n                        \"useCategories.useCallback[toggleCategoryExpand]\": (id)=>id !== categoryId\n                    }[\"useCategories.useCallback[toggleCategoryExpand]\"]) : [\n                        ...prev,\n                        categoryId\n                    ]\n            }[\"useCategories.useCallback[toggleCategoryExpand]\"]);\n        }\n    }[\"useCategories.useCallback[toggleCategoryExpand]\"], []);\n    const saveCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[saveCategory]\": async (categoryData)=>{\n            if (!guildId) {\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error('Keine Guild ausgewählt');\n                return false;\n            }\n            setLoading(true);\n            try {\n                const dtoDataScope = {\n                    scopeType: shared_types__WEBPACK_IMPORTED_MODULE_5__.ScopeType.GUILD,\n                    scopeId: guildId\n                }; // Define scope\n                if (categoryData.id) {\n                    const updateData = {\n                        name: categoryData.name,\n                        isVisibleDefault: categoryData.isVisible,\n                        setupFlowEnabled: categoryData.sendSetup,\n                        defaultTrackingEnabled: categoryData.trackingActive,\n                        setupChannelName: categoryData.setupTextChannel || undefined,\n                        warteraumChannelName: categoryData.waitingRoomName || undefined,\n                        discordRoleIds: categoryData.allowedRoles\n                    };\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.updateCategory(categoryData.id, updateData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie aktualisiert');\n                } else {\n                    const createData = {\n                        scope: dtoDataScope,\n                        name: categoryData.name,\n                        isVisibleDefault: categoryData.isVisible,\n                        setupFlowEnabled: categoryData.sendSetup,\n                        defaultTrackingEnabled: categoryData.trackingActive,\n                        setupChannelName: categoryData.setupTextChannel || undefined,\n                        warteraumChannelName: categoryData.waitingRoomName || undefined,\n                        discordRoleIds: categoryData.allowedRoles\n                    };\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.createCategory(createData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie erstellt');\n                }\n                return true;\n            } catch (err) {\n                var _err_response_data, _err_response;\n                console.error('Fehler beim Speichern der Kategorie:', err);\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error(((_err_response = err.response) === null || _err_response === void 0 ? void 0 : (_err_response_data = _err_response.data) === null || _err_response_data === void 0 ? void 0 : _err_response_data.message) || 'Fehler beim Speichern der Kategorie');\n                return false;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[saveCategory]\"], [\n        guildId\n    ]);\n    const deleteCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[deleteCategory]\": async (categoryId)=>{\n            setLoading(true);\n            try {\n                const result = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.deleteCategory(categoryId);\n                if (result.success) _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie gelöscht.');\n                else _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error(result.message || 'Fehler beim Löschen');\n                return result;\n            } catch (err) {\n                var _err_response_data, _err_response;\n                console.error('Fehler beim Löschen der Kategorie:', err);\n                const message = ((_err_response = err.response) === null || _err_response === void 0 ? void 0 : (_err_response_data = _err_response.data) === null || _err_response_data === void 0 ? void 0 : _err_response_data.message) || 'Fehler beim Löschen der Kategorie';\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error(message);\n                return {\n                    success: false,\n                    message\n                };\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[deleteCategory]\"], []);\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[refetch]\": ()=>{\n            console.log('[useCategories] refetch triggered');\n            if (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) {\n                loadedGuildIdRef.current = '';\n                initialLoadCompleteRef.current = false;\n                loadCategories(currentGuild.id);\n            }\n        }\n    }[\"useCategories.useCallback[refetch]\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories\n    ]);\n    const getTotalStats = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[getTotalStats]\": ()=>({\n                totalCategories: categories.length,\n                totalUsers: categories.reduce({\n                    \"useCategories.useCallback[getTotalStats]\": (sum, c)=>sum + c.totalUsers\n                }[\"useCategories.useCallback[getTotalStats]\"], 0),\n                totalTime: categories.reduce({\n                    \"useCategories.useCallback[getTotalStats]\": (sum, c)=>sum + c.totalTimeSpent\n                }[\"useCategories.useCallback[getTotalStats]\"], 0)\n            })\n    }[\"useCategories.useCallback[getTotalStats]\"], [\n        categories\n    ]);\n    return {\n        categories,\n        loading,\n        error,\n        expandedCategories,\n        searchQuery,\n        setSearchQuery,\n        toggleCategoryExpand,\n        saveCategory,\n        deleteCategory,\n        getTotalStats,\n        refetch\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9jYXRlZ29yeS1tYW5hZ2VtZW50L2hvb2tzL3VzZUNhdGVnb3JpZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O21FQUVpRTtBQUNmO0FBQ0M7QUFDUTtBQUNWO0FBQ29EO0FBRTNEO0FBNkMxQyxNQUFNVSxvQkFBb0IsQ0FBQ0M7UUFJTkEsd0JBQ0ZBO1dBTCtDO1FBQzlEQyxJQUFJRCxLQUFLQyxFQUFFO1FBQ1hDLE1BQU1GLEtBQUtFLElBQUk7UUFDZkMsU0FBU0gsS0FBS0ksUUFBUSxJQUFJSixLQUFLRyxPQUFPO1FBQ3RDRSxpQkFBaUJMLENBQUFBLHlCQUFBQSxLQUFLTSxnQkFBZ0IsY0FBckJOLG9DQUFBQSx5QkFBeUJBLEtBQUtPLGVBQWU7UUFDOURDLGVBQWVSLENBQUFBLDRCQUFBQSxLQUFLUyxtQkFBbUIsY0FBeEJULHVDQUFBQSw0QkFBNEJBLEtBQUtVLGlCQUFpQjtRQUNqRUMsWUFBWTtRQUFLQyxnQkFBZ0I7UUFBR0MsWUFBWTtJQUNwRDs7QUFFQSxNQUFNQyx3QkFBd0IsQ0FBQ0MsVUFBNkJDLFNBQWlCQztRQUs5REYsOEJBQ0FBLDhCQUNLQSxvQ0FDRUEsNEJBQ0RBO1dBVHFHO1FBQ3RIZCxJQUFJYyxTQUFTZCxFQUFFO1FBQ2ZDLE1BQU1hLFNBQVNiLElBQUk7UUFDbkJnQixVQUFVRjtRQUNWRyxjQUFjSixTQUFTSSxZQUFZLElBQUksRUFBRTtRQUN6Q0MsV0FBV0wsQ0FBQUEsK0JBQUFBLFNBQVNNLGtCQUFrQixjQUEzQk4sMENBQUFBLCtCQUErQkEsU0FBU08sZ0JBQWdCO1FBQ25FQyxXQUFXUixDQUFBQSwrQkFBQUEsU0FBU1Msa0JBQWtCLGNBQTNCVCwwQ0FBQUEsK0JBQStCQSxTQUFTVSxnQkFBZ0I7UUFDbkVDLGdCQUFnQlgsQ0FBQUEscUNBQUFBLFNBQVNZLHdCQUF3QixjQUFqQ1osZ0RBQUFBLHFDQUFxQ0EsU0FBU2Esc0JBQXNCO1FBQ3BG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QUMsSUFBTztnQkFDdkNpSixpQkFBaUIzRixXQUFXa0MsTUFBTTtnQkFDbENsRSxZQUFZZ0MsV0FBVzRGLE1BQU07Z0VBQUMsQ0FBQ0MsS0FBSzFDLElBQU0wQyxNQUFNMUMsRUFBRW5GLFVBQVU7K0RBQUU7Z0JBQzlEOEgsV0FBVzlGLFdBQVc0RixNQUFNO2dFQUFDLENBQUNDLEtBQUsxQyxJQUFNMEMsTUFBTTFDLEVBQUVwRixjQUFjOytEQUFFO1lBQ25FO21EQUFJO1FBQUNpQztLQUFXO0lBRWhCLE9BQU87UUFDTEE7UUFBWU07UUFBU0U7UUFBT047UUFBb0JFO1FBQ2hEQztRQUFnQjZEO1FBQXNCRztRQUFja0I7UUFDcERHO1FBQWVEO0lBQ2pCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxpbmZvXFxEb2N1bWVudHNcXERpc2NvcmQgQm90XFxDaGltZXJhXFxhcHBzXFxmcm9udGVuZFxcc3JjXFxjb21wb25lbnRzXFxkYXNoYm9hcmRcXGNhdGVnb3J5LW1hbmFnZW1lbnRcXGhvb2tzXFx1c2VDYXRlZ29yaWVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAnQC9jb21wb25lbnRzL2NvcmUvdG9hc3Rlcic7XG5pbXBvcnQgeyB1c2VHdWlsZCB9IGZyb20gJ0AvY29udGV4dC9ndWlsZC1jb250ZXh0JztcbmltcG9ydCAqIGFzIGNhdGVnb3JpZXNTZXJ2aWNlIGZyb20gJ0Avc2VydmljZXMvY2F0ZWdvcmllcyc7XG5pbXBvcnQgKiBhcyB6b25lc1NlcnZpY2UgZnJvbSAnQC9zZXJ2aWNlcy96b25lcyc7XG5pbXBvcnQgeyBDcmVhdGVDYXRlZ29yeUR0bywgVXBkYXRlQ2F0ZWdvcnlEdG8sIFNjb3BlVHlwZSwgQ2F0ZWdvcnlEdG8sIFpvbmVEdG8gfSBmcm9tICdzaGFyZWQtdHlwZXMnO1xuaW1wb3J0IHsgUmVhbHRpbWVDaGFubmVsLCBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSc7XG5cbi8vIEV4cG9ydCBJbnRlcmZhY2VzIGRpcmVjdGx5XG5leHBvcnQgaW50ZXJmYWNlIEVuaGFuY2VkQ2F0ZWdvcnkge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGd1aWxkX2lkOiBzdHJpbmc7XG4gIGFsbG93ZWRSb2xlczogc3RyaW5nW107XG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgc2VuZFNldHVwOiBib29sZWFuO1xuICB0cmFja2luZ0FjdGl2ZTogYm9vbGVhbjtcbiAgc2V0dXBUZXh0Q2hhbm5lbD86IHN0cmluZyB8IG51bGw7XG4gIHdhaXRpbmdSb29tTmFtZT86IHN0cmluZyB8IG51bGw7XG4gIGxhc3RBY3RpdmU6IHN0cmluZzsgLy8gUGxhY2Vob2xkZXJcbiAgdG90YWxUaW1lU3BlbnQ6IG51bWJlcjsgLy8gUGxhY2Vob2xkZXJcbiAgdG90YWxVc2VyczogbnVtYmVyOyAvLyBQbGFjZWhvbGRlclxuICBkaXNjb3JkQ2F0ZWdvcnlJZDogc3RyaW5nIHwgbnVsbDtcbiAgZGVsZXRlZEluRGlzY29yZDogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICB1cGRhdGVkQXQ6IERhdGU7XG4gIHpvbmVzOiBFbmhhbmNlZFpvbmVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbmhhbmNlZFpvbmUge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHpvbmVLZXk6IHN0cmluZztcbiAgbWludXRlc1JlcXVpcmVkOiBudW1iZXI7XG4gIHBvaW50c0dyYW50ZWQ6IG51bWJlcjtcbiAgbGFzdEFjdGl2ZTogc3RyaW5nOyAvLyBQbGFjZWhvbGRlclxuICB0b3RhbFRpbWVTcGVudDogbnVtYmVyOyAvLyBQbGFjZWhvbGRlclxuICB0b3RhbFVzZXJzOiBudW1iZXI7IC8vIFBsYWNlaG9sZGVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcnlJbnB1dCB7XG4gIGlkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFsbG93ZWRSb2xlczogc3RyaW5nW107XG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgc2VuZFNldHVwOiBib29sZWFuO1xuICB0cmFja2luZ0FjdGl2ZTogYm9vbGVhbjtcbiAgc2V0dXBUZXh0Q2hhbm5lbD86IHN0cmluZyB8IG51bGw7XG4gIHdhaXRpbmdSb29tTmFtZT86IHN0cmluZyB8IG51bGw7XG59XG5cbmNvbnN0IG1hcFRvRW5oYW5jZWRab25lID0gKHpvbmU6IFpvbmVEdG8gfCBhbnkpOiBFbmhhbmNlZFpvbmUgPT4gKHtcbiAgICBpZDogem9uZS5pZCxcbiAgICBuYW1lOiB6b25lLm5hbWUsXG4gICAgem9uZUtleTogem9uZS56b25lX2tleSB8fCB6b25lLnpvbmVLZXksXG4gICAgbWludXRlc1JlcXVpcmVkOiB6b25lLmludGVydmFsX21pbnV0ZXMgPz8gem9uZS5pbnRlcnZhbE1pbnV0ZXMsXG4gICAgcG9pbnRzR3JhbnRlZDogem9uZS5wb2ludHNfcGVyX2ludGVydmFsID8/IHpvbmUucG9pbnRzUGVySW50ZXJ2YWwsXG4gICAgbGFzdEFjdGl2ZTogJy0nLCB0b3RhbFRpbWVTcGVudDogMCwgdG90YWxVc2VyczogMFxufSk7XG5cbmNvbnN0IG1hcFRvRW5oYW5jZWRDYXRlZ29yeSA9IChjYXRlZ29yeTogQ2F0ZWdvcnlEdG8gfCBhbnksIGd1aWxkSWQ6IHN0cmluZywgem9uZXM6IEVuaGFuY2VkWm9uZVtdKTogRW5oYW5jZWRDYXRlZ29yeSA9PiAoe1xuICAgIGlkOiBjYXRlZ29yeS5pZCxcbiAgICBuYW1lOiBjYXRlZ29yeS5uYW1lLFxuICAgIGd1aWxkX2lkOiBndWlsZElkLFxuICAgIGFsbG93ZWRSb2xlczogY2F0ZWdvcnkuYWxsb3dlZFJvbGVzIHx8IFtdLFxuICAgIGlzVmlzaWJsZTogY2F0ZWdvcnkuaXNfdmlzaWJsZV9kZWZhdWx0ID8/IGNhdGVnb3J5LmlzVmlzaWJsZURlZmF1bHQsXG4gICAgc2VuZFNldHVwOiBjYXRlZ29yeS5zZXR1cF9mbG93X2VuYWJsZWQgPz8gY2F0ZWdvcnkuc2V0dXBGbG93RW5hYmxlZCxcbiAgICB0cmFja2luZ0FjdGl2ZTogY2F0ZWdvcnkuZGVmYXVsdF90cmFja2luZ19lbmFibGVkID8/IGNhdGVnb3J5LmRlZmF1bHRUcmFja2luZ0VuYWJsZWQsXG4gICAgc2V0dXBUZXh0Q2hhbm5lbDogY2F0ZWdvcnkuc2V0dXBfY2hhbm5lbF9pZCA/PyBjYXRlZ29yeS5zZXR1cENoYW5uZWxJZCxcbiAgICB3YWl0aW5nUm9vbU5hbWU6IGNhdGVnb3J5LndhcnRlcmF1bV9jaGFubmVsX2lkID8/IGNhdGVnb3J5LndhcnRlcmF1bUNoYW5uZWxJZCxcbiAgICBsYXN0QWN0aXZlOiAnLScsIHRvdGFsVGltZVNwZW50OiAwLCB0b3RhbFVzZXJzOiAwLFxuICAgIGRpc2NvcmRDYXRlZ29yeUlkOiBjYXRlZ29yeS5kaXNjb3JkX2NhdGVnb3J5X2lkIHx8IGNhdGVnb3J5LmRpc2NvcmRDYXRlZ29yeUlkIHx8IG51bGwsXG4gICAgZGVsZXRlZEluRGlzY29yZDogIShjYXRlZ29yeS5kaXNjb3JkX2NhdGVnb3J5X2lkIHx8IGNhdGVnb3J5LmRpc2NvcmRDYXRlZ29yeUlkKSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGNhdGVnb3J5LmNyZWF0ZWRfYXQgfHwgY2F0ZWdvcnkuY3JlYXRlZEF0KSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKGNhdGVnb3J5LnVwZGF0ZWRfYXQgfHwgY2F0ZWdvcnkudXBkYXRlZEF0KSxcbiAgICB6b25lczogem9uZXNcbn0pO1xuXG5cbmV4cG9ydCBjb25zdCB1c2VDYXRlZ29yaWVzID0gKCkgPT4ge1xuICBjb25zdCB7IGN1cnJlbnRHdWlsZCB9ID0gdXNlR3VpbGQoKTtcbiAgY29uc3QgZ3VpbGRJZCA9IGN1cnJlbnRHdWlsZD8uaWQgfHwgJyc7XG4gIGNvbnN0IFtjYXRlZ29yaWVzLCBzZXRDYXRlZ29yaWVzXSA9IHVzZVN0YXRlPEVuaGFuY2VkQ2F0ZWdvcnlbXT4oW10pO1xuICBjb25zdCBbZXhwYW5kZWRDYXRlZ29yaWVzLCBzZXRFeHBhbmRlZENhdGVnb3JpZXNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcbiAgY29uc3QgW3NlYXJjaFF1ZXJ5LCBzZXRTZWFyY2hRdWVyeV0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgcmVhbHRpbWVDaGFubmVsUmVmID0gdXNlUmVmPFJlYWx0aW1lQ2hhbm5lbCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBsb2FkZWRHdWlsZElkUmVmID0gdXNlUmVmPHN0cmluZz4oJycpO1xuICBjb25zdCBpbml0aWFsTG9hZENvbXBsZXRlUmVmID0gdXNlUmVmKGZhbHNlKTtcblxuICBjb25zdCBsb2FkQ2F0ZWdvcmllcyA9IHVzZUNhbGxiYWNrKGFzeW5jIChndWlsZElkVG9Mb2FkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWd1aWxkSWRUb0xvYWQpIHJldHVybjtcbiAgICBpZiAobG9hZGluZyAmJiBsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgPT09IGd1aWxkSWRUb0xvYWQpIHJldHVybjtcblxuICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllc10gbG9hZENhdGVnb3JpZXM6IExvYWRpbmcgZm9yIEd1aWxkOiAke2d1aWxkSWRUb0xvYWR9YCk7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBpbml0aWFsTG9hZENvbXBsZXRlUmVmLmN1cnJlbnQgPSBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYXRlZ29yaWVzRGF0YSA9IGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLmdldENhdGVnb3JpZXMoU2NvcGVUeXBlLkdVSUxELCBndWlsZElkVG9Mb2FkKTtcbiAgICAgIGNvbnN0IGVuaGFuY2VkQ2F0ZWdvcmllc1Byb21pc2VzID0gY2F0ZWdvcmllc0RhdGEubWFwKGFzeW5jIChjYXRlZ29yeSkgPT4ge1xuICAgICAgICBjb25zdCB6b25lc0RhdGEgPSBhd2FpdCB6b25lc1NlcnZpY2UuZ2V0Wm9uZXNCeUNhdGVnb3J5KGNhdGVnb3J5LmlkKTtcbiAgICAgICAgY29uc3QgZW5oYW5jZWRab25lcyA9IHpvbmVzRGF0YS5tYXAobWFwVG9FbmhhbmNlZFpvbmUpO1xuICAgICAgICAvLyBFeHBsaWNpdGx5IGZldGNoIHJvbGVzIGhlcmUgYXMgdGhleSBhcmUgbm90IGluIHRoZSBjYXRlZ29yaWVzIHBheWxvYWRcbiAgICAgICAgY29uc3Qgcm9sZXNEYXRhID0gYXdhaXQgY2F0ZWdvcmllc1NlcnZpY2UuZ2V0Q2F0ZWdvcnlSb2xlUGVybWlzc2lvbnMoY2F0ZWdvcnkuaWQpO1xuICAgICAgICBjb25zdCBhbGxvd2VkUm9sZXMgPSByb2xlc0RhdGEubWFwKHAgPT4gcC5kaXNjb3JkUm9sZUlkKTtcbiAgICAgICAgY29uc3QgbWFwcGVkQ2F0ZWdvcnkgPSBtYXBUb0VuaGFuY2VkQ2F0ZWdvcnkoY2F0ZWdvcnksIGd1aWxkSWRUb0xvYWQsIGVuaGFuY2VkWm9uZXMpO1xuICAgICAgICBtYXBwZWRDYXRlZ29yeS5hbGxvd2VkUm9sZXMgPSBhbGxvd2VkUm9sZXM7IC8vIEFkZCBmZXRjaGVkIHJvbGVzXG4gICAgICAgIHJldHVybiBtYXBwZWRDYXRlZ29yeTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZW5oYW5jZWRDYXRlZ29yaWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoZW5oYW5jZWRDYXRlZ29yaWVzUHJvbWlzZXMpO1xuXG4gICAgICBzZXRDYXRlZ29yaWVzKGVuaGFuY2VkQ2F0ZWdvcmllcyk7XG4gICAgICBsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgPSBndWlsZElkVG9Mb2FkO1xuICAgICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllc10gbG9hZENhdGVnb3JpZXM6ICR7ZW5oYW5jZWRDYXRlZ29yaWVzLmxlbmd0aH0gY2F0ZWdvcmllcyBsb2FkZWQgZm9yICR7Z3VpbGRJZFRvTG9hZH1gKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFt1c2VDYXRlZ29yaWVzXSBFcnJvciBsb2FkaW5nIGNhdGVnb3JpZXMgZm9yICR7Z3VpbGRJZFRvTG9hZH06YCwgZXJyKTtcbiAgICAgIHNldEVycm9yKCdGZWhsZXIgYmVpbSBMYWRlbiBkZXIgS2F0ZWdvcmllbicpO1xuICAgICAgc2V0Q2F0ZWdvcmllcyhbXSk7XG4gICAgICBsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgPSBndWlsZElkVG9Mb2FkO1xuICAgICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbbG9hZGluZ10pO1xuXG4gIGNvbnN0IGhhbmRsZVJlYWx0aW1lRXZlbnQgPSB1c2VDYWxsYmFjaygocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPGFueT4pID0+IHtcbiAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXMgUkFXIEVWRU5UXScsIHBheWxvYWQpO1xuICAgIGNvbnN0IHsgZXZlbnRUeXBlLCBuZXc6IG5ld1JlY29yZCwgb2xkOiBvbGRSZWNvcmQsIHRhYmxlLCBzY2hlbWEgfSA9IHBheWxvYWQ7XG5cbiAgICBpZiAoc2NoZW1hICE9PSAncHVibGljJykgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVjb3JkID0gbmV3UmVjb3JkIHx8IG9sZFJlY29yZDtcbiAgICBpZiAoIXJlY29yZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgYWZmZWN0ZWRDYXRlZ29yeUlkID0gdGFibGUgPT09ICdjYXRlZ29yaWVzJyA/IHJlY29yZC5pZCA6IChyZWNvcmQgYXMgYW55KS5jYXRlZ29yeV9pZDtcbiAgICBpZiAoIWFmZmVjdGVkQ2F0ZWdvcnlJZCkgcmV0dXJuO1xuXG4gICAgLy8gQmFzaWMgY2hlY2sgaWYgdGhlIGV2ZW50IG1pZ2h0IGJlbG9uZyB0byB0aGUgY3VycmVudCBndWlsZCAoY2FuIGJlIGltcHJvdmVkIHdpdGggUkxTL2ZpbHRlcnMpXG4gICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBwYXlsb2FkICptaWdodCogY29udGFpbiBndWlsZF9pZCBpbmRpcmVjdGx5IChuZWVkcyBzY2hlbWEga25vd2xlZGdlKVxuICAgIC8vIEZvciBub3csIHdlIG9wdGltaXN0aWNhbGx5IHByb2Nlc3MgaWYgY2F0ZWdvcnkgbWF0Y2hlcyBvbmUgaW4gc3RhdGVcbiAgICBjb25zdCBpc1JlbGV2YW50Q2F0ZWdvcnkgPSAoY2F0SWQ6IHN0cmluZykgPT4gY2F0ZWdvcmllcy5zb21lKGMgPT4gYy5pZCA9PT0gY2F0SWQgJiYgYy5ndWlsZF9pZCA9PT0gZ3VpbGRJZCk7XG5cblxuICAgIGNvbnNvbGUubG9nKGBbSEFORExFUiBDQUxMRURdIFRhYmxlOiAke3RhYmxlfSwgRXZlbnQ6ICR7ZXZlbnRUeXBlfSwgQWZmZWN0ZWQgQ2F0ZWdvcnk6ICR7YWZmZWN0ZWRDYXRlZ29yeUlkfWApO1xuXG4gICAgaWYgKHRhYmxlID09PSAnY2F0ZWdvcmllcycpIHtcbiAgICAgICAvLyBFbnN1cmUgZXZlbnQgaXMgZm9yIHRoZSBjdXJyZW50IGd1aWxkIGlmIHBvc3NpYmxlIChwYXlsb2FkIHN0cnVjdHVyZSBkZXBlbmRlbnQpXG4gICAgICAgLy8gSWYgcmVjb3JkLmd1aWxkX2lkIGV4aXN0cyBhbmQgcmVjb3JkLmd1aWxkX2lkICE9PSBndWlsZElkLCByZXR1cm4uXG4gICAgICAgLy8gU2luY2UgaXQgbWlnaHQgbm90IGV4aXN0LCB3ZSByZWx5IG9uIHRoZSBzdWJzY3JpcHRpb24gZmlsdGVyIGZvciBub3cuXG5cbiAgICAgIGlmIChldmVudFR5cGUgPT09ICdJTlNFUlQnICYmIG5ld1JlY29yZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW1JlYWx0aW1lXSBDYXRlZ29yeSBJTlNFUlQ6ICR7bmV3UmVjb3JkLmlkfWApO1xuICAgICAgICAvLyBBc3N1bWUgbmV3IGNhdGVnb3J5IGJlbG9uZ3MgdG8gY3VycmVudCBndWlsZCBpZiBubyBndWlsZF9pZCBpbiBwYXlsb2FkXG4gICAgICAgIGNvbnN0IG5ld0NhdGVnb3J5ID0gbWFwVG9FbmhhbmNlZENhdGVnb3J5KG5ld1JlY29yZCwgZ3VpbGRJZCwgW10pO1xuICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4ge1xuICAgICAgICAgICAgIGlmICghcHJldi5zb21lKGMgPT4gYy5pZCA9PT0gbmV3Q2F0ZWdvcnkuaWQpKSB7IHJldHVybiBbLi4ucHJldiwgbmV3Q2F0ZWdvcnldOyB9IHJldHVybiBwcmV2O1xuICAgICAgICB9KTtcbiAgICAgICAgem9uZXNTZXJ2aWNlLmdldFpvbmVzQnlDYXRlZ29yeShuZXdSZWNvcmQuaWQpLnRoZW4oem9uZXNEYXRhID0+IHtcbiAgICAgICAgICAgICBjb25zdCBlbmhhbmNlZFpvbmVzID0gem9uZXNEYXRhLm1hcChtYXBUb0VuaGFuY2VkWm9uZSk7XG4gICAgICAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gbmV3UmVjb3JkLmlkID8gey4uLmMsIHpvbmVzOiBlbmhhbmNlZFpvbmVzfSA6IGMpKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYFtSZWFsdGltZV0gRmFpbGVkIGZldGNoIHpvbmVzIGZvciBuZXcgY2F0ICR7bmV3UmVjb3JkLmlkfWAsIGVycikpO1xuICAgICAgICBjYXRlZ29yaWVzU2VydmljZS5nZXRDYXRlZ29yeVJvbGVQZXJtaXNzaW9ucyhuZXdSZWNvcmQuaWQpLnRoZW4ocm9sZXNEYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRSb2xlcyA9IHJvbGVzRGF0YS5tYXAocCA9PiBwLmRpc2NvcmRSb2xlSWQpO1xuICAgICAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gbmV3UmVjb3JkLmlkID8gey4uLmMsIGFsbG93ZWRSb2xlczogYWxsb3dlZFJvbGVzfSA6IGMpKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYFtSZWFsdGltZV0gRmFpbGVkIGZldGNoIHJvbGVzIGZvciBuZXcgY2F0ICR7bmV3UmVjb3JkLmlkfWAsIGVycikpO1xuXG5cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAnVVBEQVRFJyAmJiBuZXdSZWNvcmQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtSZWFsdGltZV0gQ2F0ZWdvcnkgVVBEQVRFOiAke25ld1JlY29yZC5pZH1gKTtcbiAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gbmV3UmVjb3JkLmlkID9cbiAgICAgICAgICAgIG1hcFRvRW5oYW5jZWRDYXRlZ29yeShuZXdSZWNvcmQsIGd1aWxkSWQsIGMuem9uZXMpIC8vIFVzZSBoZWxwZXIsIGtlZXAgZXhpc3Rpbmcgem9uZXNcbiAgICAgICAgICAgIDogY1xuICAgICAgICApKTtcbiAgICAgICAgIC8vIElmIHJvbGVzIG1pZ2h0IGhhdmUgY2hhbmdlZCBpbXBsaWNpdGx5LCByZWZldGNoIHRoZW1cbiAgICAgICAgIGNhdGVnb3JpZXNTZXJ2aWNlLmdldENhdGVnb3J5Um9sZVBlcm1pc3Npb25zKG5ld1JlY29yZC5pZCkudGhlbihyb2xlc0RhdGEgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWxsb3dlZFJvbGVzID0gcm9sZXNEYXRhLm1hcChwID0+IHAuZGlzY29yZFJvbGVJZCk7XG4gICAgICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBuZXdSZWNvcmQuaWQgPyB7Li4uYywgYWxsb3dlZFJvbGVzOiBhbGxvd2VkUm9sZXN9IDogYykpO1xuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgW1JlYWx0aW1lXSBGYWlsZWQgZmV0Y2ggcm9sZXMgZm9yIHVwZGF0ZWQgY2F0ICR7bmV3UmVjb3JkLmlkfWAsIGVycikpO1xuXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gJ0RFTEVURScgJiYgb2xkUmVjb3JkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbUmVhbHRpbWVdIENhdGVnb3J5IERFTEVURTogJHtvbGRSZWNvcmQuaWR9YCk7XG4gICAgICAgIHNldENhdGVnb3JpZXMocHJldiA9PiBwcmV2LmZpbHRlcihjID0+IGMuaWQgIT09IG9sZFJlY29yZC5pZCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFibGUgPT09ICd6b25lcycpIHtcbiAgICAgICAgIGNvbnNvbGUubG9nKGBbUmVhbHRpbWVdIFpvbmUgJHtldmVudFR5cGV9IGZvciBDYXRlZ29yeSAke2FmZmVjdGVkQ2F0ZWdvcnlJZH1gKTtcbiAgICAgICAgIC8vIFJlZmV0Y2ggem9uZXMgZm9yIHRoZSBhZmZlY3RlZCBjYXRlZ29yeSBmb3Igc2ltcGxpY2l0eSBhbmQgYWNjdXJhY3lcbiAgICAgICAgICBpZiAoY2F0ZWdvcmllcy5zb21lKGMgPT4gYy5pZCA9PT0gYWZmZWN0ZWRDYXRlZ29yeUlkKSkgeyAvLyBPbmx5IHJlZmV0Y2ggaWYgY2F0ZWdvcnkgaXMgcmVsZXZhbnRcbiAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgem9uZXNEYXRhID0gYXdhaXQgem9uZXNTZXJ2aWNlLmdldFpvbmVzQnlDYXRlZ29yeShhZmZlY3RlZENhdGVnb3J5SWQpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuaGFuY2VkWm9uZXMgPSB6b25lc0RhdGEubWFwKG1hcFRvRW5oYW5jZWRab25lKTtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBhZmZlY3RlZENhdGVnb3J5SWQgPyB7Li4uYywgem9uZXM6IGVuaGFuY2VkWm9uZXN9IDogYykpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgY29uc29sZS5lcnJvcihgW1JlYWx0aW1lXSBFcnJvciByZWZldGNoaW5nIHpvbmVzIGZvciBjYXRlZ29yeSAke2FmZmVjdGVkQ2F0ZWdvcnlJZH06YCwgZXJyb3IpOyB9XG4gICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ2NhdGVnb3J5X2Rpc2NvcmRfcm9sZV9wZXJtaXNzaW9ucycpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtSZWFsdGltZV0gUm9sZXMgJHtldmVudFR5cGV9IGZvciBDYXRlZ29yeSAke2FmZmVjdGVkQ2F0ZWdvcnlJZH1gKTtcbiAgICAgICAgLy8gUmVmZXRjaCByb2xlcyBmb3IgdGhlIGFmZmVjdGVkIGNhdGVnb3J5XG4gICAgICAgICBpZiAoY2F0ZWdvcmllcy5zb21lKGMgPT4gYy5pZCA9PT0gYWZmZWN0ZWRDYXRlZ29yeUlkKSkgeyAvLyBPbmx5IHJlZmV0Y2ggaWYgY2F0ZWdvcnkgaXMgcmVsZXZhbnRcbiAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvbGVzRGF0YSA9IGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLmdldENhdGVnb3J5Um9sZVBlcm1pc3Npb25zKGFmZmVjdGVkQ2F0ZWdvcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRSb2xlcyA9IHJvbGVzRGF0YS5tYXAocCA9PiBwLmRpc2NvcmRSb2xlSWQpO1xuICAgICAgICAgICAgICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBhZmZlY3RlZENhdGVnb3J5SWQgPyB7Li4uYywgYWxsb3dlZFJvbGVzOiBhbGxvd2VkUm9sZXN9IDogYykpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7IGNvbnNvbGUuZXJyb3IoYFtSZWFsdGltZV0gRXJyb3IgcmVmZXRjaGluZyByb2xlcyBmb3IgY2F0ZWdvcnkgJHthZmZlY3RlZENhdGVnb3J5SWR9OmAsIGVycm9yKTsgfVxuICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICB9XG4gICAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtndWlsZElkLCBzZXRDYXRlZ29yaWVzLCBjYXRlZ29yaWVzXSk7IC8vICdjYXRlZ29yaWVzJyBhZGRlZCBhcyBkZXAgYmVjYXVzZSB3ZSBjaGVjayBhZ2FpbnN0IGl0XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50R3VpbGRJZCA9IGN1cnJlbnRHdWlsZD8uaWQ7XG4gICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIEVmZmVjdF0gUnVubmluZyBmb3IgZ3VpbGRJZDogJHtjdXJyZW50R3VpbGRJZCB8fCAnbm9uZSd9YCk7XG5cbiAgICBpZiAoIWN1cnJlbnRHdWlsZElkKSB7XG4gICAgICBzZXRDYXRlZ29yaWVzKFtdKTtcbiAgICAgIGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCA9ICcnO1xuICAgICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAocmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc3VwYWJhc2UucmVtb3ZlQ2hhbm5lbChyZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCk7XG4gICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ICE9PSBjdXJyZW50R3VpbGRJZCkge1xuICAgICAgbG9hZENhdGVnb3JpZXMoY3VycmVudEd1aWxkSWQpO1xuICAgIH1cblxuICAgIGxldCBjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwgfCBudWxsID0gcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgZGItY2hhbmdlc2A7IC8vIExpc3RlbiB0byBhbGwgY2hhbmdlcyBvbiBvbmUgY2hhbm5lbFxuXG4gICAgaWYgKCFjaGFubmVsIHx8ICFjaGFubmVsLmlzU3Vic2NyaWJlZCgpKSB7XG4gICAgICAgIGlmIChjaGFubmVsKSBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIFNldHRpbmcgdXAgY2hhbm5lbDogJHtjaGFubmVsTmFtZX1gKTtcbiAgICAgICAgY2hhbm5lbCA9IHN1cGFiYXNlLmNoYW5uZWwoY2hhbm5lbE5hbWUpO1xuICAgICAgICBjaGFubmVsXG4gICAgICAgICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnY2F0ZWdvcmllcycgfSwgaGFuZGxlUmVhbHRpbWVFdmVudClcbiAgICAgICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICd6b25lcycgfSwgaGFuZGxlUmVhbHRpbWVFdmVudClcbiAgICAgICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjYXRlZ29yeV9kaXNjb3JkX3JvbGVfcGVybWlzc2lvbnMnIH0sIGhhbmRsZVJlYWx0aW1lRXZlbnQpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChzdGF0dXMsIGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIFN1YiBzdGF0dXMgJHtjaGFubmVsTmFtZX06YCwgc3RhdHVzLCBlcnIgfHwgJycpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdTVUJTQ1JJQkVEJykge1xuICAgICAgICAgICAgICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IGNoYW5uZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBSZS1mZXRjaGluZyBkYXRhIGFmdGVyIHN1Y2Nlc3NmdWwgc3Vic2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZENhdGVnb3JpZXMoY3VycmVudEd1aWxkSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIEFscmVhZHkgc3Vic2NyaWJlZCB0byAke2NoYW5uZWxOYW1lfWApO1xuICAgIH1cblxuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBDbGVhbnVwIGZvciBndWlsZElkOiAke2N1cnJlbnRHdWlsZElkfWApO1xuICAgICAgLy8gRG9uJ3QgcmVtb3ZlIHRoZSBjaGFubmVsIGhlcmUgaWYgaXQncyBhIHNoYXJlZCBjaGFubmVsXG4gICAgICAvLyBTdXBhYmFzZSBoYW5kbGVzIGNoYW5uZWwgY2xlYW51cCBvbiB1bm1vdW50L2Rpc2Nvbm5lY3QgYXV0b21hdGljYWxseVxuICAgICAgLy8gaWYgKHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwocmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQpO1xuICAgICAgLy8gICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAvLyB9XG4gICAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbY3VycmVudEd1aWxkPy5pZCwgbG9hZENhdGVnb3JpZXMsIGhhbmRsZVJlYWx0aW1lRXZlbnRdKTsgLy8gRGVwZW5kZW5jaWVzIHVwZGF0ZWRcblxuICBjb25zdCB0b2dnbGVDYXRlZ29yeUV4cGFuZCA9IHVzZUNhbGxiYWNrKChjYXRlZ29yeUlkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRFeHBhbmRlZENhdGVnb3JpZXMocHJldiA9PlxuICAgICAgcHJldi5pbmNsdWRlcyhjYXRlZ29yeUlkKVxuICAgICAgICA/IHByZXYuZmlsdGVyKGlkID0+IGlkICE9PSBjYXRlZ29yeUlkKVxuICAgICAgICA6IFsuLi5wcmV2LCBjYXRlZ29yeUlkXVxuICAgICk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzYXZlQ2F0ZWdvcnkgPSB1c2VDYWxsYmFjayhhc3luYyAoY2F0ZWdvcnlEYXRhOiBDYXRlZ29yeUlucHV0KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgIGlmICghZ3VpbGRJZCkgeyB0b2FzdC5lcnJvcignS2VpbmUgR3VpbGQgYXVzZ2V3w6RobHQnKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgIHRyeSB7XG4gICAgICAgY29uc3QgZHRvRGF0YVNjb3BlID0geyBzY29wZVR5cGU6IFNjb3BlVHlwZS5HVUlMRCwgc2NvcGVJZDogZ3VpbGRJZCB9OyAvLyBEZWZpbmUgc2NvcGVcbiAgICAgICBpZiAoY2F0ZWdvcnlEYXRhLmlkKSB7XG4gICAgICAgICBjb25zdCB1cGRhdGVEYXRhOiBVcGRhdGVDYXRlZ29yeUR0byA9IHtcbiAgICAgICAgICAgIG5hbWU6IGNhdGVnb3J5RGF0YS5uYW1lLCBpc1Zpc2libGVEZWZhdWx0OiBjYXRlZ29yeURhdGEuaXNWaXNpYmxlLFxuICAgICAgICAgICAgc2V0dXBGbG93RW5hYmxlZDogY2F0ZWdvcnlEYXRhLnNlbmRTZXR1cCwgZGVmYXVsdFRyYWNraW5nRW5hYmxlZDogY2F0ZWdvcnlEYXRhLnRyYWNraW5nQWN0aXZlLFxuICAgICAgICAgICAgc2V0dXBDaGFubmVsTmFtZTogY2F0ZWdvcnlEYXRhLnNldHVwVGV4dENoYW5uZWwgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgd2FydGVyYXVtQ2hhbm5lbE5hbWU6IGNhdGVnb3J5RGF0YS53YWl0aW5nUm9vbU5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGlzY29yZFJvbGVJZHM6IGNhdGVnb3J5RGF0YS5hbGxvd2VkUm9sZXNcbiAgICAgICAgIH07XG4gICAgICAgICBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS51cGRhdGVDYXRlZ29yeShjYXRlZ29yeURhdGEuaWQsIHVwZGF0ZURhdGEpO1xuICAgICAgICAgdG9hc3Quc3VjY2VzcygnS2F0ZWdvcmllIGFrdHVhbGlzaWVydCcpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICBjb25zdCBjcmVhdGVEYXRhOiBDcmVhdGVDYXRlZ29yeUR0byA9IHtcbiAgICAgICAgICAgIHNjb3BlOiBkdG9EYXRhU2NvcGUsIC8vIFVzZSBkZWZpbmVkIHNjb3BlXG4gICAgICAgICAgICBuYW1lOiBjYXRlZ29yeURhdGEubmFtZSwgaXNWaXNpYmxlRGVmYXVsdDogY2F0ZWdvcnlEYXRhLmlzVmlzaWJsZSxcbiAgICAgICAgICAgIHNldHVwRmxvd0VuYWJsZWQ6IGNhdGVnb3J5RGF0YS5zZW5kU2V0dXAsIGRlZmF1bHRUcmFja2luZ0VuYWJsZWQ6IGNhdGVnb3J5RGF0YS50cmFja2luZ0FjdGl2ZSxcbiAgICAgICAgICAgIHNldHVwQ2hhbm5lbE5hbWU6IGNhdGVnb3J5RGF0YS5zZXR1cFRleHRDaGFubmVsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHdhcnRlcmF1bUNoYW5uZWxOYW1lOiBjYXRlZ29yeURhdGEud2FpdGluZ1Jvb21OYW1lIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRpc2NvcmRSb2xlSWRzOiBjYXRlZ29yeURhdGEuYWxsb3dlZFJvbGVzXG4gICAgICAgICB9O1xuICAgICAgICAgYXdhaXQgY2F0ZWdvcmllc1NlcnZpY2UuY3JlYXRlQ2F0ZWdvcnkoY3JlYXRlRGF0YSk7XG4gICAgICAgICB0b2FzdC5zdWNjZXNzKCdLYXRlZ29yaWUgZXJzdGVsbHQnKTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHRydWU7XG4gICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICBjb25zb2xlLmVycm9yKCdGZWhsZXIgYmVpbSBTcGVpY2hlcm4gZGVyIEthdGVnb3JpZTonLCBlcnIpO1xuICAgICAgICAgdG9hc3QuZXJyb3IoZXJyLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8ICdGZWhsZXIgYmVpbSBTcGVpY2hlcm4gZGVyIEthdGVnb3JpZScpO1xuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICB9XG4gICAgIGZpbmFsbHkgeyBzZXRMb2FkaW5nKGZhbHNlKTsgfVxuICAgfSwgW2d1aWxkSWRdKTtcblxuICBjb25zdCBkZWxldGVDYXRlZ29yeSA9IHVzZUNhbGxiYWNrKGFzeW5jIChjYXRlZ29yeUlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZT86IHN0cmluZyB9PiA9PiB7XG4gICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgIHRyeSB7XG4gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2F0ZWdvcmllc1NlcnZpY2UuZGVsZXRlQ2F0ZWdvcnkoY2F0ZWdvcnlJZCk7XG4gICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB0b2FzdC5zdWNjZXNzKCdLYXRlZ29yaWUgZ2Vsw7ZzY2h0LicpO1xuICAgICAgIGVsc2UgdG9hc3QuZXJyb3IocmVzdWx0Lm1lc3NhZ2UgfHwgJ0ZlaGxlciBiZWltIEzDtnNjaGVuJyk7XG4gICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICBjb25zb2xlLmVycm9yKCdGZWhsZXIgYmVpbSBMw7ZzY2hlbiBkZXIgS2F0ZWdvcmllOicsIGVycik7XG4gICAgICAgY29uc3QgbWVzc2FnZSA9IGVyci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnRmVobGVyIGJlaW0gTMO2c2NoZW4gZGVyIEthdGVnb3JpZSc7XG4gICAgICAgdG9hc3QuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2UgfTtcbiAgICAgfVxuICAgICBmaW5hbGx5IHsgc2V0TG9hZGluZyhmYWxzZSk7IH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlZmV0Y2ggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzXSByZWZldGNoIHRyaWdnZXJlZCcpO1xuICAgIGlmIChjdXJyZW50R3VpbGQ/LmlkKSB7XG4gICAgICBsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgIGluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgbG9hZENhdGVnb3JpZXMoY3VycmVudEd1aWxkLmlkKTtcbiAgICB9XG4gIH0sIFtjdXJyZW50R3VpbGQ/LmlkLCBsb2FkQ2F0ZWdvcmllc10pO1xuXG4gIGNvbnN0IGdldFRvdGFsU3RhdHMgPSB1c2VDYWxsYmFjaygoKSA9PiAoe1xuICAgIHRvdGFsQ2F0ZWdvcmllczogY2F0ZWdvcmllcy5sZW5ndGgsXG4gICAgdG90YWxVc2VyczogY2F0ZWdvcmllcy5yZWR1Y2UoKHN1bSwgYykgPT4gc3VtICsgYy50b3RhbFVzZXJzLCAwKSxcbiAgICB0b3RhbFRpbWU6IGNhdGVnb3JpZXMucmVkdWNlKChzdW0sIGMpID0+IHN1bSArIGMudG90YWxUaW1lU3BlbnQsIDApXG4gIH0pLCBbY2F0ZWdvcmllc10pO1xuXG4gIHJldHVybiB7XG4gICAgY2F0ZWdvcmllcywgbG9hZGluZywgZXJyb3IsIGV4cGFuZGVkQ2F0ZWdvcmllcywgc2VhcmNoUXVlcnksXG4gICAgc2V0U2VhcmNoUXVlcnksIHRvZ2dsZUNhdGVnb3J5RXhwYW5kLCBzYXZlQ2F0ZWdvcnksIGRlbGV0ZUNhdGVnb3J5LFxuICAgIGdldFRvdGFsU3RhdHMsIHJlZmV0Y2hcbiAgfTtcbn07Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ0b2FzdCIsInVzZUd1aWxkIiwiY2F0ZWdvcmllc1NlcnZpY2UiLCJ6b25lc1NlcnZpY2UiLCJTY29wZVR5cGUiLCJzdXBhYmFzZSIsIm1hcFRvRW5oYW5jZWRab25lIiwiem9uZSIsImlkIiwibmFtZSIsInpvbmVLZXkiLCJ6b25lX2tleSIsIm1pbnV0ZXNSZXF1aXJlZCIsImludGVydmFsX21pbnV0ZXMiLCJpbnRlcnZhbE1pbnV0ZXMiLCJwb2ludHNHcmFudGVkIiwicG9pbnRzX3Blcl9pbnRlcnZhbCIsInBvaW50c1BlckludGVydmFsIiwibGFzdEFjdGl2ZSIsInRvdGFsVGltZVNwZW50IiwidG90YWxVc2VycyIsIm1hcFRvRW5oYW5jZWRDYXRlZ29yeSIsImNhdGVnb3J5IiwiZ3VpbGRJZCIsInpvbmVzIiwiZ3VpbGRfaWQiLCJhbGxvd2VkUm9sZXMiLCJpc1Zpc2libGUiLCJpc192aXNpYmxlX2RlZmF1bHQiLCJpc1Zpc2libGVEZWZhdWx0Iiwic2VuZFNldHVwIiwic2V0dXBfZmxvd19lbmFibGVkIiwic2V0dXBGbG93RW5hYmxlZCIsInRyYWNraW5nQWN0aXZlIiwiZGVmYXVsdF90cmFja2luZ19lbmFibGVkIiwiZGVmYXVsdFRyYWNraW5nRW5hYmxlZCIsInNldHVwVGV4dENoYW5uZWwiLCJzZXR1cF9jaGFubmVsX2lkIiwic2V0dXBDaGFubmVsSWQiLCJ3YWl0aW5nUm9vbU5hbWUiLCJ3YXJ0ZXJhdW1fY2hhbm5lbF9pZCIsIndhcnRlcmF1bUNoYW5uZWxJZCIsImRpc2NvcmRDYXRlZ29yeUlkIiwiZGlzY29yZF9jYXRlZ29yeV9pZCIsImRlbGV0ZWRJbkRpc2NvcmQiLCJjcmVhdGVkQXQiLCJEYXRlIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRBdCIsInVwZGF0ZWRfYXQiLCJ1c2VDYXRlZ29yaWVzIiwiY3VycmVudEd1aWxkIiwiY2F0ZWdvcmllcyIsInNldENhdGVnb3JpZXMiLCJleHBhbmRlZENhdGVnb3JpZXMiLCJzZXRFeHBhbmRlZENhdGVnb3JpZXMiLCJzZWFyY2hRdWVyeSIsInNldFNlYXJjaFF1ZXJ5IiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwicmVhbHRpbWVDaGFubmVsUmVmIiwibG9hZGVkR3VpbGRJZFJlZiIsImluaXRpYWxMb2FkQ29tcGxldGVSZWYiLCJsb2FkQ2F0ZWdvcmllcyIsImd1aWxkSWRUb0xvYWQiLCJjdXJyZW50IiwiY29uc29sZSIsImxvZyIsImNhdGVnb3JpZXNEYXRhIiwiZ2V0Q2F0ZWdvcmllcyIsIkdVSUxEIiwiZW5oYW5jZWRDYXRlZ29yaWVzUHJvbWlzZXMiLCJtYXAiLCJ6b25lc0RhdGEiLCJnZXRab25lc0J5Q2F0ZWdvcnkiLCJlbmhhbmNlZFpvbmVzIiwicm9sZXNEYXRhIiwiZ2V0Q2F0ZWdvcnlSb2xlUGVybWlzc2lvbnMiLCJwIiwiZGlzY29yZFJvbGVJZCIsIm1hcHBlZENhdGVnb3J5IiwiZW5oYW5jZWRDYXRlZ29yaWVzIiwiUHJvbWlzZSIsImFsbCIsImxlbmd0aCIsImVyciIsImhhbmRsZVJlYWx0aW1lRXZlbnQiLCJwYXlsb2FkIiwiZXZlbnRUeXBlIiwibmV3IiwibmV3UmVjb3JkIiwib2xkIiwib2xkUmVjb3JkIiwidGFibGUiLCJzY2hlbWEiLCJyZWNvcmQiLCJhZmZlY3RlZENhdGVnb3J5SWQiLCJjYXRlZ29yeV9pZCIsImlzUmVsZXZhbnRDYXRlZ29yeSIsImNhdElkIiwic29tZSIsImMiLCJuZXdDYXRlZ29yeSIsInByZXYiLCJ0aGVuIiwiY2F0Y2giLCJmaWx0ZXIiLCJjdXJyZW50R3VpbGRJZCIsInJlbW92ZUNoYW5uZWwiLCJjaGFubmVsIiwiY2hhbm5lbE5hbWUiLCJpc1N1YnNjcmliZWQiLCJvbiIsImV2ZW50Iiwic3Vic2NyaWJlIiwic3RhdHVzIiwidG9nZ2xlQ2F0ZWdvcnlFeHBhbmQiLCJjYXRlZ29yeUlkIiwiaW5jbHVkZXMiLCJzYXZlQ2F0ZWdvcnkiLCJjYXRlZ29yeURhdGEiLCJkdG9EYXRhU2NvcGUiLCJzY29wZVR5cGUiLCJzY29wZUlkIiwidXBkYXRlRGF0YSIsInNldHVwQ2hhbm5lbE5hbWUiLCJ1bmRlZmluZWQiLCJ3YXJ0ZXJhdW1DaGFubmVsTmFtZSIsImRpc2NvcmRSb2xlSWRzIiwidXBkYXRlQ2F0ZWdvcnkiLCJzdWNjZXNzIiwiY3JlYXRlRGF0YSIsInNjb3BlIiwiY3JlYXRlQ2F0ZWdvcnkiLCJyZXNwb25zZSIsImRhdGEiLCJtZXNzYWdlIiwiZGVsZXRlQ2F0ZWdvcnkiLCJyZXN1bHQiLCJyZWZldGNoIiwiZ2V0VG90YWxTdGF0cyIsInRvdGFsQ2F0ZWdvcmllcyIsInJlZHVjZSIsInN1bSIsInRvdGFsVGltZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts\n"));

/***/ })

});