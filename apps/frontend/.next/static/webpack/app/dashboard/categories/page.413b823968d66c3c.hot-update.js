"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/categories/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts":
/*!*****************************************************************************!*\
  !*** ./src/components/dashboard/category-management/hooks/useCategories.ts ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCategories: () => (/* binding */ useCategories)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/core/toaster */ \"(app-pages-browser)/./src/components/core/toaster.tsx\");\n/* harmony import */ var _context_guild_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/context/guild-context */ \"(app-pages-browser)/./src/context/guild-context.tsx\");\n/* harmony import */ var _services_categories__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/categories */ \"(app-pages-browser)/./src/services/categories.ts\");\n/* harmony import */ var _services_zones__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/zones */ \"(app-pages-browser)/./src/services/zones.ts\");\n/* harmony import */ var shared_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! shared-types */ \"(app-pages-browser)/../../packages/shared-types/src/index.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useCategories auto */ \n\n\n\n\n\n\n// Interfaces (EnhancedCategory, EnhancedZone, CategoryInput) bleiben unverÃ¤ndert\nconst useCategories = ()=>{\n    const { currentGuild } = (0,_context_guild_context__WEBPACK_IMPORTED_MODULE_2__.useGuild)();\n    const guildId = (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) || '';\n    console.log(\"[useCategories] Hook rendered. GuildId: \".concat(guildId));\n    const [categories, setCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [expandedCategories, setExpandedCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [searchQuery, setSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const realtimeChannelRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadedGuildIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)('');\n    const initialLoadCompleteRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false); // Verfolgt, ob der initiale Ladevorgang abgeschlossen ist\n    // --- Memoized Ladefunktion ---\n    const loadCategories = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[loadCategories]\": async (guildIdToLoad)=>{\n            if (!guildIdToLoad) {\n                console.log('[useCategories] loadCategories: No Guild ID provided.');\n                setCategories([]); // Clear state if no guild is selected\n                loadedGuildIdRef.current = ''; // Reset loaded ref\n                initialLoadCompleteRef.current = false;\n                return;\n            }\n            // Prevent re-fetching if already loading for the *same* guild\n            if (loading && loadedGuildIdRef.current === guildIdToLoad) {\n                console.log(\"[useCategories] loadCategories: Already loading for \".concat(guildIdToLoad, \". Skipping.\"));\n                return;\n            }\n            console.log(\"[useCategories] loadCategories: Loading categories for Guild: \".concat(guildIdToLoad));\n            setLoading(true);\n            setError(null);\n            initialLoadCompleteRef.current = false; // Mark as loading\n            try {\n                const categoriesData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategories(shared_types__WEBPACK_IMPORTED_MODULE_5__.ScopeType.GUILD, guildIdToLoad);\n                const enhancedCategoriesPromises = categoriesData.map({\n                    \"useCategories.useCallback[loadCategories].enhancedCategoriesPromises\": async (category)=>{\n                        // Fetch zones concurrently is fine here\n                        const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(category.id);\n                        const enhancedZones = zonesData.map({\n                            \"useCategories.useCallback[loadCategories].enhancedCategoriesPromises.enhancedZones\": (zone)=>({\n                                    id: zone.id,\n                                    name: zone.name,\n                                    zoneKey: zone.zoneKey,\n                                    minutesRequired: zone.intervalMinutes,\n                                    pointsGranted: zone.pointsPerInterval,\n                                    lastActive: '-',\n                                    totalTimeSpent: 0,\n                                    totalUsers: 0\n                                })\n                        }[\"useCategories.useCallback[loadCategories].enhancedCategoriesPromises.enhancedZones\"]);\n                        return {\n                            id: category.id,\n                            name: category.name,\n                            guild_id: guildIdToLoad,\n                            allowedRoles: category.allowedRoles || [],\n                            isVisible: category.isVisibleDefault,\n                            sendSetup: category.setupFlowEnabled,\n                            trackingActive: category.defaultTrackingEnabled,\n                            setupTextChannel: category.setupChannelId,\n                            waitingRoomName: category.warteraumChannelId,\n                            lastActive: '-',\n                            totalTimeSpent: 0,\n                            totalUsers: 0,\n                            discordCategoryId: category.discordCategoryId || null,\n                            deletedInDiscord: !category.discordCategoryId,\n                            createdAt: new Date(category.createdAt),\n                            updatedAt: new Date(category.updatedAt),\n                            zones: enhancedZones\n                        };\n                    }\n                }[\"useCategories.useCallback[loadCategories].enhancedCategoriesPromises\"]);\n                const enhancedCategories = await Promise.all(enhancedCategoriesPromises);\n                setCategories(enhancedCategories);\n                loadedGuildIdRef.current = guildIdToLoad; // Mark as loaded for this guild\n                initialLoadCompleteRef.current = true; // Mark initial load as complete\n                console.log(\"[useCategories] loadCategories: \".concat(enhancedCategories.length, \" categories loaded for \").concat(guildIdToLoad));\n            } catch (err) {\n                console.error(\"[useCategories] Error loading categories for \".concat(guildIdToLoad, \":\"), err);\n                setError('Fehler beim Laden der Kategorien');\n                setCategories([]); // Reset on error\n                loadedGuildIdRef.current = guildIdToLoad; // Still mark as attempted load\n                initialLoadCompleteRef.current = true; // Mark as complete even on error\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[loadCategories]\"], [\n        loading\n    ]); // Depend on loading to prevent parallel fetches\n    // --- Memoized Realtime Handler ---\n    const handleRealtimeEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[handleRealtimeEvent]\": (payload)=>{\n            console.log('[useCategories handleRealtimeEvent]', payload);\n            const { eventType, new: newRecord, old: oldRecord, table } = payload;\n            const record = newRecord || oldRecord;\n            if (!record) return;\n            const affectedCategoryId = table === 'categories' ? record.id : record.category_id;\n            if (!affectedCategoryId) return;\n            // Optimistic updates based on payload, followed by potential refetch if needed\n            if (table === 'categories') {\n                if (eventType === 'INSERT' && newRecord) {\n                    console.log(\"[Realtime] Category INSERT: \".concat(newRecord.id));\n                    const newCategory = {\n                        id: newRecord.id,\n                        name: newRecord.name,\n                        guild_id: guildId,\n                        allowedRoles: [],\n                        isVisible: newRecord.is_visible_default,\n                        sendSetup: newRecord.setup_flow_enabled,\n                        trackingActive: newRecord.default_tracking_enabled,\n                        setupTextChannel: newRecord.setup_channel_id,\n                        waitingRoomName: newRecord.warteraum_channel_id,\n                        lastActive: '-',\n                        totalTimeSpent: 0,\n                        totalUsers: 0,\n                        discordCategoryId: newRecord.discord_category_id || null,\n                        deletedInDiscord: !newRecord.discord_category_id,\n                        createdAt: new Date(newRecord.created_at),\n                        updatedAt: new Date(newRecord.updated_at),\n                        zones: [] // Initialize with empty zones, fetch separately if needed\n                    };\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>[\n                                ...prev,\n                                newCategory\n                            ]\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                    // Optional: Fetch zones for the new category in the background\n                    _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(newRecord.id).then({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (zonesData)=>{\n                            const enhancedZones = zonesData.map({\n                                \"useCategories.useCallback[handleRealtimeEvent].enhancedZones\": (zone)=>({})\n                            }[\"useCategories.useCallback[handleRealtimeEvent].enhancedZones\"]);\n                            setCategories({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                        \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newRecord.id ? {\n                                                ...c,\n                                                zones: enhancedZones\n                                            } : c\n                                    }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        }\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                } else if (eventType === 'UPDATE' && newRecord) {\n                    console.log(\"[Realtime] Category UPDATE: \".concat(newRecord.id));\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newRecord.id ? {\n                                        ...c,\n                                        name: newRecord.name,\n                                        isVisible: newRecord.is_visible_default,\n                                        sendSetup: newRecord.setup_flow_enabled,\n                                        trackingActive: newRecord.default_tracking_enabled,\n                                        setupTextChannel: newRecord.setup_channel_id,\n                                        waitingRoomName: newRecord.warteraum_channel_id,\n                                        discordCategoryId: newRecord.discord_category_id || null,\n                                        deletedInDiscord: !newRecord.discord_category_id,\n                                        updatedAt: new Date(newRecord.updated_at)\n                                    } : c\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                } else if (eventType === 'DELETE' && oldRecord) {\n                    console.log(\"[Realtime] Category DELETE: \".concat(oldRecord.id));\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.filter({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id !== oldRecord.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                }\n            } else if (table === 'zones') {\n                // A zone changed, update the zones array for the relevant category\n                console.log(\"[Realtime] Zone \".concat(eventType, \" for Category \").concat(affectedCategoryId));\n                ({\n                    \"useCategories.useCallback[handleRealtimeEvent]\": async ()=>{\n                        try {\n                            const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(affectedCategoryId);\n                            const enhancedZones = zonesData.map({\n                                \"useCategories.useCallback[handleRealtimeEvent].enhancedZones\": (zone)=>({})\n                            }[\"useCategories.useCallback[handleRealtimeEvent].enhancedZones\"]);\n                            setCategories({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                        \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === affectedCategoryId ? {\n                                                ...c,\n                                                zones: enhancedZones\n                                            } : c\n                                    }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        } catch (error) {\n                            console.error(\"[Realtime] Error refetching zones for category \".concat(affectedCategoryId, \":\"), error);\n                        }\n                    }\n                })[\"useCategories.useCallback[handleRealtimeEvent]\"]();\n            } else if (table === 'category_discord_role_permissions') {\n                // Roles changed, update allowedRoles for the relevant category\n                console.log(\"[Realtime] Roles \".concat(eventType, \" for Category \").concat(affectedCategoryId));\n                ({\n                    \"useCategories.useCallback[handleRealtimeEvent]\": async ()=>{\n                        try {\n                            const categoryData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryById(affectedCategoryId);\n                            if (categoryData) {\n                                setCategories({\n                                    \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                            \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === affectedCategoryId ? {\n                                                    ...c,\n                                                    allowedRoles: categoryData.allowedRoles || []\n                                                } : c\n                                        }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                                }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                            }\n                        } catch (error) {\n                            console.error(\"[Realtime] Error refetching roles for category \".concat(affectedCategoryId, \":\"), error);\n                        }\n                    }\n                })[\"useCategories.useCallback[handleRealtimeEvent]\"]();\n            }\n        }\n    }[\"useCategories.useCallback[handleRealtimeEvent]\"], [\n        guildId,\n        setCategories\n    ]); // Dependencies: guildId for context, setCategories for state update\n    // --- Haupt-useEffect fÃ¼r Laden und Subscription ---\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCategories.useEffect\": ()=>{\n            const currentGuildId = currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id;\n            console.log(\"[useCategories Effect] Running for guildId: \".concat(currentGuildId || 'none'));\n            if (!currentGuildId) {\n                console.log('[useCategories Effect] No guildId, resetting.');\n                setCategories([]);\n                loadedGuildIdRef.current = '';\n                initialLoadCompleteRef.current = false;\n                if (realtimeChannelRef.current) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(realtimeChannelRef.current);\n                    realtimeChannelRef.current = null;\n                }\n                return;\n            }\n            // Load data only if the guild changed\n            if (loadedGuildIdRef.current !== currentGuildId) {\n                loadCategories(currentGuildId);\n            }\n            // Setup subscription\n            let channel = realtimeChannelRef.current;\n            const channelName = \"categories:\".concat(currentGuildId);\n            // Subscribe only if not already subscribed to the correct channel\n            if (!channel || channel.topic !== \"realtime:\".concat(channelName)) {\n                if (channel) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(channel);\n                }\n                console.log(\"[useCategories Effect] Setting up channel: \".concat(channelName));\n                channel = _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.channel(channelName);\n                channel.on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'categories'\n                }, handleRealtimeEvent).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'zones'\n                }, handleRealtimeEvent) // Single handler\n                .on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'category_discord_role_permissions'\n                }, handleRealtimeEvent) // Single handler\n                .subscribe({\n                    \"useCategories.useEffect\": (status, err)=>{\n                        console.log(\"[useCategories Effect] Sub status \".concat(channelName, \":\"), status, err || '');\n                        if (status === 'SUBSCRIBED') {\n                            realtimeChannelRef.current = channel;\n                            // Optional: Fetch data again after subscribing IF initial load hasn't completed yet\n                            // This handles cases where the initial load failed or was very slow\n                            if (!initialLoadCompleteRef.current) {\n                                console.log('[useCategories Effect] Re-fetching data after successful subscription (initial load might have failed).');\n                                loadCategories(currentGuildId);\n                            }\n                        } else {\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }[\"useCategories.useEffect\"]);\n            } else {\n                console.log(\"[useCategories Effect] Already subscribed to \".concat(channelName));\n            }\n            // Cleanup\n            return ({\n                \"useCategories.useEffect\": ()=>{\n                    console.log(\"[useCategories Effect] Cleanup for guildId: \".concat(currentGuildId));\n                    if (channel) {\n                        console.log(\"[useCategories Effect] Removing channel \".concat(channel.topic));\n                        _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(channel);\n                        realtimeChannelRef.current = null; // Ensure ref is cleared on cleanup\n                    }\n                }\n            })[\"useCategories.useEffect\"];\n        }\n    }[\"useCategories.useEffect\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories,\n        handleRealtimeEvent\n    ]); // Main dependencies\n    // --- Restliche Funktionen ---\n    const toggleCategoryExpand = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[toggleCategoryExpand]\": (categoryId)=>{\n            setExpandedCategories({\n                \"useCategories.useCallback[toggleCategoryExpand]\": (prev)=>prev.includes(categoryId) ? prev.filter({\n                        \"useCategories.useCallback[toggleCategoryExpand]\": (id)=>id !== categoryId\n                    }[\"useCategories.useCallback[toggleCategoryExpand]\"]) : [\n                        ...prev,\n                        categoryId\n                    ]\n            }[\"useCategories.useCallback[toggleCategoryExpand]\"]);\n        }\n    }[\"useCategories.useCallback[toggleCategoryExpand]\"], []);\n    const saveCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[saveCategory]\": async (categoryData)=>{\n            // Logic... (kann meist bleiben, da Realtime den State aktualisiert)\n            if (!guildId) {\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error('Keine Guild ausgewÃ¤hlt');\n                return false;\n            }\n            setLoading(true);\n            try {\n                if (categoryData.id) {\n                    const updateData = {\n                        name: categoryData.name,\n                        isVisibleDefault: categoryData.isVisible,\n                        setupFlowEnabled: categoryData.sendSetup,\n                        defaultTrackingEnabled: categoryData.trackingActive,\n                        setupChannelName: categoryData.setupTextChannel || undefined,\n                        warteraumChannelName: categoryData.waitingRoomName || undefined,\n                        discordRoleIds: categoryData.allowedRoles\n                    };\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.updateCategory(categoryData.id, updateData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie aktualisiert');\n                } else {\n                    const createData = {\n                        scope: {\n                            id: '',\n                            scopeType: shared_types__WEBPACK_IMPORTED_MODULE_5__.ScopeType.GUILD,\n                            scopeId: guildId\n                        },\n                        name: categoryData.name,\n                        isVisibleDefault: categoryData.isVisible,\n                        setupFlowEnabled: categoryData.sendSetup,\n                        defaultTrackingEnabled: categoryData.trackingActive,\n                        setupChannelName: categoryData.setupTextChannel || undefined,\n                        warteraumChannelName: categoryData.waitingRoomName || undefined,\n                        discordRoleIds: categoryData.allowedRoles\n                    };\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.createCategory(createData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie erstellt');\n                }\n                return true;\n            } catch (err) {\n                return false;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[saveCategory]\"], [\n        guildId\n    ]);\n    const deleteCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[deleteCategory]\": async (categoryId)=>{\n            // Logic... (kann bleiben)\n            setLoading(true);\n            try {\n                const result = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.deleteCategory(categoryId);\n                if (result.success) _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie gelÃ¶scht.');\n                return result;\n            } catch (err) {\n                return {\n                    success: false,\n                    message: 'Fehler'\n                };\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[deleteCategory]\"], []);\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[refetch]\": ()=>{\n            console.log('[useCategories] refetch triggered');\n            if (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) {\n                loadedGuildIdRef.current = ''; // Reset loaded ref to force reload\n                initialLoadCompleteRef.current = false;\n                loadCategories(currentGuild.id);\n            }\n        }\n    }[\"useCategories.useCallback[refetch]\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories\n    ]);\n    const getTotalStats = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[getTotalStats]\": ()=>({\n                totalCategories: categories.length,\n                totalUsers: categories.reduce({\n                    \"useCategories.useCallback[getTotalStats]\": (sum, c)=>sum + c.totalUsers\n                }[\"useCategories.useCallback[getTotalStats]\"], 0),\n                totalTime: categories.reduce({\n                    \"useCategories.useCallback[getTotalStats]\": (sum, c)=>sum + c.totalTimeSpent\n                }[\"useCategories.useCallback[getTotalStats]\"], 0)\n            })\n    }[\"useCategories.useCallback[getTotalStats]\"], [\n        categories\n    ]);\n    return {\n        categories,\n        loading,\n        error,\n        expandedCategories,\n        searchQuery,\n        setSearchQuery,\n        toggleCategoryExpand,\n        saveCategory,\n        deleteCategory,\n        getTotalStats,\n        refetch\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9jYXRlZ29yeS1tYW5hZ2VtZW50L2hvb2tzL3VzZUNhdGVnb3JpZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O21FQUVpRTtBQUNmO0FBQ0M7QUFDUTtBQUNWO0FBQzJDO0FBRWxEO0FBRTFDLGlGQUFpRjtBQUUxRSxNQUFNVSxnQkFBZ0I7SUFDM0IsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR04sZ0VBQVFBO0lBQ2pDLE1BQU1PLFVBQVVELENBQUFBLHlCQUFBQSxtQ0FBQUEsYUFBY0UsRUFBRSxLQUFJO0lBQ3BDQyxRQUFRQyxHQUFHLENBQUMsMkNBQW1ELE9BQVJIO0lBRXZELE1BQU0sQ0FBQ0ksWUFBWUMsY0FBYyxHQUFHakIsK0NBQVFBLENBQXFCLEVBQUU7SUFDbkUsTUFBTSxDQUFDa0Isb0JBQW9CQyxzQkFBc0IsR0FBR25CLCtDQUFRQSxDQUFXLEVBQUU7SUFDekUsTUFBTSxDQUFDb0IsYUFBYUMsZUFBZSxHQUFHckIsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDc0IsU0FBU0MsV0FBVyxHQUFHdkIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDd0IsT0FBT0MsU0FBUyxHQUFHekIsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU0wQixxQkFBcUJ2Qiw2Q0FBTUEsQ0FBeUI7SUFDMUQsTUFBTXdCLG1CQUFtQnhCLDZDQUFNQSxDQUFTO0lBQ3hDLE1BQU15Qix5QkFBeUJ6Qiw2Q0FBTUEsQ0FBQyxRQUFRLDBEQUEwRDtJQUV4RyxnQ0FBZ0M7SUFDaEMsTUFBTTBCLGlCQUFpQjNCLGtEQUFXQTtxREFBQyxPQUFPNEI7WUFDeEMsSUFBSSxDQUFDQSxlQUFlO2dCQUNsQmhCLFFBQVFDLEdBQUcsQ0FBQztnQkFDWkUsY0FBYyxFQUFFLEdBQUcsc0NBQXNDO2dCQUN6RFUsaUJBQWlCSSxPQUFPLEdBQUcsSUFBSSxtQkFBbUI7Z0JBQ2xESCx1QkFBdUJHLE9BQU8sR0FB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RixFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGluZm9cXERvY3VtZW50c1xcRGlzY29yZCBCb3RcXENoaW1lcmFcXGFwcHNcXGZyb250ZW5kXFxzcmNcXGNvbXBvbmVudHNcXGRhc2hib2FyZFxcY2F0ZWdvcnktbWFuYWdlbWVudFxcaG9va3NcXHVzZUNhdGVnb3JpZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdG9hc3QgfSBmcm9tICdAL2NvbXBvbmVudHMvY29yZS90b2FzdGVyJztcbmltcG9ydCB7IHVzZUd1aWxkIH0gZnJvbSAnQC9jb250ZXh0L2d1aWxkLWNvbnRleHQnO1xuaW1wb3J0ICogYXMgY2F0ZWdvcmllc1NlcnZpY2UgZnJvbSAnQC9zZXJ2aWNlcy9jYXRlZ29yaWVzJztcbmltcG9ydCAqIGFzIHpvbmVzU2VydmljZSBmcm9tICdAL3NlcnZpY2VzL3pvbmVzJztcbmltcG9ydCB7IENyZWF0ZUNhdGVnb3J5RHRvLCBVcGRhdGVDYXRlZ29yeUR0bywgU2NvcGVUeXBlLCBDYXRlZ29yeUR0byB9IGZyb20gJ3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgeyBSZWFsdGltZUNoYW5uZWwsIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcblxuLy8gSW50ZXJmYWNlcyAoRW5oYW5jZWRDYXRlZ29yeSwgRW5oYW5jZWRab25lLCBDYXRlZ29yeUlucHV0KSBibGVpYmVuIHVudmVyw6RuZGVydFxuXG5leHBvcnQgY29uc3QgdXNlQ2F0ZWdvcmllcyA9ICgpID0+IHtcbiAgY29uc3QgeyBjdXJyZW50R3VpbGQgfSA9IHVzZUd1aWxkKCk7XG4gIGNvbnN0IGd1aWxkSWQgPSBjdXJyZW50R3VpbGQ/LmlkIHx8ICcnO1xuICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXNdIEhvb2sgcmVuZGVyZWQuIEd1aWxkSWQ6ICR7Z3VpbGRJZH1gKTtcblxuICBjb25zdCBbY2F0ZWdvcmllcywgc2V0Q2F0ZWdvcmllc10gPSB1c2VTdGF0ZTxFbmhhbmNlZENhdGVnb3J5W10+KFtdKTtcbiAgY29uc3QgW2V4cGFuZGVkQ2F0ZWdvcmllcywgc2V0RXhwYW5kZWRDYXRlZ29yaWVzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gIGNvbnN0IFtzZWFyY2hRdWVyeSwgc2V0U2VhcmNoUXVlcnldID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlYWx0aW1lQ2hhbm5lbFJlZiA9IHVzZVJlZjxSZWFsdGltZUNoYW5uZWwgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbG9hZGVkR3VpbGRJZFJlZiA9IHVzZVJlZjxzdHJpbmc+KCcnKTtcbiAgY29uc3QgaW5pdGlhbExvYWRDb21wbGV0ZVJlZiA9IHVzZVJlZihmYWxzZSk7IC8vIFZlcmZvbGd0LCBvYiBkZXIgaW5pdGlhbGUgTGFkZXZvcmdhbmcgYWJnZXNjaGxvc3NlbiBpc3RcblxuICAvLyAtLS0gTWVtb2l6ZWQgTGFkZWZ1bmt0aW9uIC0tLVxuICBjb25zdCBsb2FkQ2F0ZWdvcmllcyA9IHVzZUNhbGxiYWNrKGFzeW5jIChndWlsZElkVG9Mb2FkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWd1aWxkSWRUb0xvYWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbdXNlQ2F0ZWdvcmllc10gbG9hZENhdGVnb3JpZXM6IE5vIEd1aWxkIElEIHByb3ZpZGVkLicpO1xuICAgICAgc2V0Q2F0ZWdvcmllcyhbXSk7IC8vIENsZWFyIHN0YXRlIGlmIG5vIGd1aWxkIGlzIHNlbGVjdGVkXG4gICAgICBsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgPSAnJzsgLy8gUmVzZXQgbG9hZGVkIHJlZlxuICAgICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFByZXZlbnQgcmUtZmV0Y2hpbmcgaWYgYWxyZWFkeSBsb2FkaW5nIGZvciB0aGUgKnNhbWUqIGd1aWxkXG4gICAgaWYgKGxvYWRpbmcgJiYgbG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ID09PSBndWlsZElkVG9Mb2FkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllc10gbG9hZENhdGVnb3JpZXM6IEFscmVhZHkgbG9hZGluZyBmb3IgJHtndWlsZElkVG9Mb2FkfS4gU2tpcHBpbmcuYCk7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllc10gbG9hZENhdGVnb3JpZXM6IExvYWRpbmcgY2F0ZWdvcmllcyBmb3IgR3VpbGQ6ICR7Z3VpbGRJZFRvTG9hZH1gKTtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIGluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCA9IGZhbHNlOyAvLyBNYXJrIGFzIGxvYWRpbmdcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYXRlZ29yaWVzRGF0YSA9IGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLmdldENhdGVnb3JpZXMoU2NvcGVUeXBlLkdVSUxELCBndWlsZElkVG9Mb2FkKTtcbiAgICAgIGNvbnN0IGVuaGFuY2VkQ2F0ZWdvcmllc1Byb21pc2VzID0gY2F0ZWdvcmllc0RhdGEubWFwKGFzeW5jIChjYXRlZ29yeSkgPT4ge1xuICAgICAgICAvLyBGZXRjaCB6b25lcyBjb25jdXJyZW50bHkgaXMgZmluZSBoZXJlXG4gICAgICAgIGNvbnN0IHpvbmVzRGF0YSA9IGF3YWl0IHpvbmVzU2VydmljZS5nZXRab25lc0J5Q2F0ZWdvcnkoY2F0ZWdvcnkuaWQpO1xuICAgICAgICBjb25zdCBlbmhhbmNlZFpvbmVzOiBFbmhhbmNlZFpvbmVbXSA9IHpvbmVzRGF0YS5tYXAoem9uZSA9PiAoe1xuICAgICAgICAgIGlkOiB6b25lLmlkLFxuICAgICAgICAgIG5hbWU6IHpvbmUubmFtZSxcbiAgICAgICAgICB6b25lS2V5OiB6b25lLnpvbmVLZXksXG4gICAgICAgICAgbWludXRlc1JlcXVpcmVkOiB6b25lLmludGVydmFsTWludXRlcyxcbiAgICAgICAgICBwb2ludHNHcmFudGVkOiB6b25lLnBvaW50c1BlckludGVydmFsLFxuICAgICAgICAgIGxhc3RBY3RpdmU6ICctJywgdG90YWxUaW1lU3BlbnQ6IDAsIHRvdGFsVXNlcnM6IDBcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBjYXRlZ29yeS5pZCwgbmFtZTogY2F0ZWdvcnkubmFtZSwgZ3VpbGRfaWQ6IGd1aWxkSWRUb0xvYWQsXG4gICAgICAgICAgYWxsb3dlZFJvbGVzOiBjYXRlZ29yeS5hbGxvd2VkUm9sZXMgfHwgW10sIGlzVmlzaWJsZTogY2F0ZWdvcnkuaXNWaXNpYmxlRGVmYXVsdCxcbiAgICAgICAgICBzZW5kU2V0dXA6IGNhdGVnb3J5LnNldHVwRmxvd0VuYWJsZWQsIHRyYWNraW5nQWN0aXZlOiBjYXRlZ29yeS5kZWZhdWx0VHJhY2tpbmdFbmFibGVkLFxuICAgICAgICAgIHNldHVwVGV4dENoYW5uZWw6IGNhdGVnb3J5LnNldHVwQ2hhbm5lbElkLCB3YWl0aW5nUm9vbU5hbWU6IGNhdGVnb3J5LndhcnRlcmF1bUNoYW5uZWxJZCxcbiAgICAgICAgICBsYXN0QWN0aXZlOiAnLScsIHRvdGFsVGltZVNwZW50OiAwLCB0b3RhbFVzZXJzOiAwLFxuICAgICAgICAgIGRpc2NvcmRDYXRlZ29yeUlkOiBjYXRlZ29yeS5kaXNjb3JkQ2F0ZWdvcnlJZCB8fCBudWxsLFxuICAgICAgICAgIGRlbGV0ZWRJbkRpc2NvcmQ6ICFjYXRlZ29yeS5kaXNjb3JkQ2F0ZWdvcnlJZCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGNhdGVnb3J5LmNyZWF0ZWRBdCksIHVwZGF0ZWRBdDogbmV3IERhdGUoY2F0ZWdvcnkudXBkYXRlZEF0KSxcbiAgICAgICAgICB6b25lczogZW5oYW5jZWRab25lc1xuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVuaGFuY2VkQ2F0ZWdvcmllcyA9IGF3YWl0IFByb21pc2UuYWxsKGVuaGFuY2VkQ2F0ZWdvcmllc1Byb21pc2VzKTtcblxuICAgICAgc2V0Q2F0ZWdvcmllcyhlbmhhbmNlZENhdGVnb3JpZXMpO1xuICAgICAgbG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ID0gZ3VpbGRJZFRvTG9hZDsgLy8gTWFyayBhcyBsb2FkZWQgZm9yIHRoaXMgZ3VpbGRcbiAgICAgIGluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCA9IHRydWU7IC8vIE1hcmsgaW5pdGlhbCBsb2FkIGFzIGNvbXBsZXRlXG4gICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXNdIGxvYWRDYXRlZ29yaWVzOiAke2VuaGFuY2VkQ2F0ZWdvcmllcy5sZW5ndGh9IGNhdGVnb3JpZXMgbG9hZGVkIGZvciAke2d1aWxkSWRUb0xvYWR9YCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbdXNlQ2F0ZWdvcmllc10gRXJyb3IgbG9hZGluZyBjYXRlZ29yaWVzIGZvciAke2d1aWxkSWRUb0xvYWR9OmAsIGVycik7XG4gICAgICBzZXRFcnJvcignRmVobGVyIGJlaW0gTGFkZW4gZGVyIEthdGVnb3JpZW4nKTtcbiAgICAgIHNldENhdGVnb3JpZXMoW10pOyAvLyBSZXNldCBvbiBlcnJvclxuICAgICAgbG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ID0gZ3VpbGRJZFRvTG9hZDsgLy8gU3RpbGwgbWFyayBhcyBhdHRlbXB0ZWQgbG9hZFxuICAgICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gdHJ1ZTsgLy8gTWFyayBhcyBjb21wbGV0ZSBldmVuIG9uIGVycm9yXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2xvYWRpbmddKTsgLy8gRGVwZW5kIG9uIGxvYWRpbmcgdG8gcHJldmVudCBwYXJhbGxlbCBmZXRjaGVzXG5cbiAgLy8gLS0tIE1lbW9pemVkIFJlYWx0aW1lIEhhbmRsZXIgLS0tXG4gIGNvbnN0IGhhbmRsZVJlYWx0aW1lRXZlbnQgPSB1c2VDYWxsYmFjaygocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPGFueT4pID0+IHtcbiAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXMgaGFuZGxlUmVhbHRpbWVFdmVudF0nLCBwYXlsb2FkKTtcbiAgICBjb25zdCB7IGV2ZW50VHlwZSwgbmV3OiBuZXdSZWNvcmQsIG9sZDogb2xkUmVjb3JkLCB0YWJsZSB9ID0gcGF5bG9hZDtcbiAgICBjb25zdCByZWNvcmQgPSBuZXdSZWNvcmQgfHwgb2xkUmVjb3JkO1xuICAgIGlmICghcmVjb3JkKSByZXR1cm47XG5cbiAgICBjb25zdCBhZmZlY3RlZENhdGVnb3J5SWQgPSB0YWJsZSA9PT0gJ2NhdGVnb3JpZXMnID8gcmVjb3JkLmlkIDogcmVjb3JkLmNhdGVnb3J5X2lkO1xuICAgIGlmICghYWZmZWN0ZWRDYXRlZ29yeUlkKSByZXR1cm47XG5cbiAgICAvLyBPcHRpbWlzdGljIHVwZGF0ZXMgYmFzZWQgb24gcGF5bG9hZCwgZm9sbG93ZWQgYnkgcG90ZW50aWFsIHJlZmV0Y2ggaWYgbmVlZGVkXG5cbiAgICBpZiAodGFibGUgPT09ICdjYXRlZ29yaWVzJykge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ0lOU0VSVCcgJiYgbmV3UmVjb3JkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbUmVhbHRpbWVdIENhdGVnb3J5IElOU0VSVDogJHtuZXdSZWNvcmQuaWR9YCk7XG4gICAgICAgIGNvbnN0IG5ld0NhdGVnb3J5OiBFbmhhbmNlZENhdGVnb3J5ID0ge1xuICAgICAgICAgIGlkOiBuZXdSZWNvcmQuaWQsIG5hbWU6IG5ld1JlY29yZC5uYW1lLCBndWlsZF9pZDogZ3VpbGRJZCxcbiAgICAgICAgICBhbGxvd2VkUm9sZXM6IFtdLCAvLyBOZWVkIHRvIGZldGNoIHNlcGFyYXRlbHkgb3IgaGFuZGxlIHZpYSByb2xlIGV2ZW50XG4gICAgICAgICAgaXNWaXNpYmxlOiBuZXdSZWNvcmQuaXNfdmlzaWJsZV9kZWZhdWx0LCBzZW5kU2V0dXA6IG5ld1JlY29yZC5zZXR1cF9mbG93X2VuYWJsZWQsXG4gICAgICAgICAgdHJhY2tpbmdBY3RpdmU6IG5ld1JlY29yZC5kZWZhdWx0X3RyYWNraW5nX2VuYWJsZWQsXG4gICAgICAgICAgc2V0dXBUZXh0Q2hhbm5lbDogbmV3UmVjb3JkLnNldHVwX2NoYW5uZWxfaWQsIHdhaXRpbmdSb29tTmFtZTogbmV3UmVjb3JkLndhcnRlcmF1bV9jaGFubmVsX2lkLFxuICAgICAgICAgIGxhc3RBY3RpdmU6ICctJywgdG90YWxUaW1lU3BlbnQ6IDAsIHRvdGFsVXNlcnM6IDAsXG4gICAgICAgICAgZGlzY29yZENhdGVnb3J5SWQ6IG5ld1JlY29yZC5kaXNjb3JkX2NhdGVnb3J5X2lkIHx8IG51bGwsIGRlbGV0ZWRJbkRpc2NvcmQ6ICFuZXdSZWNvcmQuZGlzY29yZF9jYXRlZ29yeV9pZCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKG5ld1JlY29yZC5jcmVhdGVkX2F0KSwgdXBkYXRlZEF0OiBuZXcgRGF0ZShuZXdSZWNvcmQudXBkYXRlZF9hdCksXG4gICAgICAgICAgem9uZXM6IFtdIC8vIEluaXRpYWxpemUgd2l0aCBlbXB0eSB6b25lcywgZmV0Y2ggc2VwYXJhdGVseSBpZiBuZWVkZWRcbiAgICAgICAgfTtcbiAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdDYXRlZ29yeV0pO1xuICAgICAgICAvLyBPcHRpb25hbDogRmV0Y2ggem9uZXMgZm9yIHRoZSBuZXcgY2F0ZWdvcnkgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICAgem9uZXNTZXJ2aWNlLmdldFpvbmVzQnlDYXRlZ29yeShuZXdSZWNvcmQuaWQpLnRoZW4oem9uZXNEYXRhID0+IHtcbiAgICAgICAgICAgICBjb25zdCBlbmhhbmNlZFpvbmVzID0gem9uZXNEYXRhLm1hcCh6b25lID0+ICh7LyogbWFwcGluZyAqL30gYXMgRW5oYW5jZWRab25lKSk7XG4gICAgICAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gbmV3UmVjb3JkLmlkID8gey4uLmMsIHpvbmVzOiBlbmhhbmNlZFpvbmVzfSA6IGMpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAnVVBEQVRFJyAmJiBuZXdSZWNvcmQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtSZWFsdGltZV0gQ2F0ZWdvcnkgVVBEQVRFOiAke25ld1JlY29yZC5pZH1gKTtcbiAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gbmV3UmVjb3JkLmlkID8ge1xuICAgICAgICAgIC4uLmMsIC8vIEtlZXAgZXhpc3Rpbmcgem9uZXMgYW5kIHJvbGVzIGZvciBub3dcbiAgICAgICAgICBuYW1lOiBuZXdSZWNvcmQubmFtZSxcbiAgICAgICAgICBpc1Zpc2libGU6IG5ld1JlY29yZC5pc192aXNpYmxlX2RlZmF1bHQsXG4gICAgICAgICAgc2VuZFNldHVwOiBuZXdSZWNvcmQuc2V0dXBfZmxvd19lbmFibGVkLFxuICAgICAgICAgIHRyYWNraW5nQWN0aXZlOiBuZXdSZWNvcmQuZGVmYXVsdF90cmFja2luZ19lbmFibGVkLFxuICAgICAgICAgIHNldHVwVGV4dENoYW5uZWw6IG5ld1JlY29yZC5zZXR1cF9jaGFubmVsX2lkLFxuICAgICAgICAgIHdhaXRpbmdSb29tTmFtZTogbmV3UmVjb3JkLndhcnRlcmF1bV9jaGFubmVsX2lkLFxuICAgICAgICAgIGRpc2NvcmRDYXRlZ29yeUlkOiBuZXdSZWNvcmQuZGlzY29yZF9jYXRlZ29yeV9pZCB8fCBudWxsLFxuICAgICAgICAgIGRlbGV0ZWRJbkRpc2NvcmQ6ICFuZXdSZWNvcmQuZGlzY29yZF9jYXRlZ29yeV9pZCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKG5ld1JlY29yZC51cGRhdGVkX2F0KVxuICAgICAgICB9IDogYykpO1xuICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdERUxFVEUnICYmIG9sZFJlY29yZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW1JlYWx0aW1lXSBDYXRlZ29yeSBERUxFVEU6ICR7b2xkUmVjb3JkLmlkfWApO1xuICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4gcHJldi5maWx0ZXIoYyA9PiBjLmlkICE9PSBvbGRSZWNvcmQuaWQpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAnem9uZXMnKSB7XG4gICAgICAgICAvLyBBIHpvbmUgY2hhbmdlZCwgdXBkYXRlIHRoZSB6b25lcyBhcnJheSBmb3IgdGhlIHJlbGV2YW50IGNhdGVnb3J5XG4gICAgICAgICBjb25zb2xlLmxvZyhgW1JlYWx0aW1lXSBab25lICR7ZXZlbnRUeXBlfSBmb3IgQ2F0ZWdvcnkgJHthZmZlY3RlZENhdGVnb3J5SWR9YCk7XG4gICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB6b25lc0RhdGEgPSBhd2FpdCB6b25lc1NlcnZpY2UuZ2V0Wm9uZXNCeUNhdGVnb3J5KGFmZmVjdGVkQ2F0ZWdvcnlJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5oYW5jZWRab25lcyA9IHpvbmVzRGF0YS5tYXAoem9uZSA9PiAoey8qIG1hcHBpbmcgKi99IGFzIEVuaGFuY2VkWm9uZSkpO1xuICAgICAgICAgICAgICAgIHNldENhdGVnb3JpZXMocHJldiA9PiBwcmV2Lm1hcChjID0+IGMuaWQgPT09IGFmZmVjdGVkQ2F0ZWdvcnlJZCA/IHsuLi5jLCB6b25lczogZW5oYW5jZWRab25lc30gOiBjKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtSZWFsdGltZV0gRXJyb3IgcmVmZXRjaGluZyB6b25lcyBmb3IgY2F0ZWdvcnkgJHthZmZlY3RlZENhdGVnb3J5SWR9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0pKCk7XG4gICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ2NhdGVnb3J5X2Rpc2NvcmRfcm9sZV9wZXJtaXNzaW9ucycpIHtcbiAgICAgICAgLy8gUm9sZXMgY2hhbmdlZCwgdXBkYXRlIGFsbG93ZWRSb2xlcyBmb3IgdGhlIHJlbGV2YW50IGNhdGVnb3J5XG4gICAgICAgICBjb25zb2xlLmxvZyhgW1JlYWx0aW1lXSBSb2xlcyAke2V2ZW50VHlwZX0gZm9yIENhdGVnb3J5ICR7YWZmZWN0ZWRDYXRlZ29yeUlkfWApO1xuICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnlEYXRhID0gYXdhaXQgY2F0ZWdvcmllc1NlcnZpY2UuZ2V0Q2F0ZWdvcnlCeUlkKGFmZmVjdGVkQ2F0ZWdvcnlJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBhZmZlY3RlZENhdGVnb3J5SWQgPyB7Li4uYywgYWxsb3dlZFJvbGVzOiBjYXRlZ29yeURhdGEuYWxsb3dlZFJvbGVzIHx8IFtdfSA6IGMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbUmVhbHRpbWVdIEVycm9yIHJlZmV0Y2hpbmcgcm9sZXMgZm9yIGNhdGVnb3J5ICR7YWZmZWN0ZWRDYXRlZ29yeUlkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9KSgpO1xuICAgIH1cblxuICB9LCBbZ3VpbGRJZCwgc2V0Q2F0ZWdvcmllc10pOyAvLyBEZXBlbmRlbmNpZXM6IGd1aWxkSWQgZm9yIGNvbnRleHQsIHNldENhdGVnb3JpZXMgZm9yIHN0YXRlIHVwZGF0ZVxuXG4gIC8vIC0tLSBIYXVwdC11c2VFZmZlY3QgZsO8ciBMYWRlbiB1bmQgU3Vic2NyaXB0aW9uIC0tLVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRHdWlsZElkID0gY3VycmVudEd1aWxkPy5pZDtcbiAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBSdW5uaW5nIGZvciBndWlsZElkOiAke2N1cnJlbnRHdWlsZElkIHx8ICdub25lJ31gKTtcblxuICAgIGlmICghY3VycmVudEd1aWxkSWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIE5vIGd1aWxkSWQsIHJlc2V0dGluZy4nKTtcbiAgICAgIHNldENhdGVnb3JpZXMoW10pO1xuICAgICAgbG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ID0gJyc7XG4gICAgICBpbml0aWFsTG9hZENvbXBsZXRlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChyZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCkge1xuICAgICAgICBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50KTtcbiAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIExvYWQgZGF0YSBvbmx5IGlmIHRoZSBndWlsZCBjaGFuZ2VkXG4gICAgaWYgKGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCAhPT0gY3VycmVudEd1aWxkSWQpIHtcbiAgICAgIGxvYWRDYXRlZ29yaWVzKGN1cnJlbnRHdWlsZElkKTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBzdWJzY3JpcHRpb25cbiAgICBsZXQgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsIHwgbnVsbCA9IHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYGNhdGVnb3JpZXM6JHtjdXJyZW50R3VpbGRJZH1gO1xuXG4gICAgLy8gU3Vic2NyaWJlIG9ubHkgaWYgbm90IGFscmVhZHkgc3Vic2NyaWJlZCB0byB0aGUgY29ycmVjdCBjaGFubmVsXG4gICAgaWYgKCFjaGFubmVsIHx8IGNoYW5uZWwudG9waWMgIT09IGByZWFsdGltZToke2NoYW5uZWxOYW1lfWApIHtcbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwoY2hhbm5lbCk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBTZXR0aW5nIHVwIGNoYW5uZWw6ICR7Y2hhbm5lbE5hbWV9YCk7XG4gICAgICBjaGFubmVsID0gc3VwYWJhc2UuY2hhbm5lbChjaGFubmVsTmFtZSk7XG4gICAgICBjaGFubmVsXG4gICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjYXRlZ29yaWVzJyB9LCBoYW5kbGVSZWFsdGltZUV2ZW50KVxuICAgICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnem9uZXMnIH0sIGhhbmRsZVJlYWx0aW1lRXZlbnQpIC8vIFNpbmdsZSBoYW5kbGVyXG4gICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjYXRlZ29yeV9kaXNjb3JkX3JvbGVfcGVybWlzc2lvbnMnIH0sIGhhbmRsZVJlYWx0aW1lRXZlbnQpIC8vIFNpbmdsZSBoYW5kbGVyXG4gICAgICAgIC5zdWJzY3JpYmUoKHN0YXR1cywgZXJyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIEVmZmVjdF0gU3ViIHN0YXR1cyAke2NoYW5uZWxOYW1lfTpgLCBzdGF0dXMsIGVyciB8fCAnJyk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ1NVQlNDUklCRUQnKSB7XG4gICAgICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IGNoYW5uZWw7XG4gICAgICAgICAgICAgLy8gT3B0aW9uYWw6IEZldGNoIGRhdGEgYWdhaW4gYWZ0ZXIgc3Vic2NyaWJpbmcgSUYgaW5pdGlhbCBsb2FkIGhhc24ndCBjb21wbGV0ZWQgeWV0XG4gICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIGNhc2VzIHdoZXJlIHRoZSBpbml0aWFsIGxvYWQgZmFpbGVkIG9yIHdhcyB2ZXJ5IHNsb3dcbiAgICAgICAgICAgICBpZiAoIWluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIEVmZmVjdF0gUmUtZmV0Y2hpbmcgZGF0YSBhZnRlciBzdWNjZXNzZnVsIHN1YnNjcmlwdGlvbiAoaW5pdGlhbCBsb2FkIG1pZ2h0IGhhdmUgZmFpbGVkKS4nKTtcbiAgICAgICAgICAgICAgICAgIGxvYWRDYXRlZ29yaWVzKGN1cnJlbnRHdWlsZElkKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBBbHJlYWR5IHN1YnNjcmliZWQgdG8gJHtjaGFubmVsTmFtZX1gKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIENsZWFudXAgZm9yIGd1aWxkSWQ6ICR7Y3VycmVudEd1aWxkSWR9YCk7XG4gICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBSZW1vdmluZyBjaGFubmVsICR7Y2hhbm5lbC50b3BpY31gKTtcbiAgICAgICAgc3VwYWJhc2UucmVtb3ZlQ2hhbm5lbChjaGFubmVsKTtcbiAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsOyAvLyBFbnN1cmUgcmVmIGlzIGNsZWFyZWQgb24gY2xlYW51cFxuICAgICAgfVxuICAgIH07XG4gIH0sIFtjdXJyZW50R3VpbGQ/LmlkLCBsb2FkQ2F0ZWdvcmllcywgaGFuZGxlUmVhbHRpbWVFdmVudF0pOyAvLyBNYWluIGRlcGVuZGVuY2llc1xuXG4gIC8vIC0tLSBSZXN0bGljaGUgRnVua3Rpb25lbiAtLS1cbiAgY29uc3QgdG9nZ2xlQ2F0ZWdvcnlFeHBhbmQgPSB1c2VDYWxsYmFjaygoY2F0ZWdvcnlJZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0RXhwYW5kZWRDYXRlZ29yaWVzKHByZXYgPT5cbiAgICAgIHByZXYuaW5jbHVkZXMoY2F0ZWdvcnlJZClcbiAgICAgICAgPyBwcmV2LmZpbHRlcihpZCA9PiBpZCAhPT0gY2F0ZWdvcnlJZClcbiAgICAgICAgOiBbLi4ucHJldiwgY2F0ZWdvcnlJZF1cbiAgICApO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2F2ZUNhdGVnb3J5ID0gdXNlQ2FsbGJhY2soYXN5bmMgKGNhdGVnb3J5RGF0YTogQ2F0ZWdvcnlJbnB1dCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIC8vIExvZ2ljLi4uIChrYW5uIG1laXN0IGJsZWliZW4sIGRhIFJlYWx0aW1lIGRlbiBTdGF0ZSBha3R1YWxpc2llcnQpXG4gICAgaWYgKCFndWlsZElkKSB7IHRvYXN0LmVycm9yKCdLZWluZSBHdWlsZCBhdXNnZXfDpGhsdCcpOyByZXR1cm4gZmFsc2U7IH1cbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoY2F0ZWdvcnlEYXRhLmlkKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZURhdGE6IFVwZGF0ZUNhdGVnb3J5RHRvID0ge1xuICAgICAgICAgIG5hbWU6IGNhdGVnb3J5RGF0YS5uYW1lLCBpc1Zpc2libGVEZWZhdWx0OiBjYXRlZ29yeURhdGEuaXNWaXNpYmxlLFxuICAgICAgICAgIHNldHVwRmxvd0VuYWJsZWQ6IGNhdGVnb3J5RGF0YS5zZW5kU2V0dXAsIGRlZmF1bHRUcmFja2luZ0VuYWJsZWQ6IGNhdGVnb3J5RGF0YS50cmFja2luZ0FjdGl2ZSxcbiAgICAgICAgICBzZXR1cENoYW5uZWxOYW1lOiBjYXRlZ29yeURhdGEuc2V0dXBUZXh0Q2hhbm5lbCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgd2FydGVyYXVtQ2hhbm5lbE5hbWU6IGNhdGVnb3J5RGF0YS53YWl0aW5nUm9vbU5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIGRpc2NvcmRSb2xlSWRzOiBjYXRlZ29yeURhdGEuYWxsb3dlZFJvbGVzXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLnVwZGF0ZUNhdGVnb3J5KGNhdGVnb3J5RGF0YS5pZCwgdXBkYXRlRGF0YSk7XG4gICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ0thdGVnb3JpZSBha3R1YWxpc2llcnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZURhdGE6IENyZWF0ZUNhdGVnb3J5RHRvID0ge1xuICAgICAgICAgIHNjb3BlOiB7IGlkOiAnJywgc2NvcGVUeXBlOiBTY29wZVR5cGUuR1VJTEQsIHNjb3BlSWQ6IGd1aWxkSWQgfSxcbiAgICAgICAgICBuYW1lOiBjYXRlZ29yeURhdGEubmFtZSwgaXNWaXNpYmxlRGVmYXVsdDogY2F0ZWdvcnlEYXRhLmlzVmlzaWJsZSxcbiAgICAgICAgICBzZXR1cEZsb3dFbmFibGVkOiBjYXRlZ29yeURhdGEuc2VuZFNldHVwLCBkZWZhdWx0VHJhY2tpbmdFbmFibGVkOiBjYXRlZ29yeURhdGEudHJhY2tpbmdBY3RpdmUsXG4gICAgICAgICAgc2V0dXBDaGFubmVsTmFtZTogY2F0ZWdvcnlEYXRhLnNldHVwVGV4dENoYW5uZWwgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIHdhcnRlcmF1bUNoYW5uZWxOYW1lOiBjYXRlZ29yeURhdGEud2FpdGluZ1Jvb21OYW1lIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBkaXNjb3JkUm9sZUlkczogY2F0ZWdvcnlEYXRhLmFsbG93ZWRSb2xlc1xuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5jcmVhdGVDYXRlZ29yeShjcmVhdGVEYXRhKTtcbiAgICAgICAgdG9hc3Quc3VjY2VzcygnS2F0ZWdvcmllIGVyc3RlbGx0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkgeyAvKiBFcnJvciBoYW5kbGluZyAqLyByZXR1cm4gZmFsc2U7IH1cbiAgICBmaW5hbGx5IHsgc2V0TG9hZGluZyhmYWxzZSk7IH1cbiAgfSwgW2d1aWxkSWRdKTtcblxuICBjb25zdCBkZWxldGVDYXRlZ29yeSA9IHVzZUNhbGxiYWNrKGFzeW5jIChjYXRlZ29yeUlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZT86IHN0cmluZyB9PiA9PiB7XG4gICAgLy8gTG9naWMuLi4gKGthbm4gYmxlaWJlbilcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5kZWxldGVDYXRlZ29yeShjYXRlZ29yeUlkKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2VzcykgdG9hc3Quc3VjY2VzcygnS2F0ZWdvcmllIGdlbMO2c2NodC4nKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHsgLyogRXJyb3IgaGFuZGxpbmcgKi8gcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6ICdGZWhsZXInIH07IH1cbiAgICBmaW5hbGx5IHsgc2V0TG9hZGluZyhmYWxzZSk7IH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlZmV0Y2ggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzXSByZWZldGNoIHRyaWdnZXJlZCcpO1xuICAgIGlmIChjdXJyZW50R3VpbGQ/LmlkKSB7XG4gICAgICBsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgPSAnJzsgLy8gUmVzZXQgbG9hZGVkIHJlZiB0byBmb3JjZSByZWxvYWRcbiAgICAgIGluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgbG9hZENhdGVnb3JpZXMoY3VycmVudEd1aWxkLmlkKTtcbiAgICB9XG4gIH0sIFtjdXJyZW50R3VpbGQ/LmlkLCBsb2FkQ2F0ZWdvcmllc10pO1xuXG4gIGNvbnN0IGdldFRvdGFsU3RhdHMgPSB1c2VDYWxsYmFjaygoKSA9PiAoe1xuICAgIHRvdGFsQ2F0ZWdvcmllczogY2F0ZWdvcmllcy5sZW5ndGgsXG4gICAgdG90YWxVc2VyczogY2F0ZWdvcmllcy5yZWR1Y2UoKHN1bSwgYykgPT4gc3VtICsgYy50b3RhbFVzZXJzLCAwKSxcbiAgICB0b3RhbFRpbWU6IGNhdGVnb3JpZXMucmVkdWNlKChzdW0sIGMpID0+IHN1bSArIGMudG90YWxUaW1lU3BlbnQsIDApXG4gIH0pLCBbY2F0ZWdvcmllc10pO1xuXG4gIHJldHVybiB7XG4gICAgY2F0ZWdvcmllcywgbG9hZGluZywgZXJyb3IsIGV4cGFuZGVkQ2F0ZWdvcmllcywgc2VhcmNoUXVlcnksXG4gICAgc2V0U2VhcmNoUXVlcnksIHRvZ2dsZUNhdGVnb3J5RXhwYW5kLCBzYXZlQ2F0ZWdvcnksIGRlbGV0ZUNhdGVnb3J5LFxuICAgIGdldFRvdGFsU3RhdHMsIHJlZmV0Y2hcbiAgfTtcbn07Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ0b2FzdCIsInVzZUd1aWxkIiwiY2F0ZWdvcmllc1NlcnZpY2UiLCJ6b25lc1NlcnZpY2UiLCJTY29wZVR5cGUiLCJzdXBhYmFzZSIsInVzZUNhdGVnb3JpZXMiLCJjdXJyZW50R3VpbGQiLCJndWlsZElkIiwiaWQiLCJjb25zb2xlIiwibG9nIiwiY2F0ZWdvcmllcyIsInNldENhdGVnb3JpZXMiLCJleHBhbmRlZENhdGVnb3JpZXMiLCJzZXRFeHBhbmRlZENhdGVnb3JpZXMiLCJzZWFyY2hRdWVyeSIsInNldFNlYXJjaFF1ZXJ5IiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwicmVhbHRpbWVDaGFubmVsUmVmIiwibG9hZGVkR3VpbGRJZFJlZiIsImluaXRpYWxMb2FkQ29tcGxldGVSZWYiLCJsb2FkQ2F0ZWdvcmllcyIsImd1aWxkSWRUb0xvYWQiLCJjdXJyZW50IiwiY2F0ZWdvcmllc0RhdGEiLCJnZXRDYXRlZ29yaWVzIiwiR1VJTEQiLCJlbmhhbmNlZENhdGVnb3JpZXNQcm9taXNlcyIsIm1hcCIsImNhdGVnb3J5Iiwiem9uZXNEYXRhIiwiZ2V0Wm9uZXNCeUNhdGVnb3J5IiwiZW5oYW5jZWRab25lcyIsInpvbmUiLCJuYW1lIiwiem9uZUtleSIsIm1pbnV0ZXNSZXF1aXJlZCIsImludGVydmFsTWludXRlcyIsInBvaW50c0dyYW50ZWQiLCJwb2ludHNQZXJJbnRlcnZhbCIsImxhc3RBY3RpdmUiLCJ0b3RhbFRpbWVTcGVudCIsInRvdGFsVXNlcnMiLCJndWlsZF9pZCIsImFsbG93ZWRSb2xlcyIsImlzVmlzaWJsZSIsImlzVmlzaWJsZURlZmF1bHQiLCJzZW5kU2V0dXAiLCJzZXR1cEZsb3dFbmFibGVkIiwidHJhY2tpbmdBY3RpdmUiLCJkZWZhdWx0VHJhY2tpbmdFbmFibGVkIiwic2V0dXBUZXh0Q2hhbm5lbCIsInNldHVwQ2hhbm5lbElkIiwid2FpdGluZ1Jvb21OYW1lIiwid2FydGVyYXVtQ2hhbm5lbElkIiwiZGlzY29yZENhdGVnb3J5SWQiLCJkZWxldGVkSW5EaXNjb3JkIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInVwZGF0ZWRBdCIsInpvbmVzIiwiZW5oYW5jZWRDYXRlZ29yaWVzIiwiUHJvbWlzZSIsImFsbCIsImxlbmd0aCIsImVyciIsImhhbmRsZVJlYWx0aW1lRXZlbnQiLCJwYXlsb2FkIiwiZXZlbnRUeXBlIiwibmV3IiwibmV3UmVjb3JkIiwib2xkIiwib2xkUmVjb3JkIiwidGFibGUiLCJyZWNvcmQiLCJhZmZlY3RlZENhdGVnb3J5SWQiLCJjYXRlZ29yeV9pZCIsIm5ld0NhdGVnb3J5IiwiaXNfdmlzaWJsZV9kZWZhdWx0Iiwic2V0dXBfZmxvd19lbmFibGVkIiwiZGVmYXVsdF90cmFja2luZ19lbmFibGVkIiwic2V0dXBfY2hhbm5lbF9pZCIsIndhcnRlcmF1bV9jaGFubmVsX2lkIiwiZGlzY29yZF9jYXRlZ29yeV9pZCIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwicHJldiIsInRoZW4iLCJjIiwiZmlsdGVyIiwiY2F0ZWdvcnlEYXRhIiwiZ2V0Q2F0ZWdvcnlCeUlkIiwiY3VycmVudEd1aWxkSWQiLCJyZW1vdmVDaGFubmVsIiwiY2hhbm5lbCIsImNoYW5uZWxOYW1lIiwidG9waWMiLCJvbiIsImV2ZW50Iiwic2NoZW1hIiwic3Vic2NyaWJlIiwic3RhdHVzIiwidG9nZ2xlQ2F0ZWdvcnlFeHBhbmQiLCJjYXRlZ29yeUlkIiwiaW5jbHVkZXMiLCJzYXZlQ2F0ZWdvcnkiLCJ1cGRhdGVEYXRhIiwic2V0dXBDaGFubmVsTmFtZSIsInVuZGVmaW5lZCIsIndhcnRlcmF1bUNoYW5uZWxOYW1lIiwiZGlzY29yZFJvbGVJZHMiLCJ1cGRhdGVDYXRlZ29yeSIsInN1Y2Nlc3MiLCJjcmVhdGVEYXRhIiwic2NvcGUiLCJzY29wZVR5cGUiLCJzY29wZUlkIiwiY3JlYXRlQ2F0ZWdvcnkiLCJkZWxldGVDYXRlZ29yeSIsInJlc3VsdCIsIm1lc3NhZ2UiLCJyZWZldGNoIiwiZ2V0VG90YWxTdGF0cyIsInRvdGFsQ2F0ZWdvcmllcyIsInJlZHVjZSIsInN1bSIsInRvdGFsVGltZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts\n"));

/***/ })

});