/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/categories/page",{

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cinfo%5C%5CDocuments%5C%5CDiscord%20Bot%5C%5CChimera%5C%5Capps%5C%5Cfrontend%5C%5Csrc%5C%5Ccomponents%5C%5Cdashboard%5C%5Ccategory-management%5C%5Chooks%5C%5CuseCategories.ts%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cinfo%5C%5CDocuments%5C%5CDiscord%20Bot%5C%5CChimera%5C%5Capps%5C%5Cfrontend%5C%5Csrc%5C%5Ccomponents%5C%5Cdashboard%5C%5Ccategory-management%5C%5Chooks%5C%5CuseZones.ts%22%2C%22ids%22%3A%5B%22useZones%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cinfo%5C%5CDocuments%5C%5CDiscord%20Bot%5C%5CChimera%5C%5Cnode_modules%5C%5C.pnpm%5C%5C%40mui%2Bmaterial%406.3.1_%40emotio_e21801b4b04f18445829542588ce660c%5C%5Cnode_modules%5C%5C%40mui%5C%5Cmaterial%5C%5CBox%5C%5CBox.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cinfo%5C%5CDocuments%5C%5CDiscord%20Bot%5C%5CChimera%5C%5Capps%5C%5Cfrontend%5C%5Csrc%5C%5Ccomponents%5C%5Cdashboard%5C%5Ccategory-management%5C%5Chooks%5C%5CuseCategories.ts%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cinfo%5C%5CDocuments%5C%5CDiscord%20Bot%5C%5CChimera%5C%5Capps%5C%5Cfrontend%5C%5Csrc%5C%5Ccomponents%5C%5Cdashboard%5C%5Ccategory-management%5C%5Chooks%5C%5CuseZones.ts%22%2C%22ids%22%3A%5B%22useZones%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cinfo%5C%5CDocuments%5C%5CDiscord%20Bot%5C%5CChimera%5C%5Cnode_modules%5C%5C.pnpm%5C%5C%40mui%2Bmaterial%406.3.1_%40emotio_e21801b4b04f18445829542588ce660c%5C%5Cnode_modules%5C%5C%40mui%5C%5Cmaterial%5C%5CBox%5C%5CBox.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/dashboard/category-management/hooks/useCategories.ts */ \"(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/dashboard/category-management/hooks/useZones.ts */ \"(app-pages-browser)/./src/components/dashboard/category-management/hooks/useZones.ts\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ../../node_modules/.pnpm/@mui+material@6.3.1_@emotio_e21801b4b04f18445829542588ce660c/node_modules/@mui/material/Box/Box.js */ \"(app-pages-browser)/../../node_modules/.pnpm/@mui+material@6.3.1_@emotio_e21801b4b04f18445829542588ce660c/node_modules/@mui/material/Box/Box.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4zLjBfQGJhYmVsK2NvcmVANy4yX2JlOTNlMTFhY2JiZWRjMTMwYzZlYjNkMjE1YTBkNWU4L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDaW5mbyU1QyU1Q0RvY3VtZW50cyU1QyU1Q0Rpc2NvcmQlMjBCb3QlNUMlNUNDaGltZXJhJTVDJTVDYXBwcyU1QyU1Q2Zyb250ZW5kJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q2Rhc2hib2FyZCU1QyU1Q2NhdGVnb3J5LW1hbmFnZW1lbnQlNUMlNUNob29rcyU1QyU1Q3VzZUNhdGVnb3JpZXMudHMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDaW5mbyU1QyU1Q0RvY3VtZW50cyU1QyU1Q0Rpc2NvcmQlMjBCb3QlNUMlNUNDaGltZXJhJTVDJTVDYXBwcyU1QyU1Q2Zyb250ZW5kJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q2Rhc2hib2FyZCU1QyU1Q2NhdGVnb3J5LW1hbmFnZW1lbnQlNUMlNUNob29rcyU1QyU1Q3VzZVpvbmVzLnRzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIydXNlWm9uZXMlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDaW5mbyU1QyU1Q0RvY3VtZW50cyU1QyU1Q0Rpc2NvcmQlMjBCb3QlNUMlNUNDaGltZXJhJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDLnBucG0lNUMlNUMlNDBtdWklMkJtYXRlcmlhbCU0MDYuMy4xXyU0MGVtb3Rpb19lMjE4MDFiNGIwNGYxODQ0NTgyOTU0MjU4OGNlNjYwYyU1QyU1Q25vZGVfbW9kdWxlcyU1QyU1QyU0MG11aSU1QyU1Q21hdGVyaWFsJTVDJTVDQm94JTVDJTVDQm94LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyZGVmYXVsdCUyMiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLG9RQUErSztBQUMvSztBQUNBLDBQQUF3TTtBQUN4TTtBQUNBLGdYQUFnUCIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcaW5mb1xcXFxEb2N1bWVudHNcXFxcRGlzY29yZCBCb3RcXFxcQ2hpbWVyYVxcXFxhcHBzXFxcXGZyb250ZW5kXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXGRhc2hib2FyZFxcXFxjYXRlZ29yeS1tYW5hZ2VtZW50XFxcXGhvb2tzXFxcXHVzZUNhdGVnb3JpZXMudHNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcInVzZVpvbmVzXCJdICovIFwiQzpcXFxcVXNlcnNcXFxcaW5mb1xcXFxEb2N1bWVudHNcXFxcRGlzY29yZCBCb3RcXFxcQ2hpbWVyYVxcXFxhcHBzXFxcXGZyb250ZW5kXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXGRhc2hib2FyZFxcXFxjYXRlZ29yeS1tYW5hZ2VtZW50XFxcXGhvb2tzXFxcXHVzZVpvbmVzLnRzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiQzpcXFxcVXNlcnNcXFxcaW5mb1xcXFxEb2N1bWVudHNcXFxcRGlzY29yZCBCb3RcXFxcQ2hpbWVyYVxcXFxub2RlX21vZHVsZXNcXFxcLnBucG1cXFxcQG11aSttYXRlcmlhbEA2LjMuMV9AZW1vdGlvX2UyMTgwMWI0YjA0ZjE4NDQ1ODI5NTQyNTg4Y2U2NjBjXFxcXG5vZGVfbW9kdWxlc1xcXFxAbXVpXFxcXG1hdGVyaWFsXFxcXEJveFxcXFxCb3guanNcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cinfo%5C%5CDocuments%5C%5CDiscord%20Bot%5C%5CChimera%5C%5Capps%5C%5Cfrontend%5C%5Csrc%5C%5Ccomponents%5C%5Cdashboard%5C%5Ccategory-management%5C%5Chooks%5C%5CuseCategories.ts%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cinfo%5C%5CDocuments%5C%5CDiscord%20Bot%5C%5CChimera%5C%5Capps%5C%5Cfrontend%5C%5Csrc%5C%5Ccomponents%5C%5Cdashboard%5C%5Ccategory-management%5C%5Chooks%5C%5CuseZones.ts%22%2C%22ids%22%3A%5B%22useZones%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cinfo%5C%5CDocuments%5C%5CDiscord%20Bot%5C%5CChimera%5C%5Cnode_modules%5C%5C.pnpm%5C%5C%40mui%2Bmaterial%406.3.1_%40emotio_e21801b4b04f18445829542588ce660c%5C%5Cnode_modules%5C%5C%40mui%5C%5Cmaterial%5C%5CBox%5C%5CBox.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts":
/*!*****************************************************************************!*\
  !*** ./src/components/dashboard/category-management/hooks/useCategories.ts ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCategories: () => (/* binding */ useCategories)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/core/toaster */ \"(app-pages-browser)/./src/components/core/toaster.tsx\");\n/* harmony import */ var _context_guild_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/context/guild-context */ \"(app-pages-browser)/./src/context/guild-context.tsx\");\n/* harmony import */ var _services_categories__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/categories */ \"(app-pages-browser)/./src/services/categories.ts\");\n/* harmony import */ var _services_zones__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/zones */ \"(app-pages-browser)/./src/services/zones.ts\");\n/* harmony import */ var shared_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! shared-types */ \"(app-pages-browser)/../../packages/shared-types/src/index.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useCategories auto */ \n // Import hinzugefügt\n\n\n\n // ZoneDto hinzugefügt\n\n// Helper zum Mappen von DB-Zone zu EnhancedZone\nconst mapToEnhancedZone = (zone)=>({\n        id: zone.id,\n        name: zone.name,\n        zoneKey: zone.zoneKey,\n        minutesRequired: zone.intervalMinutes,\n        pointsGranted: zone.pointsPerInterval,\n        lastActive: '-',\n        totalTimeSpent: 0,\n        totalUsers: 0 // Placeholder\n    });\n// Helper zum Mappen von DB-Kategorie zu EnhancedCategory\nconst mapToEnhancedCategory = (category, guildId, zones)=>({\n        id: category.id,\n        name: category.name,\n        guild_id: guildId,\n        allowedRoles: category.allowedRoles || [],\n        isVisible: category.isVisibleDefault,\n        sendSetup: category.setupFlowEnabled,\n        trackingActive: category.defaultTrackingEnabled,\n        setupTextChannel: category.setupChannelId,\n        waitingRoomName: category.warteraumChannelId,\n        lastActive: '-',\n        totalTimeSpent: 0,\n        totalUsers: 0,\n        discordCategoryId: category.discordCategoryId || null,\n        deletedInDiscord: !category.discordCategoryId,\n        createdAt: new Date(category.createdAt),\n        updatedAt: new Date(category.updatedAt),\n        zones: zones\n    });\nconst useCategories = ()=>{\n    const { currentGuild } = (0,_context_guild_context__WEBPACK_IMPORTED_MODULE_2__.useGuild)();\n    const guildId = (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) || '';\n    console.log(\"[useCategories] Hook rendered. GuildId: \".concat(guildId));\n    const [categories, setCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [expandedCategories, setExpandedCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [searchQuery, setSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const realtimeChannelRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadedGuildIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)('');\n    const initialLoadCompleteRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // --- Memoized Ladefunktion ---\n    const loadCategories = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[loadCategories]\": async (guildIdToLoad)=>{\n            if (!guildIdToLoad) return;\n            if (loading && loadedGuildIdRef.current === guildIdToLoad) return; // Verhindere paralleles Laden für dieselbe Guild\n            console.log(\"[useCategories] loadCategories: Loading for Guild: \".concat(guildIdToLoad));\n            setLoading(true);\n            setError(null);\n            initialLoadCompleteRef.current = false;\n            try {\n                const categoriesData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategories(shared_types__WEBPACK_IMPORTED_MODULE_5__.ScopeType.GUILD, guildIdToLoad);\n                const enhancedCategoriesPromises = categoriesData.map({\n                    \"useCategories.useCallback[loadCategories].enhancedCategoriesPromises\": async (category)=>{\n                        const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(category.id);\n                        const enhancedZones = zonesData.map(mapToEnhancedZone); // Helper verwenden\n                        return mapToEnhancedCategory(category, guildIdToLoad, enhancedZones); // Helper verwenden\n                    }\n                }[\"useCategories.useCallback[loadCategories].enhancedCategoriesPromises\"]);\n                const enhancedCategories = await Promise.all(enhancedCategoriesPromises);\n                setCategories(enhancedCategories);\n                loadedGuildIdRef.current = guildIdToLoad;\n                initialLoadCompleteRef.current = true;\n                console.log(\"[useCategories] loadCategories: \".concat(enhancedCategories.length, \" categories loaded for \").concat(guildIdToLoad));\n            } catch (err) {\n                console.error(\"[useCategories] Error loading categories for \".concat(guildIdToLoad, \":\"), err);\n                setError('Fehler beim Laden der Kategorien');\n                setCategories([]);\n                loadedGuildIdRef.current = guildIdToLoad;\n                initialLoadCompleteRef.current = true;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[loadCategories]\"], [\n        loading\n    ]); // Abhängig von loading\n    // --- Memoized Realtime Handler ---\n    const handleRealtimeEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[handleRealtimeEvent]\": (payload)=>{\n            console.log('[useCategories RAW EVENT]', payload);\n            const { eventType, new: newRecord, old: oldRecord, table, schema } = payload;\n            if (schema !== 'public') return; // Nur auf public Schema reagieren\n            const record = newRecord || oldRecord;\n            if (!record) return;\n            const affectedCategoryId = table === 'categories' ? record.id : record.category_id;\n            if (!affectedCategoryId) return;\n            // Prüfen, ob das Event zur aktuellen Guild gehört (wichtig!)\n            // Wir brauchen einen Weg, die guildId aus dem Payload zu bekommen oder anzunehmen, dass der Filter greift.\n            // Annahme: Filter funktioniert serverseitig, wir reagieren auf alles, was durchkommt.\n            console.log(\"[HANDLER CALLED] Table: \".concat(table, \", Event: \").concat(eventType, \", Affected Category: \").concat(affectedCategoryId));\n            if (table === 'categories') {\n                if (eventType === 'INSERT' && newRecord) {\n                    console.log(\"[Realtime] Category INSERT: \".concat(newRecord.id));\n                    const newCategory = mapToEnhancedCategory(newRecord, guildId, []); // Initial leere Zonen\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>{\n                            if (!prev.some({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newCategory.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])) {\n                                console.log(\"[Realtime INSERT] Adding new category to state:\", newCategory.name);\n                                return [\n                                    ...prev,\n                                    newCategory\n                                ];\n                            }\n                            console.log(\"[Realtime INSERT] Category already exists, likely race condition, ignoring.\");\n                            return prev; // Verhindere Duplikate\n                        }\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                    // Lade Zonen im Hintergrund nach\n                    _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(newRecord.id).then({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (zonesData)=>{\n                            const enhancedZones = zonesData.map(mapToEnhancedZone);\n                            setCategories({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                        \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newRecord.id ? {\n                                                ...c,\n                                                zones: enhancedZones\n                                            } : c\n                                    }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        }\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]).catch({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (err)=>console.error(\"[Realtime] Failed to fetch zones for new category \".concat(newRecord.id), err)\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                } else if (eventType === 'UPDATE' && newRecord) {\n                    console.log(\"[Realtime] Category UPDATE: \".concat(newRecord.id));\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newRecord.id ? {\n                                        ...c,\n                                        name: newRecord.name,\n                                        isVisible: newRecord.is_visible_default,\n                                        sendSetup: newRecord.setup_flow_enabled,\n                                        trackingActive: newRecord.default_tracking_enabled,\n                                        setupTextChannel: newRecord.setup_channel_id,\n                                        waitingRoomName: newRecord.warteraum_channel_id,\n                                        discordCategoryId: newRecord.discord_category_id || null,\n                                        deletedInDiscord: !newRecord.discord_category_id,\n                                        updatedAt: new Date(newRecord.updated_at)\n                                    } : c\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                } else if (eventType === 'DELETE' && oldRecord) {\n                    console.log(\"[Realtime] Category DELETE: \".concat(oldRecord.id));\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.filter({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id !== oldRecord.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                }\n            } else if (table === 'zones') {\n                console.log(\"[Realtime] Zone \".concat(eventType, \" for Category \").concat(affectedCategoryId));\n                // Effizienter: Zone direkt im State aktualisieren\n                setCategories({\n                    \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>{\n                        const categoryIndex = prev.findIndex({\n                            \"useCategories.useCallback[handleRealtimeEvent].categoryIndex\": (c)=>c.id === affectedCategoryId\n                        }[\"useCategories.useCallback[handleRealtimeEvent].categoryIndex\"]);\n                        if (categoryIndex === -1) return prev; // Kategorie nicht im State\n                        const currentCategory = prev[categoryIndex];\n                        let updatedZones = [\n                            ...currentCategory.zones\n                        ]; // Kopie erstellen\n                        if (eventType === 'INSERT' && newRecord) {\n                            const newZone = mapToEnhancedZone(newRecord);\n                            if (!updatedZones.some({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (z)=>z.id === newZone.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])) {\n                                updatedZones.push(newZone);\n                            }\n                        } else if (eventType === 'UPDATE' && newRecord) {\n                            const updatedZone = mapToEnhancedZone(newRecord);\n                            updatedZones = updatedZones.map({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (z)=>z.id === updatedZone.id ? updatedZone : z\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        } else if (eventType === 'DELETE' && oldRecord) {\n                            updatedZones = updatedZones.filter({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (z)=>z.id !== oldRecord.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        }\n                        const newState = [\n                            ...prev\n                        ];\n                        newState[categoryIndex] = {\n                            ...currentCategory,\n                            zones: updatedZones\n                        };\n                        return newState;\n                    }\n                }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n            } else if (table === 'category_discord_role_permissions') {\n                console.log(\"[Realtime] Roles \".concat(eventType, \" for Category \").concat(affectedCategoryId));\n                ({\n                    \"useCategories.useCallback[handleRealtimeEvent]\": async ()=>{\n                        try {\n                            const categoryData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryById(affectedCategoryId);\n                            if (categoryData) {\n                                setCategories({\n                                    \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                            \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === affectedCategoryId ? {\n                                                    ...c,\n                                                    allowedRoles: categoryData.allowedRoles || []\n                                                } : c\n                                        }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                                }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                            }\n                        } catch (error) {\n                            console.error(\"[Realtime] Error refetching roles for category \".concat(affectedCategoryId, \":\"), error);\n                        }\n                    }\n                })[\"useCategories.useCallback[handleRealtimeEvent]\"]();\n            }\n        }\n    }[\"useCategories.useCallback[handleRealtimeEvent]\"], [\n        guildId,\n        setCategories\n    ]); // Abhängigkeiten korrekt setzen\n    // --- Haupt-useEffect für Laden und Subscription ---\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCategories.useEffect\": ()=>{\n            const currentGuildId = currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id;\n            console.log(\"[useCategories Effect] Running for guildId: \".concat(currentGuildId || 'none'));\n            if (!currentGuildId) {\n                console.log('[useCategories Effect] No guildId, resetting.');\n                setCategories([]);\n                loadedGuildIdRef.current = '';\n                initialLoadCompleteRef.current = false;\n                if (realtimeChannelRef.current) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(realtimeChannelRef.current);\n                    realtimeChannelRef.current = null;\n                }\n                return;\n            }\n            // Laden, wenn die Guild neu ist oder die Daten fehlen\n            if (loadedGuildIdRef.current !== currentGuildId) {\n                loadCategories(currentGuildId);\n            }\n            // Subscription Logik\n            let channel = realtimeChannelRef.current;\n            const channelName = \"categories:\".concat(currentGuildId);\n            if (!channel || channel.topic !== \"realtime:\".concat(channelName)) {\n                if (channel) _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(channel);\n                console.log(\"[useCategories Effect] Setting up channel: \".concat(channelName));\n                channel = _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.channel(channelName);\n                channel.on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'categories'\n                }, handleRealtimeEvent).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'zones'\n                }, handleRealtimeEvent).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'category_discord_role_permissions'\n                }, handleRealtimeEvent).subscribe({\n                    \"useCategories.useEffect\": (status, err)=>{\n                        console.log(\"[useCategories Effect] Sub status \".concat(channelName, \":\"), status, err || '');\n                        if (status === 'SUBSCRIBED') {\n                            realtimeChannelRef.current = channel;\n                            if (!initialLoadCompleteRef.current) {\n                                console.log('[useCategories Effect] Re-fetching data after successful subscription.');\n                                loadCategories(currentGuildId);\n                            }\n                        } else {\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }[\"useCategories.useEffect\"]);\n            } else {\n                console.log(\"[useCategories Effect] Already subscribed to \".concat(channelName));\n            }\n            // Cleanup\n            return(({\n                \"useCategories.useEffect\": ()=>{\n                    console.log(\"[useCategories Effect] Cleanup for guildId: \".concat(currentGuildId));\n                    // WICHTIG: Nur den Channel entfernen, wenn er noch aktuell ist!\n                    // Wenn der Effekt wegen Guild-Wechsel neu läuft, wurde der alte Channel evtl. schon entfernt.\n                    const currentChannel = realtimeChannelRef.current;\n                    if (currentChannel && currentChannel.topic === \"realtime:\".concat(channelName)) {\n                        console.log(\"[useCategories Effect] Removing channel \".concat(currentChannel.topic));\n                        _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(currentChannel);\n                        realtimeChannelRef.current = null;\n                    }\n                }\n            })[\"useCategories.useEffect\"]);\n        }\n    }[\"useCategories.useEffect\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories,\n        handleRealtimeEvent\n    ]);\n    // --- Restliche Funktionen (angepasst) ---\n    const toggleCategoryExpand = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[toggleCategoryExpand]\": (categoryId)=>{\n            setExpandedCategories({\n                \"useCategories.useCallback[toggleCategoryExpand]\": (prev)=>prev.includes(categoryId) ? prev.filter({\n                        \"useCategories.useCallback[toggleCategoryExpand]\": (id)=>id !== categoryId\n                    }[\"useCategories.useCallback[toggleCategoryExpand]\"]) : [\n                        ...prev,\n                        categoryId\n                    ]\n            }[\"useCategories.useCallback[toggleCategoryExpand]\"]);\n        }\n    }[\"useCategories.useCallback[toggleCategoryExpand]\"], []);\n    const saveCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[saveCategory]\": async (categoryData)=>{\n            if (!guildId) {\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error('Keine Guild ausgewählt');\n                return false;\n            }\n            setLoading(true);\n            try {\n                if (categoryData.id) {\n                    const updateData = {};\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.updateCategory(categoryData.id, updateData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie aktualisiert');\n                } else {\n                    const createData = {};\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.createCategory(createData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie erstellt');\n                }\n                // Realtime sollte State aktualisieren\n                return true;\n            } catch (err) {\n                return false;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[saveCategory]\"], [\n        guildId\n    ]); // Abhängigkeit von guildId\n    const deleteCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[deleteCategory]\": async (categoryId)=>{\n            setLoading(true);\n            try {\n                const result = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.deleteCategory(categoryId);\n                if (result.success) _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie gelöscht.');\n                // Realtime sollte State aktualisieren\n                return result;\n            } catch (err) {\n                return {\n                    success: false,\n                    message: 'Fehler'\n                };\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[deleteCategory]\"], []);\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[refetch]\": ()=>{\n            console.log('[useCategories] refetch triggered');\n            if (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) {\n                loadedGuildIdRef.current = '';\n                initialLoadCompleteRef.current = false;\n                loadCategories(currentGuild.id);\n            }\n        }\n    }[\"useCategories.useCallback[refetch]\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories\n    ]);\n    const getTotalStats = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[getTotalStats]\": ()=>({\n                totalCategories: categories.length,\n                totalUsers: categories.reduce({\n                    \"useCategories.useCallback[getTotalStats]\": (sum, c)=>sum + c.totalUsers\n                }[\"useCategories.useCallback[getTotalStats]\"], 0),\n                totalTime: categories.reduce({\n                    \"useCategories.useCallback[getTotalStats]\": (sum, c)=>sum + c.totalTimeSpent\n                }[\"useCategories.useCallback[getTotalStats]\"], 0)\n            })\n    }[\"useCategories.useCallback[getTotalStats]\"], [\n        categories\n    ]);\n    return {\n        categories,\n        loading,\n        error,\n        expandedCategories,\n        searchQuery,\n        setSearchQuery,\n        toggleCategoryExpand,\n        saveCategory,\n        deleteCategory,\n        getTotalStats,\n        refetch\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9jYXRlZ29yeS1tYW5hZ2VtZW50L2hvb2tzL3VzZUNhdGVnb3JpZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O21FQUVpRTtBQUNmLENBQUMscUJBQXFCO0FBQ3JCO0FBQ1E7QUFDVjtBQUNvRCxDQUFDLHNCQUFzQjtBQUVsRjtBQTZDMUMsZ0RBQWdEO0FBQ2hELE1BQU1VLG9CQUFvQixDQUFDQyxPQUFpQztRQUN4REMsSUFBSUQsS0FBS0MsRUFBRTtRQUNYQyxNQUFNRixLQUFLRSxJQUFJO1FBQ2ZDLFNBQVNILEtBQUtHLE9BQU87UUFDckJDLGlCQUFpQkosS0FBS0ssZUFBZTtRQUNyQ0MsZUFBZU4sS0FBS08saUJBQWlCO1FBQ3JDQyxZQUFZO1FBQUtDLGdCQUFnQjtRQUFHQyxZQUFZLEVBQUUsY0FBYztJQUNwRTtBQUVBLHlEQUF5RDtBQUN6RCxNQUFNQyx3QkFBd0IsQ0FBQ0MsVUFBdUJDLFNBQWlCQyxRQUE2QztRQUNoSGIsSUFBSVcsU0FBU1gsRUFBRTtRQUNmQyxNQUFNVSxTQUFTVixJQUFJO1FBQ25CYSxVQUFVRjtRQUNWRyxjQUFjSixTQUFTSSxZQUFZLElBQUksRUFBRTtRQUN6Q0MsV0FBV0wsU0FBU00sZ0JBQWdCO1FBQ3BDQyxXQUFXUCxTQUFTUSxnQkFBZ0I7UUFDcENDLGdCQUFnQlQsU0FBU1Usc0JBQXNCO1FBQy9DQyxrQkFBa0JYLFNBQVNZLGNBQWM7UUFDekNDLGlCQUFpQmIsU0FBU2Msa0JBQWtCO1FBQzVDbEIsWUFBWTtRQUFLQyxnQkFBZ0I7UUFBR0MsWUFBWTtRQUNoRGlCLG1CQUFtQmYsU0FBU2UsaUJBQWlCLElBQUk7UUFDakRDLGtCQUFrQixDQUFDaEIsU0FBU2UsaUJBQWlCO1FBQzdDRSxXQUFXLElBQUlDLEtBQUtsQixTQUFTaUIsU0FBUztRQUN0Q0UsV0FBVyxJQUFJRCxLQUFLbEIsU0FBU21CLFNBQVM7UUFDdENqQixPQUFPQTtJQUNY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LE9BQU9JO1lBQ1QsRUFBRSxPQUFPMUQsS0FBVTtnQkFBdUIsT0FBTztvQkFBRXNELFNBQVM7b0JBQU9LLFNBQVM7Z0JBQVM7WUFBRyxTQUNoRjtnQkFBRWhGLFdBQVc7WUFBUTtRQUNoQztvREFBRyxFQUFFO0lBRUwsTUFBTWlGLFVBQVVySSxrREFBV0E7OENBQUM7WUFDMUIyQyxRQUFRQyxHQUFHLENBQUM7WUFDWixJQUFJRix5QkFBQUEsbUNBQUFBLGFBQWNoQyxFQUFFLEVBQUU7Z0JBQ3BCOEMsaUJBQWlCSSxPQUFPLEdBQUc7Z0JBQzNCSCx1QkFBdUJHLE9BQU8sR0FBRztnQkFDakNGLGVBQWVoQixhQUFhaEMsRUFBRTtZQUNoQztRQUNGOzZDQUFHO1FBQUNnQyx5QkFBQUEsbUNBQUFBLGFBQWNoQyxFQUFFO1FBQUVnRDtLQUFlO0lBRXJDLE1BQU00RSxnQkFBZ0J0SSxrREFBV0E7b0RBQUMsSUFBTztnQkFDdkN1SSxpQkFBaUIxRixXQUFXMkIsTUFBTTtnQkFDbENyRCxZQUFZMEIsV0FBVzJGLE1BQU07Z0VBQUMsQ0FBQ0MsS0FBS2hELElBQU1nRCxNQUFNaEQsRUFBRXRFLFVBQVU7K0RBQUU7Z0JBQzlEdUgsV0FBVzdGLFdBQVcyRixNQUFNO2dFQUFDLENBQUNDLEtBQUtoRCxJQUFNZ0QsTUFBTWhELEVBQUV2RSxjQUFjOytEQUFFO1lBQ25FO21EQUFJO1FBQUMyQjtLQUFXO0lBRWhCLE9BQU87UUFDTEE7UUFBWU07UUFBU0U7UUFBT047UUFBb0JFO1FBQ2hEQztRQUFnQnVFO1FBQXNCRztRQUFjTTtRQUNwREk7UUFBZUQ7SUFDakI7QUFDRixFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGluZm9cXERvY3VtZW50c1xcRGlzY29yZCBCb3RcXENoaW1lcmFcXGFwcHNcXGZyb250ZW5kXFxzcmNcXGNvbXBvbmVudHNcXGRhc2hib2FyZFxcY2F0ZWdvcnktbWFuYWdlbWVudFxcaG9va3NcXHVzZUNhdGVnb3JpZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdG9hc3QgfSBmcm9tICdAL2NvbXBvbmVudHMvY29yZS90b2FzdGVyJzsgLy8gSW1wb3J0IGhpbnp1Z2Vmw7xndFxuaW1wb3J0IHsgdXNlR3VpbGQgfSBmcm9tICdAL2NvbnRleHQvZ3VpbGQtY29udGV4dCc7XG5pbXBvcnQgKiBhcyBjYXRlZ29yaWVzU2VydmljZSBmcm9tICdAL3NlcnZpY2VzL2NhdGVnb3JpZXMnO1xuaW1wb3J0ICogYXMgem9uZXNTZXJ2aWNlIGZyb20gJ0Avc2VydmljZXMvem9uZXMnO1xuaW1wb3J0IHsgQ3JlYXRlQ2F0ZWdvcnlEdG8sIFVwZGF0ZUNhdGVnb3J5RHRvLCBTY29wZVR5cGUsIENhdGVnb3J5RHRvLCBab25lRHRvIH0gZnJvbSAnc2hhcmVkLXR5cGVzJzsgLy8gWm9uZUR0byBoaW56dWdlZsO8Z3RcbmltcG9ydCB7IFJlYWx0aW1lQ2hhbm5lbCwgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkIH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuXG4vLyBJbnRlcmZhY2VzIGpldHp0IGV4cG9ydGllcmVuXG5leHBvcnQgaW50ZXJmYWNlIEVuaGFuY2VkQ2F0ZWdvcnkge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGd1aWxkX2lkOiBzdHJpbmc7XG4gIGFsbG93ZWRSb2xlczogc3RyaW5nW107XG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgc2VuZFNldHVwOiBib29sZWFuO1xuICB0cmFja2luZ0FjdGl2ZTogYm9vbGVhbjtcbiAgc2V0dXBUZXh0Q2hhbm5lbD86IHN0cmluZyB8IG51bGw7XG4gIHdhaXRpbmdSb29tTmFtZT86IHN0cmluZyB8IG51bGw7XG4gIGxhc3RBY3RpdmU6IHN0cmluZztcbiAgdG90YWxUaW1lU3BlbnQ6IG51bWJlcjtcbiAgdG90YWxVc2VyczogbnVtYmVyO1xuICBkaXNjb3JkQ2F0ZWdvcnlJZDogc3RyaW5nIHwgbnVsbDtcbiAgZGVsZXRlZEluRGlzY29yZDogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICB1cGRhdGVkQXQ6IERhdGU7XG4gIHpvbmVzOiBFbmhhbmNlZFpvbmVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbmhhbmNlZFpvbmUge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHpvbmVLZXk6IHN0cmluZztcbiAgbWludXRlc1JlcXVpcmVkOiBudW1iZXI7XG4gIHBvaW50c0dyYW50ZWQ6IG51bWJlcjtcbiAgbGFzdEFjdGl2ZTogc3RyaW5nO1xuICB0b3RhbFRpbWVTcGVudDogbnVtYmVyO1xuICB0b3RhbFVzZXJzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcnlJbnB1dCB7XG4gIGlkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFsbG93ZWRSb2xlczogc3RyaW5nW107XG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgc2VuZFNldHVwOiBib29sZWFuO1xuICB0cmFja2luZ0FjdGl2ZTogYm9vbGVhbjtcbiAgc2V0dXBUZXh0Q2hhbm5lbD86IHN0cmluZyB8IG51bGw7XG4gIHdhaXRpbmdSb29tTmFtZT86IHN0cmluZyB8IG51bGw7XG59XG5cbi8vIEhlbHBlciB6dW0gTWFwcGVuIHZvbiBEQi1ab25lIHp1IEVuaGFuY2VkWm9uZVxuY29uc3QgbWFwVG9FbmhhbmNlZFpvbmUgPSAoem9uZTogWm9uZUR0byk6IEVuaGFuY2VkWm9uZSA9PiAoe1xuICAgIGlkOiB6b25lLmlkLFxuICAgIG5hbWU6IHpvbmUubmFtZSxcbiAgICB6b25lS2V5OiB6b25lLnpvbmVLZXksXG4gICAgbWludXRlc1JlcXVpcmVkOiB6b25lLmludGVydmFsTWludXRlcyxcbiAgICBwb2ludHNHcmFudGVkOiB6b25lLnBvaW50c1BlckludGVydmFsLFxuICAgIGxhc3RBY3RpdmU6ICctJywgdG90YWxUaW1lU3BlbnQ6IDAsIHRvdGFsVXNlcnM6IDAgLy8gUGxhY2Vob2xkZXJcbn0pO1xuXG4vLyBIZWxwZXIgenVtIE1hcHBlbiB2b24gREItS2F0ZWdvcmllIHp1IEVuaGFuY2VkQ2F0ZWdvcnlcbmNvbnN0IG1hcFRvRW5oYW5jZWRDYXRlZ29yeSA9IChjYXRlZ29yeTogQ2F0ZWdvcnlEdG8sIGd1aWxkSWQ6IHN0cmluZywgem9uZXM6IEVuaGFuY2VkWm9uZVtdKTogRW5oYW5jZWRDYXRlZ29yeSA9PiAoe1xuICAgIGlkOiBjYXRlZ29yeS5pZCxcbiAgICBuYW1lOiBjYXRlZ29yeS5uYW1lLFxuICAgIGd1aWxkX2lkOiBndWlsZElkLFxuICAgIGFsbG93ZWRSb2xlczogY2F0ZWdvcnkuYWxsb3dlZFJvbGVzIHx8IFtdLFxuICAgIGlzVmlzaWJsZTogY2F0ZWdvcnkuaXNWaXNpYmxlRGVmYXVsdCxcbiAgICBzZW5kU2V0dXA6IGNhdGVnb3J5LnNldHVwRmxvd0VuYWJsZWQsXG4gICAgdHJhY2tpbmdBY3RpdmU6IGNhdGVnb3J5LmRlZmF1bHRUcmFja2luZ0VuYWJsZWQsXG4gICAgc2V0dXBUZXh0Q2hhbm5lbDogY2F0ZWdvcnkuc2V0dXBDaGFubmVsSWQsXG4gICAgd2FpdGluZ1Jvb21OYW1lOiBjYXRlZ29yeS53YXJ0ZXJhdW1DaGFubmVsSWQsXG4gICAgbGFzdEFjdGl2ZTogJy0nLCB0b3RhbFRpbWVTcGVudDogMCwgdG90YWxVc2VyczogMCwgLy8gUGxhY2Vob2xkZXJzXG4gICAgZGlzY29yZENhdGVnb3J5SWQ6IGNhdGVnb3J5LmRpc2NvcmRDYXRlZ29yeUlkIHx8IG51bGwsXG4gICAgZGVsZXRlZEluRGlzY29yZDogIWNhdGVnb3J5LmRpc2NvcmRDYXRlZ29yeUlkLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoY2F0ZWdvcnkuY3JlYXRlZEF0KSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKGNhdGVnb3J5LnVwZGF0ZWRBdCksXG4gICAgem9uZXM6IHpvbmVzXG59KTtcblxuXG5leHBvcnQgY29uc3QgdXNlQ2F0ZWdvcmllcyA9ICgpID0+IHtcbiAgY29uc3QgeyBjdXJyZW50R3VpbGQgfSA9IHVzZUd1aWxkKCk7XG4gIGNvbnN0IGd1aWxkSWQgPSBjdXJyZW50R3VpbGQ/LmlkIHx8ICcnO1xuICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXNdIEhvb2sgcmVuZGVyZWQuIEd1aWxkSWQ6ICR7Z3VpbGRJZH1gKTtcblxuICBjb25zdCBbY2F0ZWdvcmllcywgc2V0Q2F0ZWdvcmllc10gPSB1c2VTdGF0ZTxFbmhhbmNlZENhdGVnb3J5W10+KFtdKTtcbiAgY29uc3QgW2V4cGFuZGVkQ2F0ZWdvcmllcywgc2V0RXhwYW5kZWRDYXRlZ29yaWVzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gIGNvbnN0IFtzZWFyY2hRdWVyeSwgc2V0U2VhcmNoUXVlcnldID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlYWx0aW1lQ2hhbm5lbFJlZiA9IHVzZVJlZjxSZWFsdGltZUNoYW5uZWwgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbG9hZGVkR3VpbGRJZFJlZiA9IHVzZVJlZjxzdHJpbmc+KCcnKTtcbiAgY29uc3QgaW5pdGlhbExvYWRDb21wbGV0ZVJlZiA9IHVzZVJlZihmYWxzZSk7XG5cbiAgLy8gLS0tIE1lbW9pemVkIExhZGVmdW5rdGlvbiAtLS1cbiAgY29uc3QgbG9hZENhdGVnb3JpZXMgPSB1c2VDYWxsYmFjayhhc3luYyAoZ3VpbGRJZFRvTG9hZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFndWlsZElkVG9Mb2FkKSByZXR1cm47XG4gICAgaWYgKGxvYWRpbmcgJiYgbG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ID09PSBndWlsZElkVG9Mb2FkKSByZXR1cm47IC8vIFZlcmhpbmRlcmUgcGFyYWxsZWxlcyBMYWRlbiBmw7xyIGRpZXNlbGJlIEd1aWxkXG5cbiAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXNdIGxvYWRDYXRlZ29yaWVzOiBMb2FkaW5nIGZvciBHdWlsZDogJHtndWlsZElkVG9Mb2FkfWApO1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2F0ZWdvcmllc0RhdGEgPSBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5nZXRDYXRlZ29yaWVzKFNjb3BlVHlwZS5HVUlMRCwgZ3VpbGRJZFRvTG9hZCk7XG4gICAgICBjb25zdCBlbmhhbmNlZENhdGVnb3JpZXNQcm9taXNlcyA9IGNhdGVnb3JpZXNEYXRhLm1hcChhc3luYyAoY2F0ZWdvcnkpID0+IHtcbiAgICAgICAgY29uc3Qgem9uZXNEYXRhID0gYXdhaXQgem9uZXNTZXJ2aWNlLmdldFpvbmVzQnlDYXRlZ29yeShjYXRlZ29yeS5pZCk7XG4gICAgICAgIGNvbnN0IGVuaGFuY2VkWm9uZXMgPSB6b25lc0RhdGEubWFwKG1hcFRvRW5oYW5jZWRab25lKTsgLy8gSGVscGVyIHZlcndlbmRlblxuICAgICAgICByZXR1cm4gbWFwVG9FbmhhbmNlZENhdGVnb3J5KGNhdGVnb3J5LCBndWlsZElkVG9Mb2FkLCBlbmhhbmNlZFpvbmVzKTsgLy8gSGVscGVyIHZlcndlbmRlblxuICAgICAgfSk7XG4gICAgICBjb25zdCBlbmhhbmNlZENhdGVnb3JpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChlbmhhbmNlZENhdGVnb3JpZXNQcm9taXNlcyk7XG5cbiAgICAgIHNldENhdGVnb3JpZXMoZW5oYW5jZWRDYXRlZ29yaWVzKTtcbiAgICAgIGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCA9IGd1aWxkSWRUb0xvYWQ7XG4gICAgICBpbml0aWFsTG9hZENvbXBsZXRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzXSBsb2FkQ2F0ZWdvcmllczogJHtlbmhhbmNlZENhdGVnb3JpZXMubGVuZ3RofSBjYXRlZ29yaWVzIGxvYWRlZCBmb3IgJHtndWlsZElkVG9Mb2FkfWApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgW3VzZUNhdGVnb3JpZXNdIEVycm9yIGxvYWRpbmcgY2F0ZWdvcmllcyBmb3IgJHtndWlsZElkVG9Mb2FkfTpgLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoJ0ZlaGxlciBiZWltIExhZGVuIGRlciBLYXRlZ29yaWVuJyk7XG4gICAgICBzZXRDYXRlZ29yaWVzKFtdKTtcbiAgICAgIGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCA9IGd1aWxkSWRUb0xvYWQ7XG4gICAgICBpbml0aWFsTG9hZENvbXBsZXRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtsb2FkaW5nXSk7IC8vIEFiaMOkbmdpZyB2b24gbG9hZGluZ1xuXG4gIC8vIC0tLSBNZW1vaXplZCBSZWFsdGltZSBIYW5kbGVyIC0tLVxuICBjb25zdCBoYW5kbGVSZWFsdGltZUV2ZW50ID0gdXNlQ2FsbGJhY2soKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZDxhbnk+KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIFJBVyBFVkVOVF0nLCBwYXlsb2FkKTtcbiAgICBjb25zdCB7IGV2ZW50VHlwZSwgbmV3OiBuZXdSZWNvcmQsIG9sZDogb2xkUmVjb3JkLCB0YWJsZSwgc2NoZW1hIH0gPSBwYXlsb2FkO1xuXG4gICAgaWYgKHNjaGVtYSAhPT0gJ3B1YmxpYycpIHJldHVybjsgLy8gTnVyIGF1ZiBwdWJsaWMgU2NoZW1hIHJlYWdpZXJlblxuXG4gICAgY29uc3QgcmVjb3JkID0gbmV3UmVjb3JkIHx8IG9sZFJlY29yZDtcbiAgICBpZiAoIXJlY29yZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgYWZmZWN0ZWRDYXRlZ29yeUlkID0gdGFibGUgPT09ICdjYXRlZ29yaWVzJyA/IHJlY29yZC5pZCA6IChyZWNvcmQgYXMgYW55KS5jYXRlZ29yeV9pZDtcbiAgICBpZiAoIWFmZmVjdGVkQ2F0ZWdvcnlJZCkgcmV0dXJuO1xuXG4gICAgLy8gUHLDvGZlbiwgb2IgZGFzIEV2ZW50IHp1ciBha3R1ZWxsZW4gR3VpbGQgZ2Vow7ZydCAod2ljaHRpZyEpXG4gICAgLy8gV2lyIGJyYXVjaGVuIGVpbmVuIFdlZywgZGllIGd1aWxkSWQgYXVzIGRlbSBQYXlsb2FkIHp1IGJla29tbWVuIG9kZXIgYW56dW5laG1lbiwgZGFzcyBkZXIgRmlsdGVyIGdyZWlmdC5cbiAgICAvLyBBbm5haG1lOiBGaWx0ZXIgZnVua3Rpb25pZXJ0IHNlcnZlcnNlaXRpZywgd2lyIHJlYWdpZXJlbiBhdWYgYWxsZXMsIHdhcyBkdXJjaGtvbW10LlxuXG4gICAgY29uc29sZS5sb2coYFtIQU5ETEVSIENBTExFRF0gVGFibGU6ICR7dGFibGV9LCBFdmVudDogJHtldmVudFR5cGV9LCBBZmZlY3RlZCBDYXRlZ29yeTogJHthZmZlY3RlZENhdGVnb3J5SWR9YCk7XG5cbiAgICBpZiAodGFibGUgPT09ICdjYXRlZ29yaWVzJykge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ0lOU0VSVCcgJiYgbmV3UmVjb3JkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbUmVhbHRpbWVdIENhdGVnb3J5IElOU0VSVDogJHtuZXdSZWNvcmQuaWR9YCk7XG4gICAgICAgIGNvbnN0IG5ld0NhdGVnb3J5ID0gbWFwVG9FbmhhbmNlZENhdGVnb3J5KG5ld1JlY29yZCBhcyBDYXRlZ29yeUR0bywgZ3VpbGRJZCwgW10pOyAvLyBJbml0aWFsIGxlZXJlIFpvbmVuXG4gICAgICAgIHNldENhdGVnb3JpZXMocHJldiA9PiB7XG4gICAgICAgICAgICAgaWYgKCFwcmV2LnNvbWUoYyA9PiBjLmlkID09PSBuZXdDYXRlZ29yeS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1JlYWx0aW1lIElOU0VSVF0gQWRkaW5nIG5ldyBjYXRlZ29yeSB0byBzdGF0ZTpcIiwgbmV3Q2F0ZWdvcnkubmFtZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIG5ld0NhdGVnb3J5XTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmVhbHRpbWUgSU5TRVJUXSBDYXRlZ29yeSBhbHJlYWR5IGV4aXN0cywgbGlrZWx5IHJhY2UgY29uZGl0aW9uLCBpZ25vcmluZy5cIik7XG4gICAgICAgICAgICAgcmV0dXJuIHByZXY7IC8vIFZlcmhpbmRlcmUgRHVwbGlrYXRlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBMYWRlIFpvbmVuIGltIEhpbnRlcmdydW5kIG5hY2hcbiAgICAgICAgem9uZXNTZXJ2aWNlLmdldFpvbmVzQnlDYXRlZ29yeShuZXdSZWNvcmQuaWQpLnRoZW4oem9uZXNEYXRhID0+IHtcbiAgICAgICAgICAgICBjb25zdCBlbmhhbmNlZFpvbmVzID0gem9uZXNEYXRhLm1hcChtYXBUb0VuaGFuY2VkWm9uZSk7XG4gICAgICAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gbmV3UmVjb3JkLmlkID8gey4uLmMsIHpvbmVzOiBlbmhhbmNlZFpvbmVzfSA6IGMpKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYFtSZWFsdGltZV0gRmFpbGVkIHRvIGZldGNoIHpvbmVzIGZvciBuZXcgY2F0ZWdvcnkgJHtuZXdSZWNvcmQuaWR9YCwgZXJyKSk7XG5cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAnVVBEQVRFJyAmJiBuZXdSZWNvcmQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtSZWFsdGltZV0gQ2F0ZWdvcnkgVVBEQVRFOiAke25ld1JlY29yZC5pZH1gKTtcbiAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gbmV3UmVjb3JkLmlkID8ge1xuICAgICAgICAgIC4uLmMsIC8vIFdpY2h0aWc6IEJlaGFsdGUgYmVzdGVoZW5kZSBab25lbiB1bmQgUm9sbGVuIGJlaSFcbiAgICAgICAgICBuYW1lOiBuZXdSZWNvcmQubmFtZSxcbiAgICAgICAgICBpc1Zpc2libGU6IG5ld1JlY29yZC5pc192aXNpYmxlX2RlZmF1bHQsXG4gICAgICAgICAgc2VuZFNldHVwOiBuZXdSZWNvcmQuc2V0dXBfZmxvd19lbmFibGVkLFxuICAgICAgICAgIHRyYWNraW5nQWN0aXZlOiBuZXdSZWNvcmQuZGVmYXVsdF90cmFja2luZ19lbmFibGVkLFxuICAgICAgICAgIHNldHVwVGV4dENoYW5uZWw6IG5ld1JlY29yZC5zZXR1cF9jaGFubmVsX2lkLFxuICAgICAgICAgIHdhaXRpbmdSb29tTmFtZTogbmV3UmVjb3JkLndhcnRlcmF1bV9jaGFubmVsX2lkLFxuICAgICAgICAgIGRpc2NvcmRDYXRlZ29yeUlkOiBuZXdSZWNvcmQuZGlzY29yZF9jYXRlZ29yeV9pZCB8fCBudWxsLFxuICAgICAgICAgIGRlbGV0ZWRJbkRpc2NvcmQ6ICFuZXdSZWNvcmQuZGlzY29yZF9jYXRlZ29yeV9pZCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKG5ld1JlY29yZC51cGRhdGVkX2F0KVxuICAgICAgICB9IDogYykpO1xuICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdERUxFVEUnICYmIG9sZFJlY29yZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW1JlYWx0aW1lXSBDYXRlZ29yeSBERUxFVEU6ICR7b2xkUmVjb3JkLmlkfWApO1xuICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4gcHJldi5maWx0ZXIoYyA9PiBjLmlkICE9PSBvbGRSZWNvcmQuaWQpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAnem9uZXMnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbUmVhbHRpbWVdIFpvbmUgJHtldmVudFR5cGV9IGZvciBDYXRlZ29yeSAke2FmZmVjdGVkQ2F0ZWdvcnlJZH1gKTtcbiAgICAgICAgLy8gRWZmaXppZW50ZXI6IFpvbmUgZGlyZWt0IGltIFN0YXRlIGFrdHVhbGlzaWVyZW5cbiAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5SW5kZXggPSBwcmV2LmZpbmRJbmRleChjID0+IGMuaWQgPT09IGFmZmVjdGVkQ2F0ZWdvcnlJZCk7XG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnlJbmRleCA9PT0gLTEpIHJldHVybiBwcmV2OyAvLyBLYXRlZ29yaWUgbmljaHQgaW0gU3RhdGVcblxuICAgICAgICAgICAgY29uc3QgY3VycmVudENhdGVnb3J5ID0gcHJldltjYXRlZ29yeUluZGV4XTtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkWm9uZXMgPSBbLi4uY3VycmVudENhdGVnb3J5LnpvbmVzXTsgLy8gS29waWUgZXJzdGVsbGVuXG5cbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09ICdJTlNFUlQnICYmIG5ld1JlY29yZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1pvbmUgPSBtYXBUb0VuaGFuY2VkWm9uZShuZXdSZWNvcmQgYXMgWm9uZUR0byk7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkWm9uZXMuc29tZSh6ID0+IHouaWQgPT09IG5ld1pvbmUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRab25lcy5wdXNoKG5ld1pvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAnVVBEQVRFJyAmJiBuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkWm9uZSA9IG1hcFRvRW5oYW5jZWRab25lKG5ld1JlY29yZCBhcyBab25lRHRvKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkWm9uZXMgPSB1cGRhdGVkWm9uZXMubWFwKHogPT4gei5pZCA9PT0gdXBkYXRlZFpvbmUuaWQgPyB1cGRhdGVkWm9uZSA6IHopO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdERUxFVEUnICYmIG9sZFJlY29yZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRab25lcyA9IHVwZGF0ZWRab25lcy5maWx0ZXIoeiA9PiB6LmlkICE9PSBvbGRSZWNvcmQuaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IFsuLi5wcmV2XTtcbiAgICAgICAgICAgIG5ld1N0YXRlW2NhdGVnb3J5SW5kZXhdID0geyAuLi5jdXJyZW50Q2F0ZWdvcnksIHpvbmVzOiB1cGRhdGVkWm9uZXMgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAnY2F0ZWdvcnlfZGlzY29yZF9yb2xlX3Blcm1pc3Npb25zJykge1xuICAgICAgICBjb25zb2xlLmxvZyhgW1JlYWx0aW1lXSBSb2xlcyAke2V2ZW50VHlwZX0gZm9yIENhdGVnb3J5ICR7YWZmZWN0ZWRDYXRlZ29yeUlkfWApO1xuICAgICAgICAgLy8gTGFkZSBudXIgZGllIGJldHJvZmZlbmUgS2F0ZWdvcmllIG5ldSwgdW0gZGllIFJvbGxlbiB6dSBha3R1YWxpc2llcmVuXG4gICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yeURhdGEgPSBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5nZXRDYXRlZ29yeUJ5SWQoYWZmZWN0ZWRDYXRlZ29yeUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnlEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBhZmZlY3RlZENhdGVnb3J5SWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyAuLi5jLCBhbGxvd2VkUm9sZXM6IGNhdGVnb3J5RGF0YS5hbGxvd2VkUm9sZXMgfHwgW10gfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjXG4gICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbUmVhbHRpbWVdIEVycm9yIHJlZmV0Y2hpbmcgcm9sZXMgZm9yIGNhdGVnb3J5ICR7YWZmZWN0ZWRDYXRlZ29yeUlkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9KSgpO1xuICAgIH1cbiAgfSwgW2d1aWxkSWQsIHNldENhdGVnb3JpZXNdKTsgLy8gQWJow6RuZ2lna2VpdGVuIGtvcnJla3Qgc2V0emVuXG5cbiAgLy8gLS0tIEhhdXB0LXVzZUVmZmVjdCBmw7xyIExhZGVuIHVuZCBTdWJzY3JpcHRpb24gLS0tXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudEd1aWxkSWQgPSBjdXJyZW50R3VpbGQ/LmlkO1xuICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIFJ1bm5pbmcgZm9yIGd1aWxkSWQ6ICR7Y3VycmVudEd1aWxkSWQgfHwgJ25vbmUnfWApO1xuXG4gICAgaWYgKCFjdXJyZW50R3VpbGRJZCkge1xuICAgICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIEVmZmVjdF0gTm8gZ3VpbGRJZCwgcmVzZXR0aW5nLicpO1xuICAgICAgc2V0Q2F0ZWdvcmllcyhbXSk7XG4gICAgICBsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgIGluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgaWYgKHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwocmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQpO1xuICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTGFkZW4sIHdlbm4gZGllIEd1aWxkIG5ldSBpc3Qgb2RlciBkaWUgRGF0ZW4gZmVobGVuXG4gICAgaWYgKGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCAhPT0gY3VycmVudEd1aWxkSWQpIHtcbiAgICAgIGxvYWRDYXRlZ29yaWVzKGN1cnJlbnRHdWlsZElkKTtcbiAgICB9XG5cbiAgICAvLyBTdWJzY3JpcHRpb24gTG9naWtcbiAgICBsZXQgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsIHwgbnVsbCA9IHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYGNhdGVnb3JpZXM6JHtjdXJyZW50R3VpbGRJZH1gO1xuXG4gICAgaWYgKCFjaGFubmVsIHx8IGNoYW5uZWwudG9waWMgIT09IGByZWFsdGltZToke2NoYW5uZWxOYW1lfWApIHtcbiAgICAgIGlmIChjaGFubmVsKSBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpO1xuXG4gICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBTZXR0aW5nIHVwIGNoYW5uZWw6ICR7Y2hhbm5lbE5hbWV9YCk7XG4gICAgICBjaGFubmVsID0gc3VwYWJhc2UuY2hhbm5lbChjaGFubmVsTmFtZSk7XG4gICAgICBjaGFubmVsXG4gICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjYXRlZ29yaWVzJyB9LCBoYW5kbGVSZWFsdGltZUV2ZW50KVxuICAgICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnem9uZXMnIH0sIGhhbmRsZVJlYWx0aW1lRXZlbnQpXG4gICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjYXRlZ29yeV9kaXNjb3JkX3JvbGVfcGVybWlzc2lvbnMnIH0sIGhhbmRsZVJlYWx0aW1lRXZlbnQpXG4gICAgICAgIC5zdWJzY3JpYmUoKHN0YXR1cywgZXJyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIEVmZmVjdF0gU3ViIHN0YXR1cyAke2NoYW5uZWxOYW1lfTpgLCBzdGF0dXMsIGVyciB8fCAnJyk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ1NVQlNDUklCRUQnKSB7XG4gICAgICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IGNoYW5uZWw7XG4gICAgICAgICAgICBpZiAoIWluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBSZS1mZXRjaGluZyBkYXRhIGFmdGVyIHN1Y2Nlc3NmdWwgc3Vic2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgICBsb2FkQ2F0ZWdvcmllcyhjdXJyZW50R3VpbGRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBBbHJlYWR5IHN1YnNjcmliZWQgdG8gJHtjaGFubmVsTmFtZX1gKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIENsZWFudXAgZm9yIGd1aWxkSWQ6ICR7Y3VycmVudEd1aWxkSWR9YCk7XG4gICAgICAvLyBXSUNIVElHOiBOdXIgZGVuIENoYW5uZWwgZW50ZmVybmVuLCB3ZW5uIGVyIG5vY2ggYWt0dWVsbCBpc3QhXG4gICAgICAvLyBXZW5uIGRlciBFZmZla3Qgd2VnZW4gR3VpbGQtV2VjaHNlbCBuZXUgbMOkdWZ0LCB3dXJkZSBkZXIgYWx0ZSBDaGFubmVsIGV2dGwuIHNjaG9uIGVudGZlcm50LlxuICAgICAgY29uc3QgY3VycmVudENoYW5uZWwgPSByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudDtcbiAgICAgIGlmIChjdXJyZW50Q2hhbm5lbCAmJiBjdXJyZW50Q2hhbm5lbC50b3BpYyA9PT0gYHJlYWx0aW1lOiR7Y2hhbm5lbE5hbWV9YCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBSZW1vdmluZyBjaGFubmVsICR7Y3VycmVudENoYW5uZWwudG9waWN9YCk7XG4gICAgICAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwoY3VycmVudENoYW5uZWwpO1xuICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRHdWlsZD8uaWQsIGxvYWRDYXRlZ29yaWVzLCBoYW5kbGVSZWFsdGltZUV2ZW50XSk7XG5cbiAgLy8gLS0tIFJlc3RsaWNoZSBGdW5rdGlvbmVuIChhbmdlcGFzc3QpIC0tLVxuICBjb25zdCB0b2dnbGVDYXRlZ29yeUV4cGFuZCA9IHVzZUNhbGxiYWNrKChjYXRlZ29yeUlkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRFeHBhbmRlZENhdGVnb3JpZXMocHJldiA9PlxuICAgICAgcHJldi5pbmNsdWRlcyhjYXRlZ29yeUlkKVxuICAgICAgICA/IHByZXYuZmlsdGVyKGlkID0+IGlkICE9PSBjYXRlZ29yeUlkKVxuICAgICAgICA6IFsuLi5wcmV2LCBjYXRlZ29yeUlkXVxuICAgICk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzYXZlQ2F0ZWdvcnkgPSB1c2VDYWxsYmFjayhhc3luYyAoY2F0ZWdvcnlEYXRhOiBDYXRlZ29yeUlucHV0KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgIGlmICghZ3VpbGRJZCkgeyB0b2FzdC5lcnJvcignS2VpbmUgR3VpbGQgYXVzZ2V3w6RobHQnKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgIHRyeSB7XG4gICAgICAgaWYgKGNhdGVnb3J5RGF0YS5pZCkge1xuICAgICAgICAgY29uc3QgdXBkYXRlRGF0YTogVXBkYXRlQ2F0ZWdvcnlEdG8gPSB7IC8qIC4uLiBEYXRlbiAuLi4gKi8gfTtcbiAgICAgICAgIGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLnVwZGF0ZUNhdGVnb3J5KGNhdGVnb3J5RGF0YS5pZCwgdXBkYXRlRGF0YSk7XG4gICAgICAgICB0b2FzdC5zdWNjZXNzKCdLYXRlZ29yaWUgYWt0dWFsaXNpZXJ0Jyk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGNvbnN0IGNyZWF0ZURhdGE6IENyZWF0ZUNhdGVnb3J5RHRvID0geyAvKiAuLi4gRGF0ZW4gLi4uICovIH07XG4gICAgICAgICBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5jcmVhdGVDYXRlZ29yeShjcmVhdGVEYXRhKTtcbiAgICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ0thdGVnb3JpZSBlcnN0ZWxsdCcpO1xuICAgICAgIH1cbiAgICAgICAvLyBSZWFsdGltZSBzb2xsdGUgU3RhdGUgYWt0dWFsaXNpZXJlblxuICAgICAgIHJldHVybiB0cnVlO1xuICAgICB9IGNhdGNoIChlcnI6IGFueSkgeyAvKiBFcnJvciBIYW5kbGluZyAqLyByZXR1cm4gZmFsc2U7IH1cbiAgICAgZmluYWxseSB7IHNldExvYWRpbmcoZmFsc2UpOyB9XG4gICB9LCBbZ3VpbGRJZF0pOyAvLyBBYmjDpG5naWdrZWl0IHZvbiBndWlsZElkXG5cbiAgY29uc3QgZGVsZXRlQ2F0ZWdvcnkgPSB1c2VDYWxsYmFjayhhc3luYyAoY2F0ZWdvcnlJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfT4gPT4ge1xuICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICB0cnkge1xuICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLmRlbGV0ZUNhdGVnb3J5KGNhdGVnb3J5SWQpO1xuICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcykgdG9hc3Quc3VjY2VzcygnS2F0ZWdvcmllIGdlbMO2c2NodC4nKTtcbiAgICAgICAvLyBSZWFsdGltZSBzb2xsdGUgU3RhdGUgYWt0dWFsaXNpZXJlblxuICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgIH0gY2F0Y2ggKGVycjogYW55KSB7IC8qIEVycm9yIEhhbmRsaW5nICovIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiAnRmVobGVyJyB9OyB9XG4gICAgIGZpbmFsbHkgeyBzZXRMb2FkaW5nKGZhbHNlKTsgfVxuICB9LCBbXSk7XG5cbiAgY29uc3QgcmVmZXRjaCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXNdIHJlZmV0Y2ggdHJpZ2dlcmVkJyk7XG4gICAgaWYgKGN1cnJlbnRHdWlsZD8uaWQpIHtcbiAgICAgIGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCA9ICcnO1xuICAgICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBsb2FkQ2F0ZWdvcmllcyhjdXJyZW50R3VpbGQuaWQpO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRHdWlsZD8uaWQsIGxvYWRDYXRlZ29yaWVzXSk7XG5cbiAgY29uc3QgZ2V0VG90YWxTdGF0cyA9IHVzZUNhbGxiYWNrKCgpID0+ICh7XG4gICAgdG90YWxDYXRlZ29yaWVzOiBjYXRlZ29yaWVzLmxlbmd0aCxcbiAgICB0b3RhbFVzZXJzOiBjYXRlZ29yaWVzLnJlZHVjZSgoc3VtLCBjKSA9PiBzdW0gKyBjLnRvdGFsVXNlcnMsIDApLFxuICAgIHRvdGFsVGltZTogY2F0ZWdvcmllcy5yZWR1Y2UoKHN1bSwgYykgPT4gc3VtICsgYy50b3RhbFRpbWVTcGVudCwgMClcbiAgfSksIFtjYXRlZ29yaWVzXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjYXRlZ29yaWVzLCBsb2FkaW5nLCBlcnJvciwgZXhwYW5kZWRDYXRlZ29yaWVzLCBzZWFyY2hRdWVyeSxcbiAgICBzZXRTZWFyY2hRdWVyeSwgdG9nZ2xlQ2F0ZWdvcnlFeHBhbmQsIHNhdmVDYXRlZ29yeSwgZGVsZXRlQ2F0ZWdvcnksXG4gICAgZ2V0VG90YWxTdGF0cywgcmVmZXRjaFxuICB9O1xufTsiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsInRvYXN0IiwidXNlR3VpbGQiLCJjYXRlZ29yaWVzU2VydmljZSIsInpvbmVzU2VydmljZSIsIlNjb3BlVHlwZSIsInN1cGFiYXNlIiwibWFwVG9FbmhhbmNlZFpvbmUiLCJ6b25lIiwiaWQiLCJuYW1lIiwiem9uZUtleSIsIm1pbnV0ZXNSZXF1aXJlZCIsImludGVydmFsTWludXRlcyIsInBvaW50c0dyYW50ZWQiLCJwb2ludHNQZXJJbnRlcnZhbCIsImxhc3RBY3RpdmUiLCJ0b3RhbFRpbWVTcGVudCIsInRvdGFsVXNlcnMiLCJtYXBUb0VuaGFuY2VkQ2F0ZWdvcnkiLCJjYXRlZ29yeSIsImd1aWxkSWQiLCJ6b25lcyIsImd1aWxkX2lkIiwiYWxsb3dlZFJvbGVzIiwiaXNWaXNpYmxlIiwiaXNWaXNpYmxlRGVmYXVsdCIsInNlbmRTZXR1cCIsInNldHVwRmxvd0VuYWJsZWQiLCJ0cmFja2luZ0FjdGl2ZSIsImRlZmF1bHRUcmFja2luZ0VuYWJsZWQiLCJzZXR1cFRleHRDaGFubmVsIiwic2V0dXBDaGFubmVsSWQiLCJ3YWl0aW5nUm9vbU5hbWUiLCJ3YXJ0ZXJhdW1DaGFubmVsSWQiLCJkaXNjb3JkQ2F0ZWdvcnlJZCIsImRlbGV0ZWRJbkRpc2NvcmQiLCJjcmVhdGVkQXQiLCJEYXRlIiwidXBkYXRlZEF0IiwidXNlQ2F0ZWdvcmllcyIsImN1cnJlbnRHdWlsZCIsImNvbnNvbGUiLCJsb2ciLCJjYXRlZ29yaWVzIiwic2V0Q2F0ZWdvcmllcyIsImV4cGFuZGVkQ2F0ZWdvcmllcyIsInNldEV4cGFuZGVkQ2F0ZWdvcmllcyIsInNlYXJjaFF1ZXJ5Iiwic2V0U2VhcmNoUXVlcnkiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJyZWFsdGltZUNoYW5uZWxSZWYiLCJsb2FkZWRHdWlsZElkUmVmIiwiaW5pdGlhbExvYWRDb21wbGV0ZVJlZiIsImxvYWRDYXRlZ29yaWVzIiwiZ3VpbGRJZFRvTG9hZCIsImN1cnJlbnQiLCJjYXRlZ29yaWVzRGF0YSIsImdldENhdGVnb3JpZXMiLCJHVUlMRCIsImVuaGFuY2VkQ2F0ZWdvcmllc1Byb21pc2VzIiwibWFwIiwiem9uZXNEYXRhIiwiZ2V0Wm9uZXNCeUNhdGVnb3J5IiwiZW5oYW5jZWRab25lcyIsImVuaGFuY2VkQ2F0ZWdvcmllcyIsIlByb21pc2UiLCJhbGwiLCJsZW5ndGgiLCJlcnIiLCJoYW5kbGVSZWFsdGltZUV2ZW50IiwicGF5bG9hZCIsImV2ZW50VHlwZSIsIm5ldyIsIm5ld1JlY29yZCIsIm9sZCIsIm9sZFJlY29yZCIsInRhYmxlIiwic2NoZW1hIiwicmVjb3JkIiwiYWZmZWN0ZWRDYXRlZ29yeUlkIiwiY2F0ZWdvcnlfaWQiLCJuZXdDYXRlZ29yeSIsInByZXYiLCJzb21lIiwiYyIsInRoZW4iLCJjYXRjaCIsImlzX3Zpc2libGVfZGVmYXVsdCIsInNldHVwX2Zsb3dfZW5hYmxlZCIsImRlZmF1bHRfdHJhY2tpbmdfZW5hYmxlZCIsInNldHVwX2NoYW5uZWxfaWQiLCJ3YXJ0ZXJhdW1fY2hhbm5lbF9pZCIsImRpc2NvcmRfY2F0ZWdvcnlfaWQiLCJ1cGRhdGVkX2F0IiwiZmlsdGVyIiwiY2F0ZWdvcnlJbmRleCIsImZpbmRJbmRleCIsImN1cnJlbnRDYXRlZ29yeSIsInVwZGF0ZWRab25lcyIsIm5ld1pvbmUiLCJ6IiwicHVzaCIsInVwZGF0ZWRab25lIiwibmV3U3RhdGUiLCJjYXRlZ29yeURhdGEiLCJnZXRDYXRlZ29yeUJ5SWQiLCJjdXJyZW50R3VpbGRJZCIsInJlbW92ZUNoYW5uZWwiLCJjaGFubmVsIiwiY2hhbm5lbE5hbWUiLCJ0b3BpYyIsIm9uIiwiZXZlbnQiLCJzdWJzY3JpYmUiLCJzdGF0dXMiLCJjdXJyZW50Q2hhbm5lbCIsInRvZ2dsZUNhdGVnb3J5RXhwYW5kIiwiY2F0ZWdvcnlJZCIsImluY2x1ZGVzIiwic2F2ZUNhdGVnb3J5IiwidXBkYXRlRGF0YSIsInVwZGF0ZUNhdGVnb3J5Iiwic3VjY2VzcyIsImNyZWF0ZURhdGEiLCJjcmVhdGVDYXRlZ29yeSIsImRlbGV0ZUNhdGVnb3J5IiwicmVzdWx0IiwibWVzc2FnZSIsInJlZmV0Y2giLCJnZXRUb3RhbFN0YXRzIiwidG90YWxDYXRlZ29yaWVzIiwicmVkdWNlIiwic3VtIiwidG90YWxUaW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/dashboard/category-management/hooks/useZones.ts":
/*!************************************************************************!*\
  !*** ./src/components/dashboard/category-management/hooks/useZones.ts ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useZones: () => (/* binding */ useZones)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/core/toaster */ \"(app-pages-browser)/./src/components/core/toaster.tsx\");\n/* harmony import */ var _services_zones__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/services/zones */ \"(app-pages-browser)/./src/services/zones.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useZones auto */ \n // Import hinzugefügt\n\n\n// Helper zum Mappen von DB-Zone zu EnhancedZone\nconst mapToEnhancedZone = (zone)=>{\n    var _zone_interval_minutes, _zone_points_per_interval;\n    return {\n        id: zone.id,\n        name: zone.name,\n        zoneKey: zone.zone_key || zone.zoneKey,\n        minutesRequired: (_zone_interval_minutes = zone.interval_minutes) !== null && _zone_interval_minutes !== void 0 ? _zone_interval_minutes : zone.intervalMinutes,\n        pointsGranted: (_zone_points_per_interval = zone.points_per_interval) !== null && _zone_points_per_interval !== void 0 ? _zone_points_per_interval : zone.pointsPerInterval,\n        lastActive: '-',\n        totalTimeSpent: 0,\n        totalUsers: 0 // Placeholder\n    };\n};\nconst useZones = (categoryId)=>{\n    const [zones, setZones] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const realtimeChannelRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadedCategoryIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)('');\n    const initialLoadCompleteRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // --- Memoized Ladefunktion ---\n    const loadZones = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[loadZones]\": async (categoryIdToLoad)=>{\n            if (!categoryIdToLoad) {\n                console.log('[useZones] loadZones: No category ID.');\n                setZones([]);\n                loadedCategoryIdRef.current = '';\n                initialLoadCompleteRef.current = false;\n                return;\n            }\n            if (loading && loadedCategoryIdRef.current === categoryIdToLoad) {\n                console.log(\"[useZones] loadZones: Already loading for \".concat(categoryIdToLoad, \". Skipping.\"));\n                return;\n            }\n            console.log(\"[useZones] loadZones: Loading zones for category: \".concat(categoryIdToLoad));\n            setLoading(true);\n            setError(null);\n            initialLoadCompleteRef.current = false;\n            try {\n                const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_2__.getZonesByCategory(categoryIdToLoad);\n                const enhancedZones = zonesData.map(mapToEnhancedZone);\n                setZones(enhancedZones);\n                loadedCategoryIdRef.current = categoryIdToLoad;\n                initialLoadCompleteRef.current = true;\n                console.log(\"[useZones] loadZones: \".concat(enhancedZones.length, \" zones loaded for \").concat(categoryIdToLoad));\n            } catch (err) {\n                console.error(\"[useZones] Error loading zones for \".concat(categoryIdToLoad, \":\"), err);\n                setError('Fehler beim Laden der Zonen');\n                setZones([]);\n                loadedCategoryIdRef.current = categoryIdToLoad;\n                initialLoadCompleteRef.current = true;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useZones.useCallback[loadZones]\"], [\n        loading\n    ]);\n    // --- Memoized Realtime Handler ---\n    const handleZoneChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[handleZoneChange]\": (payload)=>{\n            console.log('[useZones RAW EVENT zones]', payload); // Raw Event Logging\n            console.log('[HANDLER CALLED] handleZoneChange', payload);\n            const { eventType, new: newRecord, old: oldRecord, table, schema } = payload;\n            if (schema !== 'public' || table !== 'zones') return;\n            // RLS sollte serverseitig filtern, aber zur Sicherheit hier nochmal prüfen\n            const record = newRecord || oldRecord;\n            if (!record || record.category_id !== categoryId) {\n                console.log('[useZones Realtime] Event ignored, wrong category ID or no record.');\n                return;\n            }\n            const zoneId = record.id;\n            if (!zoneId) return;\n            switch(eventType){\n                case 'INSERT':\n                    if (newRecord) {\n                        console.log(\"[Realtime] Zone INSERT: \".concat(newRecord.id));\n                        const enhancedZone = mapToEnhancedZone(newRecord);\n                        setZones({\n                            \"useZones.useCallback[handleZoneChange]\": (prev)=>{\n                                if (!prev.some({\n                                    \"useZones.useCallback[handleZoneChange]\": (z)=>z.id === enhancedZone.id\n                                }[\"useZones.useCallback[handleZoneChange]\"])) {\n                                    return [\n                                        ...prev,\n                                        enhancedZone\n                                    ];\n                                }\n                                return prev;\n                            }\n                        }[\"useZones.useCallback[handleZoneChange]\"]);\n                    }\n                    break;\n                case 'UPDATE':\n                    if (newRecord) {\n                        console.log(\"[Realtime] Zone UPDATE: \".concat(newRecord.id));\n                        const updatedZone = mapToEnhancedZone(newRecord);\n                        setZones({\n                            \"useZones.useCallback[handleZoneChange]\": (prev)=>prev.map({\n                                    \"useZones.useCallback[handleZoneChange]\": (z)=>z.id === updatedZone.id ? updatedZone : z\n                                }[\"useZones.useCallback[handleZoneChange]\"])\n                        }[\"useZones.useCallback[handleZoneChange]\"]);\n                    }\n                    break;\n                case 'DELETE':\n                    if (oldRecord) {\n                        console.log(\"[Realtime] Zone DELETE: \".concat(oldRecord.id));\n                        setZones({\n                            \"useZones.useCallback[handleZoneChange]\": (prev)=>prev.filter({\n                                    \"useZones.useCallback[handleZoneChange]\": (z)=>z.id !== oldRecord.id\n                                }[\"useZones.useCallback[handleZoneChange]\"])\n                        }[\"useZones.useCallback[handleZoneChange]\"]);\n                    }\n                    break;\n                default:\n                    console.log(\"[useZones Realtime] Unhandled event type: \".concat(eventType));\n            }\n        }\n    }[\"useZones.useCallback[handleZoneChange]\"], [\n        categoryId,\n        setZones\n    ]); // Abhängig von categoryId und setZones\n    // --- Haupt-useEffect ---\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useZones.useEffect\": ()=>{\n            console.log(\"[useZones Effect] Running for categoryId: \".concat(categoryId || 'none'));\n            if (!categoryId) {\n                console.log('[useZones Effect] No categoryId, resetting.');\n                setZones([]);\n                loadedCategoryIdRef.current = '';\n                initialLoadCompleteRef.current = false;\n                if (realtimeChannelRef.current) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.removeChannel(realtimeChannelRef.current);\n                    realtimeChannelRef.current = null;\n                }\n                return;\n            }\n            if (loadedCategoryIdRef.current !== categoryId) {\n                loadZones(categoryId);\n            }\n            // Subscription Logic\n            let channel = realtimeChannelRef.current;\n            const channelName = \"zones:\".concat(categoryId);\n            if (!channel || channel.topic !== \"realtime:\".concat(channelName)) {\n                if (channel) _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.removeChannel(channel);\n                console.log(\"[useZones Effect] Setting up channel: \".concat(channelName));\n                channel = _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.channel(channelName);\n                channel.on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'zones',\n                    filter: \"category_id=eq.\".concat(categoryId)\n                }, handleZoneChange) // Übergibt den memoized Handler\n                .subscribe({\n                    \"useZones.useEffect\": (status, err)=>{\n                        console.log(\"[useZones Effect] Sub status \".concat(channelName, \":\"), status, err || '');\n                        if (status === 'SUBSCRIBED') {\n                            realtimeChannelRef.current = channel;\n                            if (!initialLoadCompleteRef.current) {\n                                loadZones(categoryId);\n                            }\n                        } else {\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }[\"useZones.useEffect\"]);\n            }\n            // Cleanup\n            return ({\n                \"useZones.useEffect\": ()=>{\n                    console.log(\"[useZones Effect] Cleanup for categoryId: \".concat(categoryId));\n                    const currentChannel = realtimeChannelRef.current; // Capture ref in closure\n                    if (currentChannel && currentChannel.topic === \"realtime:\".concat(channelName)) {\n                        console.log(\"[useZones Effect] Removing channel \".concat(currentChannel.topic));\n                        _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.removeChannel(currentChannel);\n                        realtimeChannelRef.current = null;\n                    }\n                }\n            })[\"useZones.useEffect\"];\n        }\n    }[\"useZones.useEffect\"], [\n        categoryId,\n        loadZones,\n        handleZoneChange\n    ]); // Korrekte Abhängigkeiten\n    // --- Restliche Funktionen ---\n    const saveZone = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[saveZone]\": async (zoneData)=>{\n            if (!categoryId) {\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error('Keine Kategorie ID');\n                return false;\n            }\n            setLoading(true);\n            try {\n                const dtoData = {\n                    name: zoneData.name,\n                    zoneKey: zoneData.zoneKey,\n                    pointsPerInterval: zoneData.pointsGranted,\n                    intervalMinutes: zoneData.minutesRequired\n                };\n                if (zoneData.id) {\n                    await _services_zones__WEBPACK_IMPORTED_MODULE_2__.updateZone(zoneData.id, dtoData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Zone aktualisiert.');\n                } else {\n                    await _services_zones__WEBPACK_IMPORTED_MODULE_2__.createZone(categoryId, dtoData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Zone erstellt.');\n                }\n                return true;\n            } catch (err) {\n                var _err_response_data, _err_response;\n                console.error('Fehler beim Speichern der Zone:', err);\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error(((_err_response = err.response) === null || _err_response === void 0 ? void 0 : (_err_response_data = _err_response.data) === null || _err_response_data === void 0 ? void 0 : _err_response_data.message) || 'Fehler beim Speichern der Zone');\n                return false;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useZones.useCallback[saveZone]\"], [\n        categoryId\n    ]);\n    const deleteZone = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[deleteZone]\": async (zoneId)=>{\n            setLoading(true);\n            try {\n                const result = await _services_zones__WEBPACK_IMPORTED_MODULE_2__.deleteZone(zoneId);\n                if (result.success) _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Zone gelöscht.');\n                else _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error(result.message || 'Fehler beim Löschen');\n                return result;\n            } catch (err) {\n                var _err_response_data, _err_response;\n                console.error('Fehler beim Löschen der Zone:', err);\n                const message = ((_err_response = err.response) === null || _err_response === void 0 ? void 0 : (_err_response_data = _err_response.data) === null || _err_response_data === void 0 ? void 0 : _err_response_data.message) || 'Fehler beim Löschen der Zone';\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error(message);\n                return {\n                    success: false,\n                    message\n                };\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useZones.useCallback[deleteZone]\"], []);\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[refetch]\": ()=>{\n            console.log('[useZones] refetch triggered');\n            if (categoryId) {\n                loadedCategoryIdRef.current = '';\n                initialLoadCompleteRef.current = false;\n                loadZones(categoryId);\n            }\n        }\n    }[\"useZones.useCallback[refetch]\"], [\n        categoryId,\n        loadZones\n    ]);\n    return {\n        zones,\n        loading,\n        error,\n        saveZone,\n        deleteZone,\n        refetch\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9jYXRlZ29yeS1tYW5hZ2VtZW50L2hvb2tzL3VzZVpvbmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs4REFFaUU7QUFDZixDQUFDLHFCQUFxQjtBQUV2QjtBQUdQO0FBWTFDLGdEQUFnRDtBQUNoRCxNQUFNTyxvQkFBb0IsQ0FBQ0M7UUFJTkEsd0JBQ0ZBO1dBTCtDO1FBQzlEQyxJQUFJRCxLQUFLQyxFQUFFO1FBQ1hDLE1BQU1GLEtBQUtFLElBQUk7UUFDZkMsU0FBU0gsS0FBS0ksUUFBUSxJQUFJSixLQUFLRyxPQUFPO1FBQ3RDRSxpQkFBaUJMLENBQUFBLHlCQUFBQSxLQUFLTSxnQkFBZ0IsY0FBckJOLG9DQUFBQSx5QkFBeUJBLEtBQUtPLGVBQWU7UUFDOURDLGVBQWVSLENBQUFBLDRCQUFBQSxLQUFLUyxtQkFBbUIsY0FBeEJULHVDQUFBQSw0QkFBNEJBLEtBQUtVLGlCQUFpQjtRQUNqRUMsWUFBWTtRQUFLQyxnQkFBZ0I7UUFBR0MsWUFBWSxFQUFFLGNBQWM7SUFDcEU7O0FBR08sTUFBTUMsV0FBVyxDQUFDQztJQUN2QixNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR3pCLCtDQUFRQSxDQUFpQixFQUFFO0lBQ3JELE1BQU0sQ0FBQzBCLFNBQVNDLFdBQVcsR0FBRzNCLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQzRCLE9BQU9DLFNBQVMsR0FBRzdCLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNOEIscUJBQXFCM0IsNkNBQU1BLENBQXlCO0lBQzFELE1BQU00QixzQkFBc0I1Qiw2Q0FBTUEsQ0FBUztJQUMzQyxNQUFNNkIseUJBQXlCN0IsNkNBQU1BLENBQUM7SUFFdEMsZ0NBQWdDO0lBQ2hDLE1BQU04QixZQUFZL0Isa0RBQVdBOzJDQUFDLE9BQU9nQztZQUNuQyxJQUFJLENBQUNBLGtCQUFrQjtnQkFDckJDLFFBQVFDLEdBQUcsQ0FBQztnQkFDWlgsU0FBUyxFQUFF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dUQsVUFBVWhGLGtEQUFXQTt5Q0FBQztZQUMxQmlDLFFBQVFDLEdBQUcsQ0FBQztZQUNaLElBQUliLFlBQVk7Z0JBQ2RRLG9CQUFvQk0sT0FBTyxHQUFHO2dCQUM5QkwsdUJBQXVCSyxPQUFPLEdBQUc7Z0JBQ2pDSixVQUFVVjtZQUNaO1FBQ0Y7d0NBQUc7UUFBQ0E7UUFBWVU7S0FBVTtJQUUxQixPQUFPO1FBQUVUO1FBQU9FO1FBQVNFO1FBQU8yQztRQUFVUztRQUFZRTtJQUFRO0FBQ2hFLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaW5mb1xcRG9jdW1lbnRzXFxEaXNjb3JkIEJvdFxcQ2hpbWVyYVxcYXBwc1xcZnJvbnRlbmRcXHNyY1xcY29tcG9uZW50c1xcZGFzaGJvYXJkXFxjYXRlZ29yeS1tYW5hZ2VtZW50XFxob29rc1xcdXNlWm9uZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdG9hc3QgfSBmcm9tICdAL2NvbXBvbmVudHMvY29yZS90b2FzdGVyJzsgLy8gSW1wb3J0IGhpbnp1Z2Vmw7xndFxuaW1wb3J0IHsgRW5oYW5jZWRab25lIH0gZnJvbSAnLi91c2VDYXRlZ29yaWVzJzsgLy8gVHlwIGltcG9ydGllcmVuXG5pbXBvcnQgKiBhcyB6b25lc1NlcnZpY2UgZnJvbSAnQC9zZXJ2aWNlcy96b25lcyc7XG5pbXBvcnQgeyBDcmVhdGVab25lRHRvLCBVcGRhdGVab25lRHRvLCBab25lRHRvIH0gZnJvbSAnc2hhcmVkLXR5cGVzJztcbmltcG9ydCB7IFJlYWx0aW1lQ2hhbm5lbCwgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkIH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuXG4vLyBJbnRlcmZhY2UgWm9uZUlucHV0IGJsZWlidCBnbGVpY2guLi5cbmV4cG9ydCBpbnRlcmZhY2UgWm9uZUlucHV0IHtcbiAgaWQ/OiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgem9uZUtleTogc3RyaW5nO1xuICBtaW51dGVzUmVxdWlyZWQ6IG51bWJlcjtcbiAgcG9pbnRzR3JhbnRlZDogbnVtYmVyO1xufVxuXG5cbi8vIEhlbHBlciB6dW0gTWFwcGVuIHZvbiBEQi1ab25lIHp1IEVuaGFuY2VkWm9uZVxuY29uc3QgbWFwVG9FbmhhbmNlZFpvbmUgPSAoem9uZTogWm9uZUR0byB8IGFueSk6IEVuaGFuY2VkWm9uZSA9PiAoeyAvLyBBa3plcHRpZXJ0IGF1Y2ggYW55IHZvbSBQYXlsb2FkXG4gICAgaWQ6IHpvbmUuaWQsXG4gICAgbmFtZTogem9uZS5uYW1lLFxuICAgIHpvbmVLZXk6IHpvbmUuem9uZV9rZXkgfHwgem9uZS56b25lS2V5LCAvLyBCZWFjaHRlIHVudGVyc2NoaWVkbGljaGUgU2NocmVpYndlaXNlblxuICAgIG1pbnV0ZXNSZXF1aXJlZDogem9uZS5pbnRlcnZhbF9taW51dGVzID8/IHpvbmUuaW50ZXJ2YWxNaW51dGVzLCAvLyBCZWFjaHRlIHVudGVyc2NoaWVkbGljaGUgU2NocmVpYndlaXNlblxuICAgIHBvaW50c0dyYW50ZWQ6IHpvbmUucG9pbnRzX3Blcl9pbnRlcnZhbCA/PyB6b25lLnBvaW50c1BlckludGVydmFsLCAvLyBCZWFjaHRlIHVudGVyc2NoaWVkbGljaGUgU2NocmVpYndlaXNlblxuICAgIGxhc3RBY3RpdmU6ICctJywgdG90YWxUaW1lU3BlbnQ6IDAsIHRvdGFsVXNlcnM6IDAgLy8gUGxhY2Vob2xkZXJcbn0pO1xuXG5cbmV4cG9ydCBjb25zdCB1c2Vab25lcyA9IChjYXRlZ29yeUlkPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IFt6b25lcywgc2V0Wm9uZXNdID0gdXNlU3RhdGU8RW5oYW5jZWRab25lW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCByZWFsdGltZUNoYW5uZWxSZWYgPSB1c2VSZWY8UmVhbHRpbWVDaGFubmVsIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGxvYWRlZENhdGVnb3J5SWRSZWYgPSB1c2VSZWY8c3RyaW5nPignJyk7XG4gIGNvbnN0IGluaXRpYWxMb2FkQ29tcGxldGVSZWYgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIC8vIC0tLSBNZW1vaXplZCBMYWRlZnVua3Rpb24gLS0tXG4gIGNvbnN0IGxvYWRab25lcyA9IHVzZUNhbGxiYWNrKGFzeW5jIChjYXRlZ29yeUlkVG9Mb2FkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWNhdGVnb3J5SWRUb0xvYWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbdXNlWm9uZXNdIGxvYWRab25lczogTm8gY2F0ZWdvcnkgSUQuJyk7XG4gICAgICBzZXRab25lcyhbXSk7XG4gICAgICBsb2FkZWRDYXRlZ29yeUlkUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgIGluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobG9hZGluZyAmJiBsb2FkZWRDYXRlZ29yeUlkUmVmLmN1cnJlbnQgPT09IGNhdGVnb3J5SWRUb0xvYWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2Vab25lc10gbG9hZFpvbmVzOiBBbHJlYWR5IGxvYWRpbmcgZm9yICR7Y2F0ZWdvcnlJZFRvTG9hZH0uIFNraXBwaW5nLmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGBbdXNlWm9uZXNdIGxvYWRab25lczogTG9hZGluZyB6b25lcyBmb3IgY2F0ZWdvcnk6ICR7Y2F0ZWdvcnlJZFRvTG9hZH1gKTtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIGluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHpvbmVzRGF0YSA9IGF3YWl0IHpvbmVzU2VydmljZS5nZXRab25lc0J5Q2F0ZWdvcnkoY2F0ZWdvcnlJZFRvTG9hZCk7XG4gICAgICBjb25zdCBlbmhhbmNlZFpvbmVzOiBFbmhhbmNlZFpvbmVbXSA9IHpvbmVzRGF0YS5tYXAobWFwVG9FbmhhbmNlZFpvbmUpO1xuICAgICAgc2V0Wm9uZXMoZW5oYW5jZWRab25lcyk7XG4gICAgICBsb2FkZWRDYXRlZ29yeUlkUmVmLmN1cnJlbnQgPSBjYXRlZ29yeUlkVG9Mb2FkO1xuICAgICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlWm9uZXNdIGxvYWRab25lczogJHtlbmhhbmNlZFpvbmVzLmxlbmd0aH0gem9uZXMgbG9hZGVkIGZvciAke2NhdGVnb3J5SWRUb0xvYWR9YCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbdXNlWm9uZXNdIEVycm9yIGxvYWRpbmcgem9uZXMgZm9yICR7Y2F0ZWdvcnlJZFRvTG9hZH06YCwgZXJyKTtcbiAgICAgIHNldEVycm9yKCdGZWhsZXIgYmVpbSBMYWRlbiBkZXIgWm9uZW4nKTtcbiAgICAgIHNldFpvbmVzKFtdKTtcbiAgICAgIGxvYWRlZENhdGVnb3J5SWRSZWYuY3VycmVudCA9IGNhdGVnb3J5SWRUb0xvYWQ7XG4gICAgICBpbml0aWFsTG9hZENvbXBsZXRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtsb2FkaW5nXSk7XG5cbiAgLy8gLS0tIE1lbW9pemVkIFJlYWx0aW1lIEhhbmRsZXIgLS0tXG4gIGNvbnN0IGhhbmRsZVpvbmVDaGFuZ2UgPSB1c2VDYWxsYmFjaygocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPGFueT4pID0+IHtcbiAgICBjb25zb2xlLmxvZygnW3VzZVpvbmVzIFJBVyBFVkVOVCB6b25lc10nLCBwYXlsb2FkKTsgLy8gUmF3IEV2ZW50IExvZ2dpbmdcbiAgICBjb25zb2xlLmxvZygnW0hBTkRMRVIgQ0FMTEVEXSBoYW5kbGVab25lQ2hhbmdlJywgcGF5bG9hZCk7XG4gICAgY29uc3QgeyBldmVudFR5cGUsIG5ldzogbmV3UmVjb3JkLCBvbGQ6IG9sZFJlY29yZCwgdGFibGUsIHNjaGVtYSB9ID0gcGF5bG9hZDtcblxuICAgIGlmIChzY2hlbWEgIT09ICdwdWJsaWMnIHx8IHRhYmxlICE9PSAnem9uZXMnKSByZXR1cm47XG4gICAgLy8gUkxTIHNvbGx0ZSBzZXJ2ZXJzZWl0aWcgZmlsdGVybiwgYWJlciB6dXIgU2ljaGVyaGVpdCBoaWVyIG5vY2htYWwgcHLDvGZlblxuICAgIGNvbnN0IHJlY29yZCA9IG5ld1JlY29yZCB8fCBvbGRSZWNvcmQ7XG4gICAgaWYgKCFyZWNvcmQgfHwgKHJlY29yZCBhcyBhbnkpLmNhdGVnb3J5X2lkICE9PSBjYXRlZ29yeUlkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbdXNlWm9uZXMgUmVhbHRpbWVdIEV2ZW50IGlnbm9yZWQsIHdyb25nIGNhdGVnb3J5IElEIG9yIG5vIHJlY29yZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHpvbmVJZCA9IHJlY29yZC5pZDtcbiAgICBpZiAoIXpvbmVJZCkgcmV0dXJuO1xuXG4gICAgc3dpdGNoIChldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgJ0lOU0VSVCc6XG4gICAgICAgIGlmIChuZXdSZWNvcmQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1JlYWx0aW1lXSBab25lIElOU0VSVDogJHtuZXdSZWNvcmQuaWR9YCk7XG4gICAgICAgICAgY29uc3QgZW5oYW5jZWRab25lID0gbWFwVG9FbmhhbmNlZFpvbmUobmV3UmVjb3JkKTtcbiAgICAgICAgICBzZXRab25lcyhwcmV2ID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFwcmV2LnNvbWUoeiA9PiB6LmlkID09PSBlbmhhbmNlZFpvbmUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIGVuaGFuY2VkWm9uZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdVUERBVEUnOlxuICAgICAgICBpZiAobmV3UmVjb3JkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtSZWFsdGltZV0gWm9uZSBVUERBVEU6ICR7bmV3UmVjb3JkLmlkfWApO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRab25lID0gbWFwVG9FbmhhbmNlZFpvbmUobmV3UmVjb3JkKTtcbiAgICAgICAgICBzZXRab25lcyhwcmV2ID0+IHByZXYubWFwKHogPT4gei5pZCA9PT0gdXBkYXRlZFpvbmUuaWQgPyB1cGRhdGVkWm9uZSA6IHopKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0RFTEVURSc6XG4gICAgICAgIGlmIChvbGRSZWNvcmQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1JlYWx0aW1lXSBab25lIERFTEVURTogJHtvbGRSZWNvcmQuaWR9YCk7XG4gICAgICAgICAgc2V0Wm9uZXMocHJldiA9PiBwcmV2LmZpbHRlcih6ID0+IHouaWQgIT09IG9sZFJlY29yZC5pZCkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2Vab25lcyBSZWFsdGltZV0gVW5oYW5kbGVkIGV2ZW50IHR5cGU6ICR7ZXZlbnRUeXBlfWApO1xuICAgIH1cbiAgfSwgW2NhdGVnb3J5SWQsIHNldFpvbmVzXSk7IC8vIEFiaMOkbmdpZyB2b24gY2F0ZWdvcnlJZCB1bmQgc2V0Wm9uZXNcblxuICAvLyAtLS0gSGF1cHQtdXNlRWZmZWN0IC0tLVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBbdXNlWm9uZXMgRWZmZWN0XSBSdW5uaW5nIGZvciBjYXRlZ29yeUlkOiAke2NhdGVnb3J5SWQgfHwgJ25vbmUnfWApO1xuXG4gICAgaWYgKCFjYXRlZ29yeUlkKSB7XG4gICAgICBjb25zb2xlLmxvZygnW3VzZVpvbmVzIEVmZmVjdF0gTm8gY2F0ZWdvcnlJZCwgcmVzZXR0aW5nLicpO1xuICAgICAgc2V0Wm9uZXMoW10pO1xuICAgICAgbG9hZGVkQ2F0ZWdvcnlJZFJlZi5jdXJyZW50ID0gJyc7XG4gICAgICBpbml0aWFsTG9hZENvbXBsZXRlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChyZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCkge1xuICAgICAgICBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50KTtcbiAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsb2FkZWRDYXRlZ29yeUlkUmVmLmN1cnJlbnQgIT09IGNhdGVnb3J5SWQpIHtcbiAgICAgIGxvYWRab25lcyhjYXRlZ29yeUlkKTtcbiAgICB9XG5cbiAgICAvLyBTdWJzY3JpcHRpb24gTG9naWNcbiAgICBsZXQgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsIHwgbnVsbCA9IHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYHpvbmVzOiR7Y2F0ZWdvcnlJZH1gO1xuXG4gICAgaWYgKCFjaGFubmVsIHx8IGNoYW5uZWwudG9waWMgIT09IGByZWFsdGltZToke2NoYW5uZWxOYW1lfWApIHtcbiAgICAgIGlmIChjaGFubmVsKSBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpO1xuXG4gICAgICBjb25zb2xlLmxvZyhgW3VzZVpvbmVzIEVmZmVjdF0gU2V0dGluZyB1cCBjaGFubmVsOiAke2NoYW5uZWxOYW1lfWApO1xuICAgICAgY2hhbm5lbCA9IHN1cGFiYXNlLmNoYW5uZWwoY2hhbm5lbE5hbWUpO1xuICAgICAgY2hhbm5lbFxuICAgICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7XG4gICAgICAgICAgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICd6b25lcycsXG4gICAgICAgICAgZmlsdGVyOiBgY2F0ZWdvcnlfaWQ9ZXEuJHtjYXRlZ29yeUlkfWBcbiAgICAgICAgfSwgaGFuZGxlWm9uZUNoYW5nZSkgLy8gw5xiZXJnaWJ0IGRlbiBtZW1vaXplZCBIYW5kbGVyXG4gICAgICAgIC5zdWJzY3JpYmUoKHN0YXR1cywgZXJyKSA9PiB7XG4gICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlWm9uZXMgRWZmZWN0XSBTdWIgc3RhdHVzICR7Y2hhbm5lbE5hbWV9OmAsIHN0YXR1cywgZXJyIHx8ICcnKTtcbiAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ1NVQlNDUklCRUQnKSB7XG4gICAgICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gY2hhbm5lbDtcbiAgICAgICAgICAgICAgaWYgKCFpbml0aWFsTG9hZENvbXBsZXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgIGxvYWRab25lcyhjYXRlZ29yeUlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZVpvbmVzIEVmZmVjdF0gQ2xlYW51cCBmb3IgY2F0ZWdvcnlJZDogJHtjYXRlZ29yeUlkfWApO1xuICAgICAgY29uc3QgY3VycmVudENoYW5uZWwgPSByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudDsgLy8gQ2FwdHVyZSByZWYgaW4gY2xvc3VyZVxuICAgICAgaWYgKGN1cnJlbnRDaGFubmVsICYmIGN1cnJlbnRDaGFubmVsLnRvcGljID09PSBgcmVhbHRpbWU6JHtjaGFubmVsTmFtZX1gKSB7XG4gICAgICAgICBjb25zb2xlLmxvZyhgW3VzZVpvbmVzIEVmZmVjdF0gUmVtb3ZpbmcgY2hhbm5lbCAke2N1cnJlbnRDaGFubmVsLnRvcGljfWApO1xuICAgICAgICAgc3VwYWJhc2UucmVtb3ZlQ2hhbm5lbChjdXJyZW50Q2hhbm5lbCk7XG4gICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2NhdGVnb3J5SWQsIGxvYWRab25lcywgaGFuZGxlWm9uZUNoYW5nZV0pOyAvLyBLb3JyZWt0ZSBBYmjDpG5naWdrZWl0ZW5cblxuICAvLyAtLS0gUmVzdGxpY2hlIEZ1bmt0aW9uZW4gLS0tXG4gIGNvbnN0IHNhdmVab25lID0gdXNlQ2FsbGJhY2soYXN5bmMgKHpvbmVEYXRhOiBab25lSW5wdXQpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgaWYgKCFjYXRlZ29yeUlkKSB7IHRvYXN0LmVycm9yKCdLZWluZSBLYXRlZ29yaWUgSUQnKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgIHRyeSB7XG4gICAgICAgY29uc3QgZHRvRGF0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHpvbmVEYXRhLm5hbWUsXG4gICAgICAgICAgICB6b25lS2V5OiB6b25lRGF0YS56b25lS2V5LFxuICAgICAgICAgICAgcG9pbnRzUGVySW50ZXJ2YWw6IHpvbmVEYXRhLnBvaW50c0dyYW50ZWQsXG4gICAgICAgICAgICBpbnRlcnZhbE1pbnV0ZXM6IHpvbmVEYXRhLm1pbnV0ZXNSZXF1aXJlZFxuICAgICAgIH07XG4gICAgICAgaWYgKHpvbmVEYXRhLmlkKSB7XG4gICAgICAgICBhd2FpdCB6b25lc1NlcnZpY2UudXBkYXRlWm9uZSh6b25lRGF0YS5pZCwgZHRvRGF0YSk7XG4gICAgICAgICB0b2FzdC5zdWNjZXNzKCdab25lIGFrdHVhbGlzaWVydC4nKTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgYXdhaXQgem9uZXNTZXJ2aWNlLmNyZWF0ZVpvbmUoY2F0ZWdvcnlJZCwgZHRvRGF0YSk7XG4gICAgICAgICB0b2FzdC5zdWNjZXNzKCdab25lIGVyc3RlbGx0LicpO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmVobGVyIGJlaW0gU3BlaWNoZXJuIGRlciBab25lOicsIGVycik7XG4gICAgICAgIHRvYXN0LmVycm9yKGVyci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnRmVobGVyIGJlaW0gU3BlaWNoZXJuIGRlciBab25lJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgfVxuICAgICBmaW5hbGx5IHsgc2V0TG9hZGluZyhmYWxzZSk7IH1cbiAgfSwgW2NhdGVnb3J5SWRdKTtcblxuICBjb25zdCBkZWxldGVab25lID0gdXNlQ2FsbGJhY2soYXN5bmMgKHpvbmVJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfT4gPT4ge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHpvbmVzU2VydmljZS5kZWxldGVab25lKHpvbmVJZCk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHRvYXN0LnN1Y2Nlc3MoJ1pvbmUgZ2Vsw7ZzY2h0LicpO1xuICAgICAgZWxzZSB0b2FzdC5lcnJvcihyZXN1bHQubWVzc2FnZSB8fCAnRmVobGVyIGJlaW0gTMO2c2NoZW4nKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmVobGVyIGJlaW0gTMO2c2NoZW4gZGVyIFpvbmU6JywgZXJyKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVyci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnRmVobGVyIGJlaW0gTMO2c2NoZW4gZGVyIFpvbmUnO1xuICAgICAgICB0b2FzdC5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2UgfTtcbiAgICB9XG4gICAgZmluYWxseSB7IHNldExvYWRpbmcoZmFsc2UpOyB9XG4gIH0sIFtdKTtcblxuICBjb25zdCByZWZldGNoID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbdXNlWm9uZXNdIHJlZmV0Y2ggdHJpZ2dlcmVkJyk7XG4gICAgaWYgKGNhdGVnb3J5SWQpIHtcbiAgICAgIGxvYWRlZENhdGVnb3J5SWRSZWYuY3VycmVudCA9ICcnO1xuICAgICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBsb2FkWm9uZXMoY2F0ZWdvcnlJZCk7XG4gICAgfVxuICB9LCBbY2F0ZWdvcnlJZCwgbG9hZFpvbmVzXSk7XG5cbiAgcmV0dXJuIHsgem9uZXMsIGxvYWRpbmcsIGVycm9yLCBzYXZlWm9uZSwgZGVsZXRlWm9uZSwgcmVmZXRjaCB9O1xufTsiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsInRvYXN0Iiwiem9uZXNTZXJ2aWNlIiwic3VwYWJhc2UiLCJtYXBUb0VuaGFuY2VkWm9uZSIsInpvbmUiLCJpZCIsIm5hbWUiLCJ6b25lS2V5Iiwiem9uZV9rZXkiLCJtaW51dGVzUmVxdWlyZWQiLCJpbnRlcnZhbF9taW51dGVzIiwiaW50ZXJ2YWxNaW51dGVzIiwicG9pbnRzR3JhbnRlZCIsInBvaW50c19wZXJfaW50ZXJ2YWwiLCJwb2ludHNQZXJJbnRlcnZhbCIsImxhc3RBY3RpdmUiLCJ0b3RhbFRpbWVTcGVudCIsInRvdGFsVXNlcnMiLCJ1c2Vab25lcyIsImNhdGVnb3J5SWQiLCJ6b25lcyIsInNldFpvbmVzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwicmVhbHRpbWVDaGFubmVsUmVmIiwibG9hZGVkQ2F0ZWdvcnlJZFJlZiIsImluaXRpYWxMb2FkQ29tcGxldGVSZWYiLCJsb2FkWm9uZXMiLCJjYXRlZ29yeUlkVG9Mb2FkIiwiY29uc29sZSIsImxvZyIsImN1cnJlbnQiLCJ6b25lc0RhdGEiLCJnZXRab25lc0J5Q2F0ZWdvcnkiLCJlbmhhbmNlZFpvbmVzIiwibWFwIiwibGVuZ3RoIiwiZXJyIiwiaGFuZGxlWm9uZUNoYW5nZSIsInBheWxvYWQiLCJldmVudFR5cGUiLCJuZXciLCJuZXdSZWNvcmQiLCJvbGQiLCJvbGRSZWNvcmQiLCJ0YWJsZSIsInNjaGVtYSIsInJlY29yZCIsImNhdGVnb3J5X2lkIiwiem9uZUlkIiwiZW5oYW5jZWRab25lIiwicHJldiIsInNvbWUiLCJ6IiwidXBkYXRlZFpvbmUiLCJmaWx0ZXIiLCJyZW1vdmVDaGFubmVsIiwiY2hhbm5lbCIsImNoYW5uZWxOYW1lIiwidG9waWMiLCJvbiIsImV2ZW50Iiwic3Vic2NyaWJlIiwic3RhdHVzIiwiY3VycmVudENoYW5uZWwiLCJzYXZlWm9uZSIsInpvbmVEYXRhIiwiZHRvRGF0YSIsInVwZGF0ZVpvbmUiLCJzdWNjZXNzIiwiY3JlYXRlWm9uZSIsInJlc3BvbnNlIiwiZGF0YSIsIm1lc3NhZ2UiLCJkZWxldGVab25lIiwicmVzdWx0IiwicmVmZXRjaCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/category-management/hooks/useZones.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/context/auth-context.tsx":
/*!**************************************!*\
  !*** ./src/context/auth-context.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useAuth,AuthProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n// Standardwerte\nconst defaultContext = {\n    user: null,\n    availableGuilds: [],\n    token: null,\n    loading: true,\n    isAuthenticated: false,\n    login: ()=>{},\n    logout: async ()=>{},\n    refreshSession: async ()=>{}\n};\n// Erstellen des Kontexts\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(defaultContext);\n// Hook für den Zugriff auf den Kontext\nconst useAuth = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n// Provider-Komponente\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s1();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [internalAvailableGuilds, setInternalAvailableGuilds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [token, setToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.usePathname)();\n    // --- Stabile Funktionen ---\n    const handleLogout = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[handleLogout]\": async function() {\n            let redirect = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n            console.log('handleLogout: Starting logout...');\n            const currentPath =  true ? window.location.pathname : 0; // Check for window\n            setUser(null);\n            setInternalAvailableGuilds([]);\n            setToken(null);\n            setIsAuthenticated(false);\n            setLoading(false); // Stop loading on logout\n            if (true) {\n                const tokenKey = \"chimera_auth_token\" || 0;\n                localStorage.removeItem(tokenKey);\n                localStorage.removeItem('selectedGuildId'); // Korrekter Schlüssel\n            }\n            try {\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.auth.signOut();\n                if (error) console.error('handleLogout: Supabase signOut error:', error);\n                else console.log('handleLogout: Supabase signOut successful.');\n            } catch (error) {\n                console.error('handleLogout: Unexpected signOut error:', error);\n            }\n            if (redirect && !currentPath.startsWith('/auth/login') && \"object\" !== 'undefined') {\n                console.log('handleLogout: Redirecting to /auth/login');\n                router.push('/auth/login'); // Use Next.js router for client-side navigation\n            } else {\n                console.log('handleLogout: No redirect needed or desired.');\n            }\n        }\n    }[\"AuthProvider.useCallback[handleLogout]\"], [\n        router\n    ]); // router ist stabil\n    const fetchBackendSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[fetchBackendSession]\": async (supabaseToken)=>{\n            console.log('[AuthContext] fetchBackendSession: Fetching backend session...');\n            // Avoid setting loading true if component unmounted before fetch completes\n            let isMounted = true;\n            setLoading(true);\n            try {\n                var _sessionData_user;\n                const apiUrl = \"http://localhost:3000\" || 0;\n                const response = await fetch(\"\".concat(apiUrl, \"/api/v1/auth/session\"), {\n                    headers: {\n                        Authorization: \"Bearer \".concat(supabaseToken)\n                    }\n                });\n                if (!response.ok) {\n                    const errorText = await response.text().catch({\n                        \"AuthProvider.useCallback[fetchBackendSession]\": ()=>\"Status \".concat(response.status)\n                    }[\"AuthProvider.useCallback[fetchBackendSession]\"]);\n                    console.error(\"[AuthContext] fetchBackendSession: Error \".concat(response.status, \": \").concat(errorText));\n                    if (isMounted) await handleLogout(false); // Nur ausloggen, wenn noch gemounted\n                    return null;\n                }\n                const sessionData = await response.json();\n                console.log('[AuthContext] fetchBackendSession: Success. User:', (_sessionData_user = sessionData.user) === null || _sessionData_user === void 0 ? void 0 : _sessionData_user.username);\n                if (isMounted) {\n                    setToken({\n                        \"AuthProvider.useCallback[fetchBackendSession]\": (prev)=>prev === supabaseToken ? prev : supabaseToken\n                    }[\"AuthProvider.useCallback[fetchBackendSession]\"]);\n                    setUser({\n                        \"AuthProvider.useCallback[fetchBackendSession]\": (prev)=>JSON.stringify(prev) === JSON.stringify(sessionData.user) ? prev : sessionData.user\n                    }[\"AuthProvider.useCallback[fetchBackendSession]\"]);\n                    setInternalAvailableGuilds({\n                        \"AuthProvider.useCallback[fetchBackendSession]\": (prev)=>JSON.stringify(prev) === JSON.stringify(sessionData.availableGuilds) ? prev : sessionData.availableGuilds\n                    }[\"AuthProvider.useCallback[fetchBackendSession]\"]);\n                    setIsAuthenticated(true);\n                    if (true) {\n                        const tokenKey = \"chimera_auth_token\" || 0;\n                        localStorage.setItem(tokenKey, supabaseToken);\n                    }\n                }\n                return sessionData;\n            } catch (error) {\n                console.error('[AuthContext] fetchBackendSession: Unexpected error:', error);\n                if (isMounted) await handleLogout(false);\n                return null;\n            } finally{\n                if (isMounted) setLoading(false);\n            }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"AuthProvider.useCallback[fetchBackendSession]\"], [\n        handleLogout\n    ]); // handleLogout ist stabil\n    // --- Auth State Listener ---\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            let isMounted = true; // Flag to prevent state updates on unmounted component\n            console.log('[AuthContext] Setting up onAuthStateChange listener');\n            setLoading(true);\n            const { data: authListener } = _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.auth.onAuthStateChange({\n                \"AuthProvider.useEffect\": async (event, session)=>{\n                    if (!isMounted) return; // Don't run if component is unmounted\n                    console.log('[AuthContext] Event:', event, 'Session present:', !!session);\n                    if (event === 'INITIAL_SESSION' || event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {\n                        if (session === null || session === void 0 ? void 0 : session.access_token) {\n                            await fetchBackendSession(session.access_token);\n                        } else {\n                            if (isAuthenticated) {\n                                console.log('[AuthContext] Auth event with session but no token, logging out.');\n                                await handleLogout(false);\n                            } else {\n                                setLoading(false);\n                            }\n                        }\n                    } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n                        console.log(\"[AuthContext] \".concat(event, \" event received, logging out.\"));\n                        await handleLogout(true); // Logout with redirect\n                    }\n                // setLoading is handled within fetchBackendSession/handleLogout\n                }\n            }[\"AuthProvider.useEffect\"]);\n            return ({\n                \"AuthProvider.useEffect\": ()=>{\n                    var _authListener_subscription;\n                    isMounted = false; // Set flag on unmount\n                    console.log('[AuthContext] Removing onAuthStateChange listener');\n                    authListener === null || authListener === void 0 ? void 0 : (_authListener_subscription = authListener.subscription) === null || _authListener_subscription === void 0 ? void 0 : _authListener_subscription.unsubscribe();\n                }\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], [\n        fetchBackendSession,\n        handleLogout,\n        isAuthenticated\n    ]); // isAuthenticated added\n    // --- Other Functions ---\n    const login = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[login]\": async ()=>{\n            console.log('Login: Starting Supabase Discord OAuth Flow...');\n            if (true) {\n                localStorage.removeItem(\"chimera_auth_token\" || 0);\n                localStorage.removeItem('selectedGuildId');\n            }\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.auth.signInWithOAuth({\n                provider: 'discord',\n                options: {\n                    redirectTo: \"\".concat(window.location.protocol, \"//\").concat(window.location.host, \"/auth/callback\"),\n                    scopes: 'identify guilds'\n                }\n            });\n            if (error) console.error('Login Error:', error);\n        }\n    }[\"AuthProvider.useCallback[login]\"], []);\n    const refreshSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[refreshSession]\": async ()=>{\n            console.log('[AuthContext] refreshSession called...');\n            const { data: { session } } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.auth.getSession();\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await fetchBackendSession(session.access_token);\n            } else {\n                console.warn('[AuthContext] refreshSession: No valid Supabase session found.');\n                await handleLogout(true);\n            }\n        }\n    }[\"AuthProvider.useCallback[refreshSession]\"], [\n        fetchBackendSession,\n        handleLogout\n    ]);\n    // --- Redirect Effect ---\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            console.log(\"[AuthContext Redirect Check] loading: \".concat(loading, \", isAuthenticated: \").concat(isAuthenticated, \", pathname: \").concat(pathname));\n            if (!loading && isAuthenticated && !pathname.startsWith('/dashboard') && !pathname.startsWith('/auth/callback')) {\n                console.log('[AuthContext Redirect Action] Redirecting to /dashboard...');\n                router.replace('/dashboard');\n            }\n        }\n    }[\"AuthProvider.useEffect\"], [\n        loading,\n        isAuthenticated,\n        pathname,\n        router\n    ]);\n    // --- Memoized Context Value ---\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"AuthProvider.useMemo[contextValue]\": ()=>{\n            console.log('[AuthContext] Recalculating context value.');\n            return {\n                user,\n                availableGuilds: internalAvailableGuilds,\n                token,\n                loading,\n                isAuthenticated,\n                login,\n                logout: handleLogout,\n                refreshSession\n            };\n        }\n    }[\"AuthProvider.useMemo[contextValue]\"], [\n        user,\n        internalAvailableGuilds,\n        token,\n        loading,\n        isAuthenticated,\n        login,\n        handleLogout,\n        refreshSession\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\info\\\\Documents\\\\Discord Bot\\\\Chimera\\\\apps\\\\frontend\\\\src\\\\context\\\\auth-context.tsx\",\n        lineNumber: 216,\n        columnNumber: 5\n    }, this);\n}\n_s1(AuthProvider, \"BJfqnzkHIjEi+EqcinsMt+uiSy4=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter,\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.usePathname\n    ];\n});\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L2F1dGgtY29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRW9HO0FBQzNDO0FBQ2Y7QUFpQjFDLGdCQUFnQjtBQUNoQixNQUFNVSxpQkFBa0M7SUFDdENDLE1BQU07SUFDTkMsaUJBQWlCLEVBQUU7SUFDbkJDLE9BQU87SUFDUEMsU0FBUztJQUNUQyxpQkFBaUI7SUFDakJDLE9BQU8sS0FBTztJQUNkQyxRQUFRLFdBQWE7SUFDckJDLGdCQUFnQixXQUFhO0FBQy9CO0FBRUEseUJBQXlCO0FBQ3pCLE1BQU1DLDRCQUFjbEIsb0RBQWFBLENBQWtCUztBQUVuRCx1Q0FBdUM7QUFDaEMsTUFBTVUsVUFBVTs7SUFBTWxCLE9BQUFBLGlEQUFVQSxDQUFDaUI7QUFBVyxFQUFFO0dBQXhDQztBQUViLHNCQUFzQjtBQUNmLFNBQVNDLGFBQWEsS0FBMkM7UUFBM0MsRUFBRUMsUUFBUSxFQUFpQyxHQUEzQzs7SUFDM0IsTUFBTSxDQUFDWCxNQUFNWSxRQUFRLEdBQUduQiwrQ0FBUUEsQ0FBYztJQUM5QyxNQUFNLENBQUNvQix5QkFBeUJDLDJCQUEyQixHQUFHckIsK0NBQVFBLENBQTBCLEVBQUU7SUFDbEcsTUFBTSxDQUFDUyxPQUFPYSxTQUFTLEdBQUd0QiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDVSxTQUFTYSxXQUFXLEdBQUd2QiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNXLGlCQUFpQmEsbUJBQW1CLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNeUIsU0FBU3RCLDBEQUFTQTtJQUN4QixNQUFNdUIsV0FBV3RCLDREQUFXQTtJQUU1Qiw2QkFBNkI7SUFDN0IsTUFBTXVCLGVBQWV6QixrREFBV0E7a0RBQUM7Z0JBQU8wQiw0RUFBVztZQUNqREMsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTUMsY0FBYyxLQUE2QixHQUFHQyxPQUFPQyxRQUFRLENBQUNQLFFBQVEsR0FBRyxD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QUFtQixDQUFDZSxTQUFTaUIsVUFBVSxDQUFDLGlCQUFpQixDQUFDakIsU0FBU2lCLFVBQVUsQ0FBQyxtQkFBbUI7Z0JBQy9HZCxRQUFRQyxHQUFHLENBQUM7Z0JBQ1pMLE9BQU8wRCxPQUFPLENBQUM7WUFDakI7UUFDRjtpQ0FBRztRQUFDekU7UUFBU0M7UUFBaUJlO1FBQVVEO0tBQU87SUFFL0MsaUNBQWlDO0lBQ2pDLE1BQU0yRCxlQUFlbkYsOENBQU9BOzhDQUFDO1lBQzNCNEIsUUFBUUMsR0FBRyxDQUFDO1lBQ1osT0FBTztnQkFDTHZCO2dCQUNBQyxpQkFBaUJZO2dCQUNqQlg7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7Z0JBQ0FDLFFBQVFjO2dCQUNSYjtZQUNGO1FBQ0Y7NkNBQUc7UUFBQ1A7UUFBTWE7UUFBeUJYO1FBQU9DO1FBQVNDO1FBQWlCQztRQUFPZTtRQUFjYjtLQUFlO0lBRXhHLHFCQUNFLDhEQUFDQyxZQUFZc0UsUUFBUTtRQUFDQyxPQUFPRjtrQkFDMUJsRTs7Ozs7O0FBR1A7SUFuTGdCRDs7UUFNQ2Qsc0RBQVNBO1FBQ1BDLHdEQUFXQTs7O0tBUGRhIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGluZm9cXERvY3VtZW50c1xcRGlzY29yZCBCb3RcXENoaW1lcmFcXGFwcHNcXGZyb250ZW5kXFxzcmNcXGNvbnRleHRcXGF1dGgtY29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlTWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIsIHVzZVBhdGhuYW1lIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuaW1wb3J0IHsgU2Vzc2lvbkR0bywgR3VpbGRTZWxlY3Rpb25JbmZvRHRvLCBVc2VyUHJvZmlsZUR0byB9IGZyb20gJ3NoYXJlZC10eXBlcyc7XG5cbi8vIFR5cGRlZmluaXRpb25lblxuZXhwb3J0IHR5cGUgVXNlciA9IE9taXQ8VXNlclByb2ZpbGVEdG8sICdjcmVhdGVkX2F0JyB8ICd1cGRhdGVkX2F0JyB8ICdpc19zdXBlcl9hZG1pbic+OyAvLyBFeGNsdWRlIGJhY2tlbmQtb25seSBmaWVsZHMgaWYgbmVlZGVkXG5cbmludGVyZmFjZSBBdXRoQ29udGV4dFR5cGUge1xuICB1c2VyOiBVc2VyIHwgbnVsbDtcbiAgYXZhaWxhYmxlR3VpbGRzOiBHdWlsZFNlbGVjdGlvbkluZm9EdG9bXTtcbiAgdG9rZW46IHN0cmluZyB8IG51bGw7XG4gIGxvYWRpbmc6IGJvb2xlYW47XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgbG9naW46ICgpID0+IHZvaWQ7XG4gIGxvZ291dDogKHJlZGlyZWN0PzogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVmcmVzaFNlc3Npb246ICgpID0+IFByb21pc2U8dm9pZD47XG59XG5cbi8vIFN0YW5kYXJkd2VydGVcbmNvbnN0IGRlZmF1bHRDb250ZXh0OiBBdXRoQ29udGV4dFR5cGUgPSB7XG4gIHVzZXI6IG51bGwsXG4gIGF2YWlsYWJsZUd1aWxkczogW10sXG4gIHRva2VuOiBudWxsLFxuICBsb2FkaW5nOiB0cnVlLFxuICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICBsb2dpbjogKCkgPT4ge30sXG4gIGxvZ291dDogYXN5bmMgKCkgPT4ge30sXG4gIHJlZnJlc2hTZXNzaW9uOiBhc3luYyAoKSA9PiB7fSxcbn07XG5cbi8vIEVyc3RlbGxlbiBkZXMgS29udGV4dHNcbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGU+KGRlZmF1bHRDb250ZXh0KTtcblxuLy8gSG9vayBmw7xyIGRlbiBadWdyaWZmIGF1ZiBkZW4gS29udGV4dFxuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKSA9PiB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcblxuLy8gUHJvdmlkZXItS29tcG9uZW50ZVxuZXhwb3J0IGZ1bmN0aW9uIEF1dGhQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlPFVzZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2ludGVybmFsQXZhaWxhYmxlR3VpbGRzLCBzZXRJbnRlcm5hbEF2YWlsYWJsZUd1aWxkc10gPSB1c2VTdGF0ZTxHdWlsZFNlbGVjdGlvbkluZm9EdG9bXT4oW10pO1xuICBjb25zdCBbdG9rZW4sIHNldFRva2VuXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2lzQXV0aGVudGljYXRlZCwgc2V0SXNBdXRoZW50aWNhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIGNvbnN0IHBhdGhuYW1lID0gdXNlUGF0aG5hbWUoKTtcblxuICAvLyAtLS0gU3RhYmlsZSBGdW5rdGlvbmVuIC0tLVxuICBjb25zdCBoYW5kbGVMb2dvdXQgPSB1c2VDYWxsYmFjayhhc3luYyAocmVkaXJlY3QgPSB0cnVlKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ2hhbmRsZUxvZ291dDogU3RhcnRpbmcgbG9nb3V0Li4uJyk7XG4gICAgY29uc3QgY3VycmVudFBhdGggPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA6ICcnOyAvLyBDaGVjayBmb3Igd2luZG93XG4gICAgc2V0VXNlcihudWxsKTtcbiAgICBzZXRJbnRlcm5hbEF2YWlsYWJsZUd1aWxkcyhbXSk7XG4gICAgc2V0VG9rZW4obnVsbCk7XG4gICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTsgLy8gU3RvcCBsb2FkaW5nIG9uIGxvZ291dFxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IHRva2VuS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVVUSF9UT0tFTl9LRVkgfHwgJ2NoaW1lcmFfYXV0aF90b2tlbic7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRva2VuS2V5KTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3NlbGVjdGVkR3VpbGRJZCcpOyAvLyBLb3JyZWt0ZXIgU2NobMO8c3NlbFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25PdXQoKTtcbiAgICAgIGlmIChlcnJvcikgY29uc29sZS5lcnJvcignaGFuZGxlTG9nb3V0OiBTdXBhYmFzZSBzaWduT3V0IGVycm9yOicsIGVycm9yKTtcbiAgICAgIGVsc2UgY29uc29sZS5sb2coJ2hhbmRsZUxvZ291dDogU3VwYWJhc2Ugc2lnbk91dCBzdWNjZXNzZnVsLicpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdoYW5kbGVMb2dvdXQ6IFVuZXhwZWN0ZWQgc2lnbk91dCBlcnJvcjonLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHJlZGlyZWN0ICYmICFjdXJyZW50UGF0aC5zdGFydHNXaXRoKCcvYXV0aC9sb2dpbicpICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmxvZygnaGFuZGxlTG9nb3V0OiBSZWRpcmVjdGluZyB0byAvYXV0aC9sb2dpbicpO1xuICAgICAgcm91dGVyLnB1c2goJy9hdXRoL2xvZ2luJyk7IC8vIFVzZSBOZXh0LmpzIHJvdXRlciBmb3IgY2xpZW50LXNpZGUgbmF2aWdhdGlvblxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnaGFuZGxlTG9nb3V0OiBObyByZWRpcmVjdCBuZWVkZWQgb3IgZGVzaXJlZC4nKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXJdKTsgLy8gcm91dGVyIGlzdCBzdGFiaWxcblxuICBjb25zdCBmZXRjaEJhY2tlbmRTZXNzaW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKHN1cGFiYXNlVG9rZW46IHN0cmluZyk6IFByb21pc2U8U2Vzc2lvbkR0byB8IG51bGw+ID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0F1dGhDb250ZXh0XSBmZXRjaEJhY2tlbmRTZXNzaW9uOiBGZXRjaGluZyBiYWNrZW5kIHNlc3Npb24uLi4nKTtcbiAgICAvLyBBdm9pZCBzZXR0aW5nIGxvYWRpbmcgdHJ1ZSBpZiBjb21wb25lbnQgdW5tb3VudGVkIGJlZm9yZSBmZXRjaCBjb21wbGV0ZXNcbiAgICBsZXQgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhcGlVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHthcGlVcmx9L2FwaS92MS9hdXRoL3Nlc3Npb25gLCB7XG4gICAgICAgIGhlYWRlcnM6IHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3N1cGFiYXNlVG9rZW59YCB9LFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IGBTdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtBdXRoQ29udGV4dF0gZmV0Y2hCYWNrZW5kU2Vzc2lvbjogRXJyb3IgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcbiAgICAgICAgaWYgKGlzTW91bnRlZCkgYXdhaXQgaGFuZGxlTG9nb3V0KGZhbHNlKTsgLy8gTnVyIGF1c2xvZ2dlbiwgd2VubiBub2NoIGdlbW91bnRlZFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2Vzc2lvbkRhdGE6IFNlc3Npb25EdG8gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnW0F1dGhDb250ZXh0XSBmZXRjaEJhY2tlbmRTZXNzaW9uOiBTdWNjZXNzLiBVc2VyOicsIHNlc3Npb25EYXRhLnVzZXI/LnVzZXJuYW1lKTtcblxuICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICBzZXRUb2tlbihwcmV2ID0+IHByZXYgPT09IHN1cGFiYXNlVG9rZW4gPyBwcmV2IDogc3VwYWJhc2VUb2tlbik7XG4gICAgICAgIHNldFVzZXIocHJldiA9PiBKU09OLnN0cmluZ2lmeShwcmV2KSA9PT0gSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbkRhdGEudXNlcikgPyBwcmV2IDogc2Vzc2lvbkRhdGEudXNlcik7XG4gICAgICAgIHNldEludGVybmFsQXZhaWxhYmxlR3VpbGRzKHByZXYgPT4gSlNPTi5zdHJpbmdpZnkocHJldikgPT09IEpTT04uc3RyaW5naWZ5KHNlc3Npb25EYXRhLmF2YWlsYWJsZUd1aWxkcykgPyBwcmV2IDogc2Vzc2lvbkRhdGEuYXZhaWxhYmxlR3VpbGRzKTtcbiAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BVVRIX1RPS0VOX0tFWSB8fCAnY2hpbWVyYV9hdXRoX3Rva2VuJztcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRva2VuS2V5LCBzdXBhYmFzZVRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlc3Npb25EYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbQXV0aENvbnRleHRdIGZldGNoQmFja2VuZFNlc3Npb246IFVuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgaWYgKGlzTW91bnRlZCkgYXdhaXQgaGFuZGxlTG9nb3V0KGZhbHNlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoaXNNb3VudGVkKSBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2hhbmRsZUxvZ291dF0pOyAvLyBoYW5kbGVMb2dvdXQgaXN0IHN0YWJpbFxuXG5cbiAgLy8gLS0tIEF1dGggU3RhdGUgTGlzdGVuZXIgLS0tXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7IC8vIEZsYWcgdG8gcHJldmVudCBzdGF0ZSB1cGRhdGVzIG9uIHVubW91bnRlZCBjb21wb25lbnRcbiAgICBjb25zb2xlLmxvZygnW0F1dGhDb250ZXh0XSBTZXR0aW5nIHVwIG9uQXV0aFN0YXRlQ2hhbmdlIGxpc3RlbmVyJyk7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcblxuICAgIGNvbnN0IHsgZGF0YTogYXV0aExpc3RlbmVyIH0gPSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKFxuICAgICAgYXN5bmMgKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICAgIGlmICghaXNNb3VudGVkKSByZXR1cm47IC8vIERvbid0IHJ1biBpZiBjb21wb25lbnQgaXMgdW5tb3VudGVkXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQXV0aENvbnRleHRdIEV2ZW50OicsIGV2ZW50LCAnU2Vzc2lvbiBwcmVzZW50OicsICEhc2Vzc2lvbik7XG5cbiAgICAgICAgaWYgKGV2ZW50ID09PSAnSU5JVElBTF9TRVNTSU9OJyB8fCBldmVudCA9PT0gJ1NJR05FRF9JTicgfHwgZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnKSB7XG4gICAgICAgICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgYXdhaXQgZmV0Y2hCYWNrZW5kU2Vzc2lvbihzZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhlbnRpY2F0ZWQpIHsgLy8gT25seSBsb2dvdXQgaWYgcHJldmlvdXNseSBhdXRoZW50aWNhdGVkXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQXV0aENvbnRleHRdIEF1dGggZXZlbnQgd2l0aCBzZXNzaW9uIGJ1dCBubyB0b2tlbiwgbG9nZ2luZyBvdXQuJyk7XG4gICAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvZ291dChmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJyB8fCBldmVudCA9PT0gJ1VTRVJfREVMRVRFRCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbQXV0aENvbnRleHRdICR7ZXZlbnR9IGV2ZW50IHJlY2VpdmVkLCBsb2dnaW5nIG91dC5gKTtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvZ291dCh0cnVlKTsgLy8gTG9nb3V0IHdpdGggcmVkaXJlY3RcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXRMb2FkaW5nIGlzIGhhbmRsZWQgd2l0aGluIGZldGNoQmFja2VuZFNlc3Npb24vaGFuZGxlTG9nb3V0XG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQgPSBmYWxzZTsgLy8gU2V0IGZsYWcgb24gdW5tb3VudFxuICAgICAgY29uc29sZS5sb2coJ1tBdXRoQ29udGV4dF0gUmVtb3Zpbmcgb25BdXRoU3RhdGVDaGFuZ2UgbGlzdGVuZXInKTtcbiAgICAgIGF1dGhMaXN0ZW5lcj8uc3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtmZXRjaEJhY2tlbmRTZXNzaW9uLCBoYW5kbGVMb2dvdXQsIGlzQXV0aGVudGljYXRlZF0pOyAvLyBpc0F1dGhlbnRpY2F0ZWQgYWRkZWRcblxuICAvLyAtLS0gT3RoZXIgRnVuY3Rpb25zIC0tLVxuICBjb25zdCBsb2dpbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnTG9naW46IFN0YXJ0aW5nIFN1cGFiYXNlIERpc2NvcmQgT0F1dGggRmxvdy4uLicpO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BVVRIX1RPS0VOX0tFWSB8fCAnY2hpbWVyYV9hdXRoX3Rva2VuJyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzZWxlY3RlZEd1aWxkSWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoT0F1dGgoe1xuICAgICAgcHJvdmlkZXI6ICdkaXNjb3JkJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcmVkaXJlY3RUbzogYCR7d2luZG93LmxvY2F0aW9uLnByb3RvY29sfS8vJHt3aW5kb3cubG9jYXRpb24uaG9zdH0vYXV0aC9jYWxsYmFja2AsXG4gICAgICAgIHNjb3BlczogJ2lkZW50aWZ5IGd1aWxkcycsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChlcnJvcikgY29uc29sZS5lcnJvcignTG9naW4gRXJyb3I6JywgZXJyb3IpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgcmVmcmVzaFNlc3Npb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1tBdXRoQ29udGV4dF0gcmVmcmVzaFNlc3Npb24gY2FsbGVkLi4uJyk7XG4gICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCk7XG4gICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgYXdhaXQgZmV0Y2hCYWNrZW5kU2Vzc2lvbihzZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignW0F1dGhDb250ZXh0XSByZWZyZXNoU2Vzc2lvbjogTm8gdmFsaWQgU3VwYWJhc2Ugc2Vzc2lvbiBmb3VuZC4nKTtcbiAgICAgIGF3YWl0IGhhbmRsZUxvZ291dCh0cnVlKTtcbiAgICB9XG4gIH0sIFtmZXRjaEJhY2tlbmRTZXNzaW9uLCBoYW5kbGVMb2dvdXRdKTtcblxuICAvLyAtLS0gUmVkaXJlY3QgRWZmZWN0IC0tLVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBbQXV0aENvbnRleHQgUmVkaXJlY3QgQ2hlY2tdIGxvYWRpbmc6ICR7bG9hZGluZ30sIGlzQXV0aGVudGljYXRlZDogJHtpc0F1dGhlbnRpY2F0ZWR9LCBwYXRobmFtZTogJHtwYXRobmFtZX1gKTtcbiAgICBpZiAoIWxvYWRpbmcgJiYgaXNBdXRoZW50aWNhdGVkICYmICFwYXRobmFtZS5zdGFydHNXaXRoKCcvZGFzaGJvYXJkJykgJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoJy9hdXRoL2NhbGxiYWNrJykpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbQXV0aENvbnRleHQgUmVkaXJlY3QgQWN0aW9uXSBSZWRpcmVjdGluZyB0byAvZGFzaGJvYXJkLi4uJyk7XG4gICAgICByb3V0ZXIucmVwbGFjZSgnL2Rhc2hib2FyZCcpO1xuICAgIH1cbiAgfSwgW2xvYWRpbmcsIGlzQXV0aGVudGljYXRlZCwgcGF0aG5hbWUsIHJvdXRlcl0pO1xuXG4gIC8vIC0tLSBNZW1vaXplZCBDb250ZXh0IFZhbHVlIC0tLVxuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0F1dGhDb250ZXh0XSBSZWNhbGN1bGF0aW5nIGNvbnRleHQgdmFsdWUuJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXIsXG4gICAgICBhdmFpbGFibGVHdWlsZHM6IGludGVybmFsQXZhaWxhYmxlR3VpbGRzLCAvLyBVc2UgaW50ZXJuYWwgc3RhdGVcbiAgICAgIHRva2VuLFxuICAgICAgbG9hZGluZyxcbiAgICAgIGlzQXV0aGVudGljYXRlZCxcbiAgICAgIGxvZ2luLFxuICAgICAgbG9nb3V0OiBoYW5kbGVMb2dvdXQsXG4gICAgICByZWZyZXNoU2Vzc2lvbixcbiAgICB9O1xuICB9LCBbdXNlciwgaW50ZXJuYWxBdmFpbGFibGVHdWlsZHMsIHRva2VuLCBsb2FkaW5nLCBpc0F1dGhlbnRpY2F0ZWQsIGxvZ2luLCBoYW5kbGVMb2dvdXQsIHJlZnJlc2hTZXNzaW9uXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8QXV0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRWYWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9BdXRoQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwidXNlUm91dGVyIiwidXNlUGF0aG5hbWUiLCJzdXBhYmFzZSIsImRlZmF1bHRDb250ZXh0IiwidXNlciIsImF2YWlsYWJsZUd1aWxkcyIsInRva2VuIiwibG9hZGluZyIsImlzQXV0aGVudGljYXRlZCIsImxvZ2luIiwibG9nb3V0IiwicmVmcmVzaFNlc3Npb24iLCJBdXRoQ29udGV4dCIsInVzZUF1dGgiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInNldFVzZXIiLCJpbnRlcm5hbEF2YWlsYWJsZUd1aWxkcyIsInNldEludGVybmFsQXZhaWxhYmxlR3VpbGRzIiwic2V0VG9rZW4iLCJzZXRMb2FkaW5nIiwic2V0SXNBdXRoZW50aWNhdGVkIiwicm91dGVyIiwicGF0aG5hbWUiLCJoYW5kbGVMb2dvdXQiLCJyZWRpcmVjdCIsImNvbnNvbGUiLCJsb2ciLCJjdXJyZW50UGF0aCIsIndpbmRvdyIsImxvY2F0aW9uIiwidG9rZW5LZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVVUSF9UT0tFTl9LRVkiLCJsb2NhbFN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwiZXJyb3IiLCJhdXRoIiwic2lnbk91dCIsInN0YXJ0c1dpdGgiLCJwdXNoIiwiZmV0Y2hCYWNrZW5kU2Vzc2lvbiIsInN1cGFiYXNlVG9rZW4iLCJpc01vdW50ZWQiLCJzZXNzaW9uRGF0YSIsImFwaVVybCIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJjYXRjaCIsInN0YXR1cyIsImpzb24iLCJ1c2VybmFtZSIsInByZXYiLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0SXRlbSIsImRhdGEiLCJhdXRoTGlzdGVuZXIiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImV2ZW50Iiwic2Vzc2lvbiIsImFjY2Vzc190b2tlbiIsInN1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlIiwic2lnbkluV2l0aE9BdXRoIiwicHJvdmlkZXIiLCJvcHRpb25zIiwicmVkaXJlY3RUbyIsInByb3RvY29sIiwiaG9zdCIsInNjb3BlcyIsImdldFNlc3Npb24iLCJ3YXJuIiwicmVwbGFjZSIsImNvbnRleHRWYWx1ZSIsIlByb3ZpZGVyIiwidmFsdWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/auth-context.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/context/guild-context.tsx":
/*!***************************************!*\
  !*** ./src/context/guild-context.tsx ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GuildProvider: () => (/* binding */ GuildProvider),\n/* harmony export */   useGuild: () => (/* binding */ useGuild)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _auth_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./auth-context */ \"(app-pages-browser)/./src/context/auth-context.tsx\");\n/* __next_internal_client_entry_do_not_use__ useGuild,GuildProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst defaultContext = {\n    availableGuilds: [],\n    currentGuild: null,\n    setCurrentGuild: ()=>{},\n    loading: true\n};\nconst GuildContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(defaultContext);\nconst useGuild = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(GuildContext);\n};\n_s(useGuild, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction GuildProvider(param) {\n    let { children } = param;\n    _s1();\n    const { availableGuilds, loading: authLoading, isAuthenticated } = (0,_auth_context__WEBPACK_IMPORTED_MODULE_2__.useAuth)(); // availableGuilds ist jetzt stabil\n    const [selectedGuild, setSelectedGuild] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Funktion zum Setzen der Guild - stabilisiert\n    const setCurrentGuildMemoized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"GuildProvider.useCallback[setCurrentGuildMemoized]\": (guildId)=>{\n            console.log(\"[GuildContext] setCurrentGuild called with ID: \".concat(guildId));\n            const foundGuild = guildId ? availableGuilds.find({\n                \"GuildProvider.useCallback[setCurrentGuildMemoized]\": (g)=>g.id === guildId\n            }[\"GuildProvider.useCallback[setCurrentGuildMemoized]\"]) : null;\n            setSelectedGuild({\n                \"GuildProvider.useCallback[setCurrentGuildMemoized]\": (prevSelected)=>{\n                    if ((prevSelected === null || prevSelected === void 0 ? void 0 : prevSelected.id) === (foundGuild === null || foundGuild === void 0 ? void 0 : foundGuild.id)) {\n                        console.log(\"[GuildContext] Guild \".concat(guildId, \" is already selected.\"));\n                        return prevSelected; // Keine Änderung, Referenz behalten\n                    }\n                    if (guildId && !foundGuild) {\n                        console.error(\"[GuildContext] Attempted to set non-available guild: \".concat(guildId));\n                        // Nicht ändern, wenn nicht gefunden\n                        return prevSelected;\n                    }\n                    if (foundGuild) {\n                        localStorage.setItem('selectedGuildId', foundGuild.id);\n                        console.log(\"[GuildContext] Guild set to: \".concat(foundGuild.name));\n                        return foundGuild;\n                    } else {\n                        localStorage.removeItem('selectedGuildId');\n                        console.log('[GuildContext] Guild selection cleared.');\n                        return null;\n                    }\n                }\n            }[\"GuildProvider.useCallback[setCurrentGuildMemoized]\"]);\n        }\n    }[\"GuildProvider.useCallback[setCurrentGuildMemoized]\"], [\n        availableGuilds\n    ]); // Abhängig von den verfügbaren Guilds\n    // Effekt zur Initialisierung/Wiederherstellung der Auswahl\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"GuildProvider.useEffect\": ()=>{\n            console.log('[GuildContext Initial Effect] Running. AuthLoading:', authLoading, 'IsAuth:', isAuthenticated);\n            if (!authLoading && isAuthenticated) {\n                const guildsToUse = availableGuilds || [];\n                console.log('[GuildContext Initial Effect] Guilds available:', guildsToUse.length);\n                if (guildsToUse.length === 0) {\n                    if (selectedGuild !== null) {\n                        console.log('[GuildContext Initial Effect] No guilds available, resetting selection.');\n                        setCurrentGuildMemoized(null); // Zustand über die Funktion aktualisieren\n                    }\n                    return;\n                }\n                const storedGuildId = localStorage.getItem('selectedGuildId');\n                let guildToSelect = null;\n                if (storedGuildId) {\n                    guildToSelect = guildsToUse.find({\n                        \"GuildProvider.useEffect\": (g)=>g.id === storedGuildId\n                    }[\"GuildProvider.useEffect\"]);\n                    if (!guildToSelect) {\n                        console.warn(\"[GuildContext Initial Effect] Stored guildId \".concat(storedGuildId, \" not found in available guilds.\"));\n                        localStorage.removeItem('selectedGuildId');\n                    }\n                }\n                if (!guildToSelect && guildsToUse.length > 0) {\n                    guildToSelect = guildsToUse[0];\n                    console.log('[GuildContext Initial Effect] Selecting first available guild:', guildToSelect.name);\n                    // Nur setzen, wenn nicht bereits ausgewählt\n                    if ((selectedGuild === null || selectedGuild === void 0 ? void 0 : selectedGuild.id) !== guildToSelect.id) {\n                        setCurrentGuildMemoized(guildToSelect.id);\n                    }\n                } else if (guildToSelect && (selectedGuild === null || selectedGuild === void 0 ? void 0 : selectedGuild.id) !== guildToSelect.id) {\n                    console.log(\"[GuildContext Initial Effect] Setting selected guild to stored: \".concat(guildToSelect.name));\n                    setCurrentGuildMemoized(guildToSelect.id);\n                } else if (!guildToSelect && selectedGuild !== null) {\n                    console.log('[GuildContext Initial Effect] No valid initial guild, resetting.');\n                    setCurrentGuildMemoized(null);\n                }\n            } else if (!authLoading && !isAuthenticated) {\n                if (selectedGuild !== null) {\n                    console.log('[GuildContext Initial Effect] Not authenticated, resetting selection.');\n                    setCurrentGuildMemoized(null);\n                }\n            }\n        }\n    }[\"GuildProvider.useEffect\"], [\n        authLoading,\n        isAuthenticated,\n        availableGuilds,\n        setCurrentGuildMemoized,\n        selectedGuild\n    ]); // selectedGuild hinzugefügt\n    // Memoisierten Kontextwert erstellen\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"GuildProvider.useMemo[contextValue]\": ()=>{\n            console.log('[GuildContext] Recalculating context value.');\n            return {\n                currentGuild: selectedGuild,\n                availableGuilds: availableGuilds || [],\n                setCurrentGuild: setCurrentGuildMemoized,\n                loading: authLoading\n            };\n        }\n    }[\"GuildProvider.useMemo[contextValue]\"], [\n        selectedGuild,\n        availableGuilds,\n        setCurrentGuildMemoized,\n        authLoading\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(GuildContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\info\\\\Documents\\\\Discord Bot\\\\Chimera\\\\apps\\\\frontend\\\\src\\\\context\\\\guild-context.tsx\",\n        lineNumber: 120,\n        columnNumber: 5\n    }, this);\n}\n_s1(GuildProvider, \"OsRabFJIJysx/9OQg5vtTa0FrK8=\", false, function() {\n    return [\n        _auth_context__WEBPACK_IMPORTED_MODULE_2__.useAuth\n    ];\n});\n_c = GuildProvider;\nvar _c;\n$RefreshReg$(_c, \"GuildProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L2d1aWxkLWNvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRW9HO0FBRTNEO0FBU3pDLE1BQU1RLGlCQUFtQztJQUN2Q0MsaUJBQWlCLEVBQUU7SUFDbkJDLGNBQWM7SUFDZEMsaUJBQWlCLEtBQU87SUFDeEJDLFNBQVM7QUFDWDtBQUVBLE1BQU1DLDZCQUFlWixvREFBYUEsQ0FBbUJPO0FBRTlDLE1BQU1NLFdBQVc7O0lBQU1aLE9BQUFBLGlEQUFVQSxDQUFDVztBQUFZLEVBQUU7R0FBMUNDO0FBRU4sU0FBU0MsY0FBYyxLQUEyQztRQUEzQyxFQUFFQyxRQUFRLEVBQWlDLEdBQTNDOztJQUM1QixNQUFNLEVBQUVQLGVBQWUsRUFBRUcsU0FBU0ssV0FBVyxFQUFFQyxlQUFlLEVBQUUsR0FBR1gsc0RBQU9BLElBQUksbUNBQW1DO0lBQ2pILE1BQU0sQ0FBQ1ksZUFBZUMsaUJBQWlCLEdBQUdqQiwrQ0FBUUEsQ0FBK0I7SUFFakYsK0NBQStDO0lBQy9DLE1BQU1rQiwwQkFBMEJmLGtEQUFXQTs4REFBQyxDQUFDZ0I7WUFDM0NDLFFBQVFDLEdBQUcsQ0FBQyxrREFBMEQsT0FBUkY7WUFDOUQsTUFBTUcsYUFBYUgsVUFBVWIsZ0JBQWdCaUIsSUFBSTtzRUFBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsRUFBRSxLQUFLTjt1RUFBVztZQUUzRUY7c0VBQWlCUyxDQUFBQTtvQkFDYixJQUFJQSxDQUFBQSx5QkFBQUEsbUNBQUFBLGFBQWNELEVBQUUsT0FBS0gsdUJBQUFBLGlDQUFBQSxXQUFZRyxFQUFFLEdBQUU7d0JBQ3JDTCxRQUFRQyxHQUFHLENBQUMsd0JBQWdDLE9BQVJGLFNBQVE7d0JBQzVDLE9BQU9PLGNBQWMsb0NBQW9DO29CQUM3RDtvQkFFQSxJQUFJUCxXQUFXLENBQUNHLFlBQVk7d0JBQ3hCRixRQUFRTyxLQUFLLENBQUMsd0RBQWdFLE9BQVJSO3dCQUN0RSxvQ0FBb0M7d0JBQ3BDLE9B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Q2hpbWVyYVxcYXBwc1xcZnJvbnRlbmRcXHNyY1xcY29udGV4dFxcZ3VpbGQtY29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBHdWlsZFNlbGVjdGlvbkluZm9EdG8gfSBmcm9tICdzaGFyZWQtdHlwZXMnO1xuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gJy4vYXV0aC1jb250ZXh0JztcblxuaW50ZXJmYWNlIEd1aWxkQ29udGV4dFR5cGUge1xuICBhdmFpbGFibGVHdWlsZHM6IEd1aWxkU2VsZWN0aW9uSW5mb0R0b1tdO1xuICBjdXJyZW50R3VpbGQ6IEd1aWxkU2VsZWN0aW9uSW5mb0R0byB8IG51bGw7XG4gIHNldEN1cnJlbnRHdWlsZDogKGd1aWxkSWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIGxvYWRpbmc6IGJvb2xlYW47XG59XG5cbmNvbnN0IGRlZmF1bHRDb250ZXh0OiBHdWlsZENvbnRleHRUeXBlID0ge1xuICBhdmFpbGFibGVHdWlsZHM6IFtdLFxuICBjdXJyZW50R3VpbGQ6IG51bGwsXG4gIHNldEN1cnJlbnRHdWlsZDogKCkgPT4ge30sXG4gIGxvYWRpbmc6IHRydWUsXG59O1xuXG5jb25zdCBHdWlsZENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEd1aWxkQ29udGV4dFR5cGU+KGRlZmF1bHRDb250ZXh0KTtcblxuZXhwb3J0IGNvbnN0IHVzZUd1aWxkID0gKCkgPT4gdXNlQ29udGV4dChHdWlsZENvbnRleHQpO1xuXG5leHBvcnQgZnVuY3Rpb24gR3VpbGRQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IHsgYXZhaWxhYmxlR3VpbGRzLCBsb2FkaW5nOiBhdXRoTG9hZGluZywgaXNBdXRoZW50aWNhdGVkIH0gPSB1c2VBdXRoKCk7IC8vIGF2YWlsYWJsZUd1aWxkcyBpc3QgamV0enQgc3RhYmlsXG4gIGNvbnN0IFtzZWxlY3RlZEd1aWxkLCBzZXRTZWxlY3RlZEd1aWxkXSA9IHVzZVN0YXRlPEd1aWxkU2VsZWN0aW9uSW5mb0R0byB8IG51bGw+KG51bGwpO1xuXG4gIC8vIEZ1bmt0aW9uIHp1bSBTZXR6ZW4gZGVyIEd1aWxkIC0gc3RhYmlsaXNpZXJ0XG4gIGNvbnN0IHNldEN1cnJlbnRHdWlsZE1lbW9pemVkID0gdXNlQ2FsbGJhY2soKGd1aWxkSWQ6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICBjb25zb2xlLmxvZyhgW0d1aWxkQ29udGV4dF0gc2V0Q3VycmVudEd1aWxkIGNhbGxlZCB3aXRoIElEOiAke2d1aWxkSWR9YCk7XG4gICAgY29uc3QgZm91bmRHdWlsZCA9IGd1aWxkSWQgPyBhdmFpbGFibGVHdWlsZHMuZmluZChnID0+IGcuaWQgPT09IGd1aWxkSWQpIDogbnVsbDtcblxuICAgIHNldFNlbGVjdGVkR3VpbGQocHJldlNlbGVjdGVkID0+IHtcbiAgICAgICAgaWYgKHByZXZTZWxlY3RlZD8uaWQgPT09IGZvdW5kR3VpbGQ/LmlkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0d1aWxkQ29udGV4dF0gR3VpbGQgJHtndWlsZElkfSBpcyBhbHJlYWR5IHNlbGVjdGVkLmApO1xuICAgICAgICAgICAgcmV0dXJuIHByZXZTZWxlY3RlZDsgLy8gS2VpbmUgw4RuZGVydW5nLCBSZWZlcmVueiBiZWhhbHRlblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGd1aWxkSWQgJiYgIWZvdW5kR3VpbGQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtHdWlsZENvbnRleHRdIEF0dGVtcHRlZCB0byBzZXQgbm9uLWF2YWlsYWJsZSBndWlsZDogJHtndWlsZElkfWApO1xuICAgICAgICAgICAgLy8gTmljaHQgw6RuZGVybiwgd2VubiBuaWNodCBnZWZ1bmRlblxuICAgICAgICAgICAgcmV0dXJuIHByZXZTZWxlY3RlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3VuZEd1aWxkKSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc2VsZWN0ZWRHdWlsZElkJywgZm91bmRHdWlsZC5pZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0d1aWxkQ29udGV4dF0gR3VpbGQgc2V0IHRvOiAke2ZvdW5kR3VpbGQubmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZEd1aWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3NlbGVjdGVkR3VpbGRJZCcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tHdWlsZENvbnRleHRdIEd1aWxkIHNlbGVjdGlvbiBjbGVhcmVkLicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICB9LCBbYXZhaWxhYmxlR3VpbGRzXSk7IC8vIEFiaMOkbmdpZyB2b24gZGVuIHZlcmbDvGdiYXJlbiBHdWlsZHNcblxuICAgLy8gRWZmZWt0IHp1ciBJbml0aWFsaXNpZXJ1bmcvV2llZGVyaGVyc3RlbGx1bmcgZGVyIEF1c3dhaGxcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0d1aWxkQ29udGV4dCBJbml0aWFsIEVmZmVjdF0gUnVubmluZy4gQXV0aExvYWRpbmc6JywgYXV0aExvYWRpbmcsICdJc0F1dGg6JywgaXNBdXRoZW50aWNhdGVkKTtcbiAgICBpZiAoIWF1dGhMb2FkaW5nICYmIGlzQXV0aGVudGljYXRlZCkge1xuICAgICAgICBjb25zdCBndWlsZHNUb1VzZSA9IGF2YWlsYWJsZUd1aWxkcyB8fCBbXTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tHdWlsZENvbnRleHQgSW5pdGlhbCBFZmZlY3RdIEd1aWxkcyBhdmFpbGFibGU6JywgZ3VpbGRzVG9Vc2UubGVuZ3RoKTtcblxuICAgICAgICBpZiAoZ3VpbGRzVG9Vc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRHdWlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbR3VpbGRDb250ZXh0IEluaXRpYWwgRWZmZWN0XSBObyBndWlsZHMgYXZhaWxhYmxlLCByZXNldHRpbmcgc2VsZWN0aW9uLicpO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRHdWlsZE1lbW9pemVkKG51bGwpOyAvLyBadXN0YW5kIMO8YmVyIGRpZSBGdW5rdGlvbiBha3R1YWxpc2llcmVuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9yZWRHdWlsZElkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NlbGVjdGVkR3VpbGRJZCcpO1xuICAgICAgICBsZXQgZ3VpbGRUb1NlbGVjdDogR3VpbGRTZWxlY3Rpb25JbmZvRHRvIHwgdW5kZWZpbmVkIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHN0b3JlZEd1aWxkSWQpIHtcbiAgICAgICAgICAgIGd1aWxkVG9TZWxlY3QgPSBndWlsZHNUb1VzZS5maW5kKGcgPT4gZy5pZCA9PT0gc3RvcmVkR3VpbGRJZCk7XG4gICAgICAgICAgICBpZiAoIWd1aWxkVG9TZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtHdWlsZENvbnRleHQgSW5pdGlhbCBFZmZlY3RdIFN0b3JlZCBndWlsZElkICR7c3RvcmVkR3VpbGRJZH0gbm90IGZvdW5kIGluIGF2YWlsYWJsZSBndWlsZHMuYCk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3NlbGVjdGVkR3VpbGRJZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFndWlsZFRvU2VsZWN0ICYmIGd1aWxkc1RvVXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGd1aWxkVG9TZWxlY3QgPSBndWlsZHNUb1VzZVswXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbR3VpbGRDb250ZXh0IEluaXRpYWwgRWZmZWN0XSBTZWxlY3RpbmcgZmlyc3QgYXZhaWxhYmxlIGd1aWxkOicsIGd1aWxkVG9TZWxlY3QubmFtZSk7XG4gICAgICAgICAgICAgLy8gTnVyIHNldHplbiwgd2VubiBuaWNodCBiZXJlaXRzIGF1c2dld8OkaGx0XG4gICAgICAgICAgICAgaWYgKHNlbGVjdGVkR3VpbGQ/LmlkICE9PSBndWlsZFRvU2VsZWN0LmlkKSB7XG4gICAgICAgICAgICAgICAgIHNldEN1cnJlbnRHdWlsZE1lbW9pemVkKGd1aWxkVG9TZWxlY3QuaWQpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChndWlsZFRvU2VsZWN0ICYmIHNlbGVjdGVkR3VpbGQ/LmlkICE9PSBndWlsZFRvU2VsZWN0LmlkKSB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coYFtHdWlsZENvbnRleHQgSW5pdGlhbCBFZmZlY3RdIFNldHRpbmcgc2VsZWN0ZWQgZ3VpbGQgdG8gc3RvcmVkOiAke2d1aWxkVG9TZWxlY3QubmFtZX1gKTtcbiAgICAgICAgICAgICBzZXRDdXJyZW50R3VpbGRNZW1vaXplZChndWlsZFRvU2VsZWN0LmlkKTtcbiAgICAgICAgfSBlbHNlIGlmICghZ3VpbGRUb1NlbGVjdCAmJiBzZWxlY3RlZEd1aWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ1tHdWlsZENvbnRleHQgSW5pdGlhbCBFZmZlY3RdIE5vIHZhbGlkIGluaXRpYWwgZ3VpbGQsIHJlc2V0dGluZy4nKTtcbiAgICAgICAgICAgICBzZXRDdXJyZW50R3VpbGRNZW1vaXplZChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICghYXV0aExvYWRpbmcgJiYgIWlzQXV0aGVudGljYXRlZCkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRHdWlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tHdWlsZENvbnRleHQgSW5pdGlhbCBFZmZlY3RdIE5vdCBhdXRoZW50aWNhdGVkLCByZXNldHRpbmcgc2VsZWN0aW9uLicpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEd1aWxkTWVtb2l6ZWQobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0sIFthdXRoTG9hZGluZywgaXNBdXRoZW50aWNhdGVkLCBhdmFpbGFibGVHdWlsZHMsIHNldEN1cnJlbnRHdWlsZE1lbW9pemVkLCBzZWxlY3RlZEd1aWxkXSk7IC8vIHNlbGVjdGVkR3VpbGQgaGluenVnZWbDvGd0XG5cbiAgLy8gTWVtb2lzaWVydGVuIEtvbnRleHR3ZXJ0IGVyc3RlbGxlblxuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0d1aWxkQ29udGV4dF0gUmVjYWxjdWxhdGluZyBjb250ZXh0IHZhbHVlLicpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50R3VpbGQ6IHNlbGVjdGVkR3VpbGQsXG4gICAgICBhdmFpbGFibGVHdWlsZHM6IGF2YWlsYWJsZUd1aWxkcyB8fCBbXSxcbiAgICAgIHNldEN1cnJlbnRHdWlsZDogc2V0Q3VycmVudEd1aWxkTWVtb2l6ZWQsXG4gICAgICBsb2FkaW5nOiBhdXRoTG9hZGluZyxcbiAgICB9O1xuICB9LCBbc2VsZWN0ZWRHdWlsZCwgYXZhaWxhYmxlR3VpbGRzLCBzZXRDdXJyZW50R3VpbGRNZW1vaXplZCwgYXV0aExvYWRpbmddKTtcblxuICByZXR1cm4gKFxuICAgIDxHdWlsZENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRWYWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9HdWlsZENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59Il0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsInVzZUF1dGgiLCJkZWZhdWx0Q29udGV4dCIsImF2YWlsYWJsZUd1aWxkcyIsImN1cnJlbnRHdWlsZCIsInNldEN1cnJlbnRHdWlsZCIsImxvYWRpbmciLCJHdWlsZENvbnRleHQiLCJ1c2VHdWlsZCIsIkd1aWxkUHJvdmlkZXIiLCJjaGlsZHJlbiIsImF1dGhMb2FkaW5nIiwiaXNBdXRoZW50aWNhdGVkIiwic2VsZWN0ZWRHdWlsZCIsInNldFNlbGVjdGVkR3VpbGQiLCJzZXRDdXJyZW50R3VpbGRNZW1vaXplZCIsImd1aWxkSWQiLCJjb25zb2xlIiwibG9nIiwiZm91bmRHdWlsZCIsImZpbmQiLCJnIiwiaWQiLCJwcmV2U2VsZWN0ZWQiLCJlcnJvciIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJuYW1lIiwicmVtb3ZlSXRlbSIsImd1aWxkc1RvVXNlIiwibGVuZ3RoIiwic3RvcmVkR3VpbGRJZCIsImdldEl0ZW0iLCJndWlsZFRvU2VsZWN0Iiwid2FybiIsImNvbnRleHRWYWx1ZSIsIlByb3ZpZGVyIiwidmFsdWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/guild-context.tsx\n"));

/***/ })

});