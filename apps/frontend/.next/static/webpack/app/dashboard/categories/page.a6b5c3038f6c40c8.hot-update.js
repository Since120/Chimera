"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/categories/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts":
/*!*****************************************************************************!*\
  !*** ./src/components/dashboard/category-management/hooks/useCategories.ts ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCategories: () => (/* binding */ useCategories)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/core/toaster */ \"(app-pages-browser)/./src/components/core/toaster.tsx\");\n/* harmony import */ var _context_guild_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/context/guild-context */ \"(app-pages-browser)/./src/context/guild-context.tsx\");\n/* harmony import */ var _services_categories__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/categories */ \"(app-pages-browser)/./src/services/categories.ts\");\n/* harmony import */ var _services_zones__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/zones */ \"(app-pages-browser)/./src/services/zones.ts\");\n/* harmony import */ var shared_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! shared-types */ \"(app-pages-browser)/../../packages/shared-types/src/index.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useCategories auto */ \n // Import hinzugefügt\n\n\n\n // ZoneDto hinzugefügt\n\n// Helper zum Mappen von DB-Zone zu EnhancedZone\nconst mapToEnhancedZone = (zone)=>({\n        id: zone.id,\n        name: zone.name,\n        zoneKey: zone.zoneKey,\n        minutesRequired: zone.intervalMinutes,\n        pointsGranted: zone.pointsPerInterval,\n        lastActive: '-',\n        totalTimeSpent: 0,\n        totalUsers: 0 // Placeholder\n    });\n// Helper zum Mappen von DB-Kategorie zu EnhancedCategory\nconst mapToEnhancedCategory = (category, guildId, zones)=>({\n        id: category.id,\n        name: category.name,\n        guild_id: guildId,\n        allowedRoles: category.allowedRoles || [],\n        isVisible: category.isVisibleDefault,\n        sendSetup: category.setupFlowEnabled,\n        trackingActive: category.defaultTrackingEnabled,\n        setupTextChannel: category.setupChannelId,\n        waitingRoomName: category.warteraumChannelId,\n        lastActive: '-',\n        totalTimeSpent: 0,\n        totalUsers: 0,\n        discordCategoryId: category.discordCategoryId || null,\n        deletedInDiscord: !category.discordCategoryId,\n        createdAt: new Date(category.createdAt),\n        updatedAt: new Date(category.updatedAt),\n        zones: zones\n    });\nconst useCategories = ()=>{\n    const { currentGuild } = (0,_context_guild_context__WEBPACK_IMPORTED_MODULE_2__.useGuild)();\n    const guildId = (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) || '';\n    console.log(\"[useCategories] Hook rendered. GuildId: \".concat(guildId));\n    const [categories, setCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [expandedCategories, setExpandedCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [searchQuery, setSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const realtimeChannelRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadedGuildIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)('');\n    const initialLoadCompleteRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // --- Memoized Ladefunktion ---\n    const loadCategories = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[loadCategories]\": async (guildIdToLoad)=>{\n            if (!guildIdToLoad) return;\n            if (loading && loadedGuildIdRef.current === guildIdToLoad) return; // Verhindere paralleles Laden für dieselbe Guild\n            console.log(\"[useCategories] loadCategories: Loading for Guild: \".concat(guildIdToLoad));\n            setLoading(true);\n            setError(null);\n            initialLoadCompleteRef.current = false;\n            try {\n                const categoriesData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategories(shared_types__WEBPACK_IMPORTED_MODULE_5__.ScopeType.GUILD, guildIdToLoad);\n                const enhancedCategoriesPromises = categoriesData.map({\n                    \"useCategories.useCallback[loadCategories].enhancedCategoriesPromises\": async (category)=>{\n                        const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(category.id);\n                        const enhancedZones = zonesData.map(mapToEnhancedZone); // Helper verwenden\n                        return mapToEnhancedCategory(category, guildIdToLoad, enhancedZones); // Helper verwenden\n                    }\n                }[\"useCategories.useCallback[loadCategories].enhancedCategoriesPromises\"]);\n                const enhancedCategories = await Promise.all(enhancedCategoriesPromises);\n                setCategories(enhancedCategories);\n                loadedGuildIdRef.current = guildIdToLoad;\n                initialLoadCompleteRef.current = true;\n                console.log(\"[useCategories] loadCategories: \".concat(enhancedCategories.length, \" categories loaded for \").concat(guildIdToLoad));\n            } catch (err) {\n                console.error(\"[useCategories] Error loading categories for \".concat(guildIdToLoad, \":\"), err);\n                setError('Fehler beim Laden der Kategorien');\n                setCategories([]);\n                loadedGuildIdRef.current = guildIdToLoad;\n                initialLoadCompleteRef.current = true;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[loadCategories]\"], [\n        loading\n    ]); // Abhängig von loading\n    // --- Memoized Realtime Handler ---\n    const handleRealtimeEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[handleRealtimeEvent]\": (payload)=>{\n            console.log('[useCategories RAW EVENT]', payload);\n            const { eventType, new: newRecord, old: oldRecord, table, schema } = payload;\n            if (schema !== 'public') return; // Nur auf public Schema reagieren\n            const record = newRecord || oldRecord;\n            if (!record) return;\n            const affectedCategoryId = table === 'categories' ? record.id : record.category_id;\n            if (!affectedCategoryId) return;\n            // Prüfen, ob das Event zur aktuellen Guild gehört (wichtig!)\n            // Wir brauchen einen Weg, die guildId aus dem Payload zu bekommen oder anzunehmen, dass der Filter greift.\n            // Annahme: Filter funktioniert serverseitig, wir reagieren auf alles, was durchkommt.\n            console.log(\"[HANDLER CALLED] Table: \".concat(table, \", Event: \").concat(eventType, \", Affected Category: \").concat(affectedCategoryId));\n            if (table === 'categories') {\n                if (eventType === 'INSERT' && newRecord) {\n                    console.log(\"[Realtime] Category INSERT: \".concat(newRecord.id));\n                    const newCategory = mapToEnhancedCategory(newRecord, guildId, []); // Initial leere Zonen\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>{\n                            if (!prev.some({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newCategory.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])) {\n                                console.log(\"[Realtime INSERT] Adding new category to state:\", newCategory.name);\n                                return [\n                                    ...prev,\n                                    newCategory\n                                ];\n                            }\n                            console.log(\"[Realtime INSERT] Category already exists, likely race condition, ignoring.\");\n                            return prev; // Verhindere Duplikate\n                        }\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                    // Lade Zonen im Hintergrund nach\n                    _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(newRecord.id).then({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (zonesData)=>{\n                            const enhancedZones = zonesData.map(mapToEnhancedZone);\n                            setCategories({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                        \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newRecord.id ? {\n                                                ...c,\n                                                zones: enhancedZones\n                                            } : c\n                                    }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        }\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]).catch({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (err)=>console.error(\"[Realtime] Failed to fetch zones for new category \".concat(newRecord.id), err)\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                } else if (eventType === 'UPDATE' && newRecord) {\n                    console.log(\"[Realtime] Category UPDATE: \".concat(newRecord.id));\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === newRecord.id ? {\n                                        ...c,\n                                        name: newRecord.name,\n                                        isVisible: newRecord.is_visible_default,\n                                        sendSetup: newRecord.setup_flow_enabled,\n                                        trackingActive: newRecord.default_tracking_enabled,\n                                        setupTextChannel: newRecord.setup_channel_id,\n                                        waitingRoomName: newRecord.warteraum_channel_id,\n                                        discordCategoryId: newRecord.discord_category_id || null,\n                                        deletedInDiscord: !newRecord.discord_category_id,\n                                        updatedAt: new Date(newRecord.updated_at)\n                                    } : c\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                } else if (eventType === 'DELETE' && oldRecord) {\n                    console.log(\"[Realtime] Category DELETE: \".concat(oldRecord.id));\n                    setCategories({\n                        \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.filter({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id !== oldRecord.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                    }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                }\n            } else if (table === 'zones') {\n                console.log(\"[Realtime] Zone \".concat(eventType, \" for Category \").concat(affectedCategoryId));\n                // Effizienter: Zone direkt im State aktualisieren\n                setCategories({\n                    \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>{\n                        const categoryIndex = prev.findIndex({\n                            \"useCategories.useCallback[handleRealtimeEvent].categoryIndex\": (c)=>c.id === affectedCategoryId\n                        }[\"useCategories.useCallback[handleRealtimeEvent].categoryIndex\"]);\n                        if (categoryIndex === -1) return prev; // Kategorie nicht im State\n                        const currentCategory = prev[categoryIndex];\n                        let updatedZones = [\n                            ...currentCategory.zones\n                        ]; // Kopie erstellen\n                        if (eventType === 'INSERT' && newRecord) {\n                            const newZone = mapToEnhancedZone(newRecord);\n                            if (!updatedZones.some({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (z)=>z.id === newZone.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"])) {\n                                updatedZones.push(newZone);\n                            }\n                        } else if (eventType === 'UPDATE' && newRecord) {\n                            const updatedZone = mapToEnhancedZone(newRecord);\n                            updatedZones = updatedZones.map({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (z)=>z.id === updatedZone.id ? updatedZone : z\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        } else if (eventType === 'DELETE' && oldRecord) {\n                            updatedZones = updatedZones.filter({\n                                \"useCategories.useCallback[handleRealtimeEvent]\": (z)=>z.id !== oldRecord.id\n                            }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                        }\n                        const newState = [\n                            ...prev\n                        ];\n                        newState[categoryIndex] = {\n                            ...currentCategory,\n                            zones: updatedZones\n                        };\n                        return newState;\n                    }\n                }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n            } else if (table === 'category_discord_role_permissions') {\n                console.log(\"[Realtime] Roles \".concat(eventType, \" for Category \").concat(affectedCategoryId));\n                ({\n                    \"useCategories.useCallback[handleRealtimeEvent]\": async ()=>{\n                        try {\n                            const categoryData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryById(affectedCategoryId);\n                            if (categoryData) {\n                                setCategories({\n                                    \"useCategories.useCallback[handleRealtimeEvent]\": (prev)=>prev.map({\n                                            \"useCategories.useCallback[handleRealtimeEvent]\": (c)=>c.id === affectedCategoryId ? {\n                                                    ...c,\n                                                    allowedRoles: categoryData.allowedRoles || []\n                                                } : c\n                                        }[\"useCategories.useCallback[handleRealtimeEvent]\"])\n                                }[\"useCategories.useCallback[handleRealtimeEvent]\"]);\n                            }\n                        } catch (error) {\n                            console.error(\"[Realtime] Error refetching roles for category \".concat(affectedCategoryId, \":\"), error);\n                        }\n                    }\n                })[\"useCategories.useCallback[handleRealtimeEvent]\"]();\n            }\n        }\n    }[\"useCategories.useCallback[handleRealtimeEvent]\"], [\n        guildId,\n        setCategories\n    ]); // Abhängigkeiten korrekt setzen\n    // --- Haupt-useEffect für Laden und Subscription ---\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCategories.useEffect\": ()=>{\n            const currentGuildId = currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id;\n            console.log(\"[useCategories Effect] Running for guildId: \".concat(currentGuildId || 'none'));\n            if (!currentGuildId) {\n                console.log('[useCategories Effect] No guildId, resetting.');\n                setCategories([]);\n                loadedGuildIdRef.current = '';\n                initialLoadCompleteRef.current = false;\n                if (realtimeChannelRef.current) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(realtimeChannelRef.current);\n                    realtimeChannelRef.current = null;\n                }\n                return;\n            }\n            // Laden, wenn die Guild neu ist oder die Daten fehlen\n            if (loadedGuildIdRef.current !== currentGuildId) {\n                loadCategories(currentGuildId);\n            }\n            // Subscription Logik\n            let channel = realtimeChannelRef.current;\n            const channelName = \"categories:\".concat(currentGuildId);\n            if (!channel || channel.topic !== \"realtime:\".concat(channelName)) {\n                if (channel) _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(channel);\n                console.log(\"[useCategories Effect] Setting up channel: \".concat(channelName));\n                channel = _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.channel(channelName);\n                channel.on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'categories'\n                }, handleRealtimeEvent).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'zones'\n                }, handleRealtimeEvent).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'category_discord_role_permissions'\n                }, handleRealtimeEvent).subscribe({\n                    \"useCategories.useEffect\": (status, err)=>{\n                        console.log(\"[useCategories Effect] Sub status \".concat(channelName, \":\"), status, err || '');\n                        if (status === 'SUBSCRIBED') {\n                            realtimeChannelRef.current = channel;\n                            if (!initialLoadCompleteRef.current) {\n                                console.log('[useCategories Effect] Re-fetching data after successful subscription.');\n                                loadCategories(currentGuildId);\n                            }\n                        } else {\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }[\"useCategories.useEffect\"]);\n            } else {\n                console.log(\"[useCategories Effect] Already subscribed to \".concat(channelName));\n            }\n            // Cleanup\n            return(({\n                \"useCategories.useEffect\": ()=>{\n                    console.log(\"[useCategories Effect] Cleanup for guildId: \".concat(currentGuildId));\n                    // WICHTIG: Nur den Channel entfernen, wenn er noch aktuell ist!\n                    // Wenn der Effekt wegen Guild-Wechsel neu läuft, wurde der alte Channel evtl. schon entfernt.\n                    const currentChannel = realtimeChannelRef.current;\n                    if (currentChannel && currentChannel.topic === \"realtime:\".concat(channelName)) {\n                        console.log(\"[useCategories Effect] Removing channel \".concat(currentChannel.topic));\n                        _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(currentChannel);\n                        realtimeChannelRef.current = null;\n                    }\n                }\n            })[\"useCategories.useEffect\"]);\n        }\n    }[\"useCategories.useEffect\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories,\n        handleRealtimeEvent\n    ]);\n    // --- Restliche Funktionen (angepasst) ---\n    const toggleCategoryExpand = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[toggleCategoryExpand]\": (categoryId)=>{\n            setExpandedCategories({\n                \"useCategories.useCallback[toggleCategoryExpand]\": (prev)=>prev.includes(categoryId) ? prev.filter({\n                        \"useCategories.useCallback[toggleCategoryExpand]\": (id)=>id !== categoryId\n                    }[\"useCategories.useCallback[toggleCategoryExpand]\"]) : [\n                        ...prev,\n                        categoryId\n                    ]\n            }[\"useCategories.useCallback[toggleCategoryExpand]\"]);\n        }\n    }[\"useCategories.useCallback[toggleCategoryExpand]\"], []);\n    const saveCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[saveCategory]\": async (categoryData)=>{\n            if (!guildId) {\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error('Keine Guild ausgewählt');\n                return false;\n            }\n            setLoading(true);\n            try {\n                if (categoryData.id) {\n                    const updateData = {};\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.updateCategory(categoryData.id, updateData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie aktualisiert');\n                } else {\n                    const createData = {};\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.createCategory(createData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie erstellt');\n                }\n                // Realtime sollte State aktualisieren\n                return true;\n            } catch (err) {\n                return false;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[saveCategory]\"], [\n        guildId\n    ]); // Abhängigkeit von guildId\n    const deleteCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[deleteCategory]\": async (categoryId)=>{\n            setLoading(true);\n            try {\n                const result = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.deleteCategory(categoryId);\n                if (result.success) _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie gelöscht.');\n                // Realtime sollte State aktualisieren\n                return result;\n            } catch (err) {\n                return {\n                    success: false,\n                    message: 'Fehler'\n                };\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[deleteCategory]\"], []);\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[refetch]\": ()=>{\n            console.log('[useCategories] refetch triggered');\n            if (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) {\n                loadedGuildIdRef.current = '';\n                initialLoadCompleteRef.current = false;\n                loadCategories(currentGuild.id);\n            }\n        }\n    }[\"useCategories.useCallback[refetch]\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories\n    ]);\n    const getTotalStats = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[getTotalStats]\": ()=>({\n                totalCategories: categories.length,\n                totalUsers: categories.reduce({\n                    \"useCategories.useCallback[getTotalStats]\": (sum, c)=>sum + c.totalUsers\n                }[\"useCategories.useCallback[getTotalStats]\"], 0),\n                totalTime: categories.reduce({\n                    \"useCategories.useCallback[getTotalStats]\": (sum, c)=>sum + c.totalTimeSpent\n                }[\"useCategories.useCallback[getTotalStats]\"], 0)\n            })\n    }[\"useCategories.useCallback[getTotalStats]\"], [\n        categories\n    ]);\n    return {\n        categories,\n        loading,\n        error,\n        expandedCategories,\n        searchQuery,\n        setSearchQuery,\n        toggleCategoryExpand,\n        saveCategory,\n        deleteCategory,\n        getTotalStats,\n        refetch\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9jYXRlZ29yeS1tYW5hZ2VtZW50L2hvb2tzL3VzZUNhdGVnb3JpZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O21FQUVpRTtBQUNmLENBQUMscUJBQXFCO0FBQ3JCO0FBQ1E7QUFDVjtBQUNvRCxDQUFDLHNCQUFzQjtBQUVsRjtBQTZDMUMsZ0RBQWdEO0FBQ2hELE1BQU1VLG9CQUFvQixDQUFDQyxPQUFpQztRQUN4REMsSUFBSUQsS0FBS0MsRUFBRTtRQUNYQyxNQUFNRixLQUFLRSxJQUFJO1FBQ2ZDLFNBQVNILEtBQUtHLE9BQU87UUFDckJDLGlCQUFpQkosS0FBS0ssZUFBZTtRQUNyQ0MsZUFBZU4sS0FBS08saUJBQWlCO1FBQ3JDQyxZQUFZO1FBQUtDLGdCQUFnQjtRQUFHQyxZQUFZLEVBQUUsY0FBYztJQUNwRTtBQUVBLHlEQUF5RDtBQUN6RCxNQUFNQyx3QkFBd0IsQ0FBQ0MsVUFBdUJDLFNBQWlCQyxRQUE2QztRQUNoSGIsSUFBSVcsU0FBU1gsRUFBRTtRQUNmQyxNQUFNVSxTQUFTVixJQUFJO1FBQ25CYSxVQUFVRjtRQUNWRyxjQUFjSixTQUFTSSxZQUFZLElBQUksRUFBRTtRQUN6Q0MsV0FBV0wsU0FBU00sZ0JBQWdCO1FBQ3BDQyxXQUFXUCxTQUFTUSxnQkFBZ0I7UUFDcENDLGdCQUFnQlQsU0FBU1Usc0JBQXNCO1FBQy9DQyxrQkFBa0JYLFNBQVNZLGNBQWM7UUFDekNDLGlCQUFpQmIsU0FBU2Msa0JBQWtCO1FBQzVDbEIsWUFBWTtRQUFLQyxnQkFBZ0I7UUFBR0MsWUFBWTtRQUNoRGlCLG1CQUFtQmYsU0FBU2UsaUJBQWlCLElBQUk7UUFDakRDLGtCQUFrQixDQUFDaEIsU0FBU2UsaUJBQWlCO1FBQzdDRSxXQUFXLElBQUlDLEtBQUtsQixTQUFTaUIsU0FBUztRQUN0Q0UsV0FBVyxJQUFJRCxLQUFLbEIsU0FBU21CLFNBQVM7UUFDdENqQixPQUFPQTtJQUNY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LE9BQU9JO1lBQ1QsRUFBRSxPQUFPMUQsS0FBVTtnQkFBdUIsT0FBTztvQkFBRXNELFNBQVM7b0JBQU9LLFNBQVM7Z0JBQVM7WUFBRyxTQUNoRjtnQkFBRWhGLFdBQVc7WUFBUTtRQUNoQztvREFBRyxFQUFFO0lBRUwsTUFBTWlGLFVBQVVySSxrREFBV0E7OENBQUM7WUFDMUIyQyxRQUFRQyxHQUFHLENBQUM7WUFDWixJQUFJRix5QkFBQUEsbUNBQUFBLGFBQWNoQyxFQUFFLEVBQUU7Z0JBQ3BCOEMsaUJBQWlCSSxPQUFPLEdBQUc7Z0JBQzNCSCx1QkFBdUJHLE9BQU8sR0FBRztnQkFDakNGLGVBQWVoQixhQUFhaEMsRUFBRTtZQUNoQztRQUNGOzZDQUFHO1FBQUNnQyx5QkFBQUEsbUNBQUFBLGFBQWNoQyxFQUFFO1FBQUVnRDtLQUFlO0lBRXJDLE1BQU00RSxnQkFBZ0J0SSxrREFBV0E7b0RBQUMsSUFBTztnQkFDdkN1SSxpQkFBaUIxRixXQUFXMkIsTUFBTTtnQkFDbENyRCxZQUFZMEIsV0FBVzJGLE1BQU07Z0VBQUMsQ0FBQ0MsS0FBS2hELElBQU1nRCxNQUFNaEQsRUFBRXRFLFVBQVU7K0RBQUU7Z0JBQzlEdUgsV0FBVzdGLFdBQVcyRixNQUFNO2dFQUFDLENBQUNDLEtBQUtoRCxJQUFNZ0QsTUFBTWhELEVBQUV2RSxjQUFjOytEQUFFO1lBQ25FO21EQUFJO1FBQUMyQjtLQUFXO0lBRWhCLE9BQU87UUFDTEE7UUFBWU07UUFBU0U7UUFBT047UUFBb0JFO1FBQ2hEQztRQUFnQnVFO1FBQXNCRztRQUFjTTtRQUNwREk7UUFBZUQ7SUFDakI7QUFDRixFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGluZm9cXERvY3VtZW50c1xcRGlzY29yZCBCb3RcXENoaW1lcmFcXGFwcHNcXGZyb250ZW5kXFxzcmNcXGNvbXBvbmVudHNcXGRhc2hib2FyZFxcY2F0ZWdvcnktbWFuYWdlbWVudFxcaG9va3NcXHVzZUNhdGVnb3JpZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdG9hc3QgfSBmcm9tICdAL2NvbXBvbmVudHMvY29yZS90b2FzdGVyJzsgLy8gSW1wb3J0IGhpbnp1Z2Vmw7xndFxuaW1wb3J0IHsgdXNlR3VpbGQgfSBmcm9tICdAL2NvbnRleHQvZ3VpbGQtY29udGV4dCc7XG5pbXBvcnQgKiBhcyBjYXRlZ29yaWVzU2VydmljZSBmcm9tICdAL3NlcnZpY2VzL2NhdGVnb3JpZXMnO1xuaW1wb3J0ICogYXMgem9uZXNTZXJ2aWNlIGZyb20gJ0Avc2VydmljZXMvem9uZXMnO1xuaW1wb3J0IHsgQ3JlYXRlQ2F0ZWdvcnlEdG8sIFVwZGF0ZUNhdGVnb3J5RHRvLCBTY29wZVR5cGUsIENhdGVnb3J5RHRvLCBab25lRHRvIH0gZnJvbSAnc2hhcmVkLXR5cGVzJzsgLy8gWm9uZUR0byBoaW56dWdlZsO8Z3RcbmltcG9ydCB7IFJlYWx0aW1lQ2hhbm5lbCwgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkIH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuXG4vLyBJbnRlcmZhY2VzIGpldHp0IGV4cG9ydGllcmVuXG5leHBvcnQgaW50ZXJmYWNlIEVuaGFuY2VkQ2F0ZWdvcnkge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGd1aWxkX2lkOiBzdHJpbmc7XG4gIGFsbG93ZWRSb2xlczogc3RyaW5nW107XG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgc2VuZFNldHVwOiBib29sZWFuO1xuICB0cmFja2luZ0FjdGl2ZTogYm9vbGVhbjtcbiAgc2V0dXBUZXh0Q2hhbm5lbD86IHN0cmluZyB8IG51bGw7XG4gIHdhaXRpbmdSb29tTmFtZT86IHN0cmluZyB8IG51bGw7XG4gIGxhc3RBY3RpdmU6IHN0cmluZztcbiAgdG90YWxUaW1lU3BlbnQ6IG51bWJlcjtcbiAgdG90YWxVc2VyczogbnVtYmVyO1xuICBkaXNjb3JkQ2F0ZWdvcnlJZDogc3RyaW5nIHwgbnVsbDtcbiAgZGVsZXRlZEluRGlzY29yZDogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICB1cGRhdGVkQXQ6IERhdGU7XG4gIHpvbmVzOiBFbmhhbmNlZFpvbmVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbmhhbmNlZFpvbmUge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHpvbmVLZXk6IHN0cmluZztcbiAgbWludXRlc1JlcXVpcmVkOiBudW1iZXI7XG4gIHBvaW50c0dyYW50ZWQ6IG51bWJlcjtcbiAgbGFzdEFjdGl2ZTogc3RyaW5nO1xuICB0b3RhbFRpbWVTcGVudDogbnVtYmVyO1xuICB0b3RhbFVzZXJzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcnlJbnB1dCB7XG4gIGlkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFsbG93ZWRSb2xlczogc3RyaW5nW107XG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgc2VuZFNldHVwOiBib29sZWFuO1xuICB0cmFja2luZ0FjdGl2ZTogYm9vbGVhbjtcbiAgc2V0dXBUZXh0Q2hhbm5lbD86IHN0cmluZyB8IG51bGw7XG4gIHdhaXRpbmdSb29tTmFtZT86IHN0cmluZyB8IG51bGw7XG59XG5cbi8vIEhlbHBlciB6dW0gTWFwcGVuIHZvbiBEQi1ab25lIHp1IEVuaGFuY2VkWm9uZVxuY29uc3QgbWFwVG9FbmhhbmNlZFpvbmUgPSAoem9uZTogWm9uZUR0byk6IEVuaGFuY2VkWm9uZSA9PiAoe1xuICAgIGlkOiB6b25lLmlkLFxuICAgIG5hbWU6IHpvbmUubmFtZSxcbiAgICB6b25lS2V5OiB6b25lLnpvbmVLZXksXG4gICAgbWludXRlc1JlcXVpcmVkOiB6b25lLmludGVydmFsTWludXRlcyxcbiAgICBwb2ludHNHcmFudGVkOiB6b25lLnBvaW50c1BlckludGVydmFsLFxuICAgIGxhc3RBY3RpdmU6ICctJywgdG90YWxUaW1lU3BlbnQ6IDAsIHRvdGFsVXNlcnM6IDAgLy8gUGxhY2Vob2xkZXJcbn0pO1xuXG4vLyBIZWxwZXIgenVtIE1hcHBlbiB2b24gREItS2F0ZWdvcmllIHp1IEVuaGFuY2VkQ2F0ZWdvcnlcbmNvbnN0IG1hcFRvRW5oYW5jZWRDYXRlZ29yeSA9IChjYXRlZ29yeTogQ2F0ZWdvcnlEdG8sIGd1aWxkSWQ6IHN0cmluZywgem9uZXM6IEVuaGFuY2VkWm9uZVtdKTogRW5oYW5jZWRDYXRlZ29yeSA9PiAoe1xuICAgIGlkOiBjYXRlZ29yeS5pZCxcbiAgICBuYW1lOiBjYXRlZ29yeS5uYW1lLFxuICAgIGd1aWxkX2lkOiBndWlsZElkLFxuICAgIGFsbG93ZWRSb2xlczogY2F0ZWdvcnkuYWxsb3dlZFJvbGVzIHx8IFtdLFxuICAgIGlzVmlzaWJsZTogY2F0ZWdvcnkuaXNWaXNpYmxlRGVmYXVsdCxcbiAgICBzZW5kU2V0dXA6IGNhdGVnb3J5LnNldHVwRmxvd0VuYWJsZWQsXG4gICAgdHJhY2tpbmdBY3RpdmU6IGNhdGVnb3J5LmRlZmF1bHRUcmFja2luZ0VuYWJsZWQsXG4gICAgc2V0dXBUZXh0Q2hhbm5lbDogY2F0ZWdvcnkuc2V0dXBDaGFubmVsSWQsXG4gICAgd2FpdGluZ1Jvb21OYW1lOiBjYXRlZ29yeS53YXJ0ZXJhdW1DaGFubmVsSWQsXG4gICAgbGFzdEFjdGl2ZTogJy0nLCB0b3RhbFRpbWVTcGVudDogMCwgdG90YWxVc2VyczogMCwgLy8gUGxhY2Vob2xkZXJzXG4gICAgZGlzY29yZENhdGVnb3J5SWQ6IGNhdGVnb3J5LmRpc2NvcmRDYXRlZ29yeUlkIHx8IG51bGwsXG4gICAgZGVsZXRlZEluRGlzY29yZDogIWNhdGVnb3J5LmRpc2NvcmRDYXRlZ29yeUlkLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoY2F0ZWdvcnkuY3JlYXRlZEF0KSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKGNhdGVnb3J5LnVwZGF0ZWRBdCksXG4gICAgem9uZXM6IHpvbmVzXG59KTtcblxuXG5leHBvcnQgY29uc3QgdXNlQ2F0ZWdvcmllcyA9ICgpID0+IHtcbiAgY29uc3QgeyBjdXJyZW50R3VpbGQgfSA9IHVzZUd1aWxkKCk7XG4gIGNvbnN0IGd1aWxkSWQgPSBjdXJyZW50R3VpbGQ/LmlkIHx8ICcnO1xuICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXNdIEhvb2sgcmVuZGVyZWQuIEd1aWxkSWQ6ICR7Z3VpbGRJZH1gKTtcblxuICBjb25zdCBbY2F0ZWdvcmllcywgc2V0Q2F0ZWdvcmllc10gPSB1c2VTdGF0ZTxFbmhhbmNlZENhdGVnb3J5W10+KFtdKTtcbiAgY29uc3QgW2V4cGFuZGVkQ2F0ZWdvcmllcywgc2V0RXhwYW5kZWRDYXRlZ29yaWVzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gIGNvbnN0IFtzZWFyY2hRdWVyeSwgc2V0U2VhcmNoUXVlcnldID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlYWx0aW1lQ2hhbm5lbFJlZiA9IHVzZVJlZjxSZWFsdGltZUNoYW5uZWwgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbG9hZGVkR3VpbGRJZFJlZiA9IHVzZVJlZjxzdHJpbmc+KCcnKTtcbiAgY29uc3QgaW5pdGlhbExvYWRDb21wbGV0ZVJlZiA9IHVzZVJlZihmYWxzZSk7XG5cbiAgLy8gLS0tIE1lbW9pemVkIExhZGVmdW5rdGlvbiAtLS1cbiAgY29uc3QgbG9hZENhdGVnb3JpZXMgPSB1c2VDYWxsYmFjayhhc3luYyAoZ3VpbGRJZFRvTG9hZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFndWlsZElkVG9Mb2FkKSByZXR1cm47XG4gICAgaWYgKGxvYWRpbmcgJiYgbG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ID09PSBndWlsZElkVG9Mb2FkKSByZXR1cm47IC8vIFZlcmhpbmRlcmUgcGFyYWxsZWxlcyBMYWRlbiBmw7xyIGRpZXNlbGJlIEd1aWxkXG5cbiAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXNdIGxvYWRDYXRlZ29yaWVzOiBMb2FkaW5nIGZvciBHdWlsZDogJHtndWlsZElkVG9Mb2FkfWApO1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2F0ZWdvcmllc0RhdGEgPSBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5nZXRDYXRlZ29yaWVzKFNjb3BlVHlwZS5HVUlMRCwgZ3VpbGRJZFRvTG9hZCk7XG4gICAgICBjb25zdCBlbmhhbmNlZENhdGVnb3JpZXNQcm9taXNlcyA9IGNhdGVnb3JpZXNEYXRhLm1hcChhc3luYyAoY2F0ZWdvcnkpID0+IHtcbiAgICAgICAgY29uc3Qgem9uZXNEYXRhID0gYXdhaXQgem9uZXNTZXJ2aWNlLmdldFpvbmVzQnlDYXRlZ29yeShjYXRlZ29yeS5pZCk7XG4gICAgICAgIGNvbnN0IGVuaGFuY2VkWm9uZXMgPSB6b25lc0RhdGEubWFwKG1hcFRvRW5oYW5jZWRab25lKTsgLy8gSGVscGVyIHZlcndlbmRlblxuICAgICAgICByZXR1cm4gbWFwVG9FbmhhbmNlZENhdGVnb3J5KGNhdGVnb3J5LCBndWlsZElkVG9Mb2FkLCBlbmhhbmNlZFpvbmVzKTsgLy8gSGVscGVyIHZlcndlbmRlblxuICAgICAgfSk7XG4gICAgICBjb25zdCBlbmhhbmNlZENhdGVnb3JpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChlbmhhbmNlZENhdGVnb3JpZXNQcm9taXNlcyk7XG5cbiAgICAgIHNldENhdGVnb3JpZXMoZW5oYW5jZWRDYXRlZ29yaWVzKTtcbiAgICAgIGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCA9IGd1aWxkSWRUb0xvYWQ7XG4gICAgICBpbml0aWFsTG9hZENvbXBsZXRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzXSBsb2FkQ2F0ZWdvcmllczogJHtlbmhhbmNlZENhdGVnb3JpZXMubGVuZ3RofSBjYXRlZ29yaWVzIGxvYWRlZCBmb3IgJHtndWlsZElkVG9Mb2FkfWApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgW3VzZUNhdGVnb3JpZXNdIEVycm9yIGxvYWRpbmcgY2F0ZWdvcmllcyBmb3IgJHtndWlsZElkVG9Mb2FkfTpgLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoJ0ZlaGxlciBiZWltIExhZGVuIGRlciBLYXRlZ29yaWVuJyk7XG4gICAgICBzZXRDYXRlZ29yaWVzKFtdKTtcbiAgICAgIGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCA9IGd1aWxkSWRUb0xvYWQ7XG4gICAgICBpbml0aWFsTG9hZENvbXBsZXRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtsb2FkaW5nXSk7IC8vIEFiaMOkbmdpZyB2b24gbG9hZGluZ1xuXG4gIC8vIC0tLSBNZW1vaXplZCBSZWFsdGltZSBIYW5kbGVyIC0tLVxuICBjb25zdCBoYW5kbGVSZWFsdGltZUV2ZW50ID0gdXNlQ2FsbGJhY2soKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZDxhbnk+KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIFJBVyBFVkVOVF0nLCBwYXlsb2FkKTtcbiAgICBjb25zdCB7IGV2ZW50VHlwZSwgbmV3OiBuZXdSZWNvcmQsIG9sZDogb2xkUmVjb3JkLCB0YWJsZSwgc2NoZW1hIH0gPSBwYXlsb2FkO1xuXG4gICAgaWYgKHNjaGVtYSAhPT0gJ3B1YmxpYycpIHJldHVybjsgLy8gTnVyIGF1ZiBwdWJsaWMgU2NoZW1hIHJlYWdpZXJlblxuXG4gICAgY29uc3QgcmVjb3JkID0gbmV3UmVjb3JkIHx8IG9sZFJlY29yZDtcbiAgICBpZiAoIXJlY29yZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgYWZmZWN0ZWRDYXRlZ29yeUlkID0gdGFibGUgPT09ICdjYXRlZ29yaWVzJyA/IHJlY29yZC5pZCA6IChyZWNvcmQgYXMgYW55KS5jYXRlZ29yeV9pZDtcbiAgICBpZiAoIWFmZmVjdGVkQ2F0ZWdvcnlJZCkgcmV0dXJuO1xuXG4gICAgLy8gUHLDvGZlbiwgb2IgZGFzIEV2ZW50IHp1ciBha3R1ZWxsZW4gR3VpbGQgZ2Vow7ZydCAod2ljaHRpZyEpXG4gICAgLy8gV2lyIGJyYXVjaGVuIGVpbmVuIFdlZywgZGllIGd1aWxkSWQgYXVzIGRlbSBQYXlsb2FkIHp1IGJla29tbWVuIG9kZXIgYW56dW5laG1lbiwgZGFzcyBkZXIgRmlsdGVyIGdyZWlmdC5cbiAgICAvLyBBbm5haG1lOiBGaWx0ZXIgZnVua3Rpb25pZXJ0IHNlcnZlcnNlaXRpZywgd2lyIHJlYWdpZXJlbiBhdWYgYWxsZXMsIHdhcyBkdXJjaGtvbW10LlxuXG4gICAgY29uc29sZS5sb2coYFtIQU5ETEVSIENBTExFRF0gVGFibGU6ICR7dGFibGV9LCBFdmVudDogJHtldmVudFR5cGV9LCBBZmZlY3RlZCBDYXRlZ29yeTogJHthZmZlY3RlZENhdGVnb3J5SWR9YCk7XG5cbiAgICBpZiAodGFibGUgPT09ICdjYXRlZ29yaWVzJykge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ0lOU0VSVCcgJiYgbmV3UmVjb3JkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbUmVhbHRpbWVdIENhdGVnb3J5IElOU0VSVDogJHtuZXdSZWNvcmQuaWR9YCk7XG4gICAgICAgIGNvbnN0IG5ld0NhdGVnb3J5ID0gbWFwVG9FbmhhbmNlZENhdGVnb3J5KG5ld1JlY29yZCBhcyBDYXRlZ29yeUR0bywgZ3VpbGRJZCwgW10pOyAvLyBJbml0aWFsIGxlZXJlIFpvbmVuXG4gICAgICAgIHNldENhdGVnb3JpZXMocHJldiA9PiB7XG4gICAgICAgICAgICAgaWYgKCFwcmV2LnNvbWUoYyA9PiBjLmlkID09PSBuZXdDYXRlZ29yeS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1JlYWx0aW1lIElOU0VSVF0gQWRkaW5nIG5ldyBjYXRlZ29yeSB0byBzdGF0ZTpcIiwgbmV3Q2F0ZWdvcnkubmFtZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIG5ld0NhdGVnb3J5XTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmVhbHRpbWUgSU5TRVJUXSBDYXRlZ29yeSBhbHJlYWR5IGV4aXN0cywgbGlrZWx5IHJhY2UgY29uZGl0aW9uLCBpZ25vcmluZy5cIik7XG4gICAgICAgICAgICAgcmV0dXJuIHByZXY7IC8vIFZlcmhpbmRlcmUgRHVwbGlrYXRlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBMYWRlIFpvbmVuIGltIEhpbnRlcmdydW5kIG5hY2hcbiAgICAgICAgem9uZXNTZXJ2aWNlLmdldFpvbmVzQnlDYXRlZ29yeShuZXdSZWNvcmQuaWQpLnRoZW4oem9uZXNEYXRhID0+IHtcbiAgICAgICAgICAgICBjb25zdCBlbmhhbmNlZFpvbmVzID0gem9uZXNEYXRhLm1hcChtYXBUb0VuaGFuY2VkWm9uZSk7XG4gICAgICAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gbmV3UmVjb3JkLmlkID8gey4uLmMsIHpvbmVzOiBlbmhhbmNlZFpvbmVzfSA6IGMpKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYFtSZWFsdGltZV0gRmFpbGVkIHRvIGZldGNoIHpvbmVzIGZvciBuZXcgY2F0ZWdvcnkgJHtuZXdSZWNvcmQuaWR9YCwgZXJyKSk7XG5cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAnVVBEQVRFJyAmJiBuZXdSZWNvcmQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtSZWFsdGltZV0gQ2F0ZWdvcnkgVVBEQVRFOiAke25ld1JlY29yZC5pZH1gKTtcbiAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gbmV3UmVjb3JkLmlkID8ge1xuICAgICAgICAgIC4uLmMsIC8vIFdpY2h0aWc6IEJlaGFsdGUgYmVzdGVoZW5kZSBab25lbiB1bmQgUm9sbGVuIGJlaSFcbiAgICAgICAgICBuYW1lOiBuZXdSZWNvcmQubmFtZSxcbiAgICAgICAgICBpc1Zpc2libGU6IG5ld1JlY29yZC5pc192aXNpYmxlX2RlZmF1bHQsXG4gICAgICAgICAgc2VuZFNldHVwOiBuZXdSZWNvcmQuc2V0dXBfZmxvd19lbmFibGVkLFxuICAgICAgICAgIHRyYWNraW5nQWN0aXZlOiBuZXdSZWNvcmQuZGVmYXVsdF90cmFja2luZ19lbmFibGVkLFxuICAgICAgICAgIHNldHVwVGV4dENoYW5uZWw6IG5ld1JlY29yZC5zZXR1cF9jaGFubmVsX2lkLFxuICAgICAgICAgIHdhaXRpbmdSb29tTmFtZTogbmV3UmVjb3JkLndhcnRlcmF1bV9jaGFubmVsX2lkLFxuICAgICAgICAgIGRpc2NvcmRDYXRlZ29yeUlkOiBuZXdSZWNvcmQuZGlzY29yZF9jYXRlZ29yeV9pZCB8fCBudWxsLFxuICAgICAgICAgIGRlbGV0ZWRJbkRpc2NvcmQ6ICFuZXdSZWNvcmQuZGlzY29yZF9jYXRlZ29yeV9pZCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKG5ld1JlY29yZC51cGRhdGVkX2F0KVxuICAgICAgICB9IDogYykpO1xuICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdERUxFVEUnICYmIG9sZFJlY29yZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW1JlYWx0aW1lXSBDYXRlZ29yeSBERUxFVEU6ICR7b2xkUmVjb3JkLmlkfWApO1xuICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4gcHJldi5maWx0ZXIoYyA9PiBjLmlkICE9PSBvbGRSZWNvcmQuaWQpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAnem9uZXMnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbUmVhbHRpbWVdIFpvbmUgJHtldmVudFR5cGV9IGZvciBDYXRlZ29yeSAke2FmZmVjdGVkQ2F0ZWdvcnlJZH1gKTtcbiAgICAgICAgLy8gRWZmaXppZW50ZXI6IFpvbmUgZGlyZWt0IGltIFN0YXRlIGFrdHVhbGlzaWVyZW5cbiAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5SW5kZXggPSBwcmV2LmZpbmRJbmRleChjID0+IGMuaWQgPT09IGFmZmVjdGVkQ2F0ZWdvcnlJZCk7XG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnlJbmRleCA9PT0gLTEpIHJldHVybiBwcmV2OyAvLyBLYXRlZ29yaWUgbmljaHQgaW0gU3RhdGVcblxuICAgICAgICAgICAgY29uc3QgY3VycmVudENhdGVnb3J5ID0gcHJldltjYXRlZ29yeUluZGV4XTtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkWm9uZXMgPSBbLi4uY3VycmVudENhdGVnb3J5LnpvbmVzXTsgLy8gS29waWUgZXJzdGVsbGVuXG5cbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09ICdJTlNFUlQnICYmIG5ld1JlY29yZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1pvbmUgPSBtYXBUb0VuaGFuY2VkWm9uZShuZXdSZWNvcmQgYXMgWm9uZUR0byk7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkWm9uZXMuc29tZSh6ID0+IHouaWQgPT09IG5ld1pvbmUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRab25lcy5wdXNoKG5ld1pvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAnVVBEQVRFJyAmJiBuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkWm9uZSA9IG1hcFRvRW5oYW5jZWRab25lKG5ld1JlY29yZCBhcyBab25lRHRvKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkWm9uZXMgPSB1cGRhdGVkWm9uZXMubWFwKHogPT4gei5pZCA9PT0gdXBkYXRlZFpvbmUuaWQgPyB1cGRhdGVkWm9uZSA6IHopO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdERUxFVEUnICYmIG9sZFJlY29yZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRab25lcyA9IHVwZGF0ZWRab25lcy5maWx0ZXIoeiA9PiB6LmlkICE9PSBvbGRSZWNvcmQuaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IFsuLi5wcmV2XTtcbiAgICAgICAgICAgIG5ld1N0YXRlW2NhdGVnb3J5SW5kZXhdID0geyAuLi5jdXJyZW50Q2F0ZWdvcnksIHpvbmVzOiB1cGRhdGVkWm9uZXMgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAnY2F0ZWdvcnlfZGlzY29yZF9yb2xlX3Blcm1pc3Npb25zJykge1xuICAgICAgICBjb25zb2xlLmxvZyhgW1JlYWx0aW1lXSBSb2xlcyAke2V2ZW50VHlwZX0gZm9yIENhdGVnb3J5ICR7YWZmZWN0ZWRDYXRlZ29yeUlkfWApO1xuICAgICAgICAgLy8gTGFkZSBudXIgZGllIGJldHJvZmZlbmUgS2F0ZWdvcmllIG5ldSwgdW0gZGllIFJvbGxlbiB6dSBha3R1YWxpc2llcmVuXG4gICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yeURhdGEgPSBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5nZXRDYXRlZ29yeUJ5SWQoYWZmZWN0ZWRDYXRlZ29yeUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnlEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBhZmZlY3RlZENhdGVnb3J5SWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyAuLi5jLCBhbGxvd2VkUm9sZXM6IGNhdGVnb3J5RGF0YS5hbGxvd2VkUm9sZXMgfHwgW10gfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjXG4gICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbUmVhbHRpbWVdIEVycm9yIHJlZmV0Y2hpbmcgcm9sZXMgZm9yIGNhdGVnb3J5ICR7YWZmZWN0ZWRDYXRlZ29yeUlkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9KSgpO1xuICAgIH1cbiAgfSwgW2d1aWxkSWQsIHNldENhdGVnb3JpZXNdKTsgLy8gQWJow6RuZ2lna2VpdGVuIGtvcnJla3Qgc2V0emVuXG5cbiAgLy8gLS0tIEhhdXB0LXVzZUVmZmVjdCBmw7xyIExhZGVuIHVuZCBTdWJzY3JpcHRpb24gLS0tXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudEd1aWxkSWQgPSBjdXJyZW50R3VpbGQ/LmlkO1xuICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIFJ1bm5pbmcgZm9yIGd1aWxkSWQ6ICR7Y3VycmVudEd1aWxkSWQgfHwgJ25vbmUnfWApO1xuXG4gICAgaWYgKCFjdXJyZW50R3VpbGRJZCkge1xuICAgICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIEVmZmVjdF0gTm8gZ3VpbGRJZCwgcmVzZXR0aW5nLicpO1xuICAgICAgc2V0Q2F0ZWdvcmllcyhbXSk7XG4gICAgICBsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgIGluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgaWYgKHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwocmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQpO1xuICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTGFkZW4sIHdlbm4gZGllIEd1aWxkIG5ldSBpc3Qgb2RlciBkaWUgRGF0ZW4gZmVobGVuXG4gICAgaWYgKGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCAhPT0gY3VycmVudEd1aWxkSWQpIHtcbiAgICAgIGxvYWRDYXRlZ29yaWVzKGN1cnJlbnRHdWlsZElkKTtcbiAgICB9XG5cbiAgICAvLyBTdWJzY3JpcHRpb24gTG9naWtcbiAgICBsZXQgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsIHwgbnVsbCA9IHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYGNhdGVnb3JpZXM6JHtjdXJyZW50R3VpbGRJZH1gO1xuXG4gICAgaWYgKCFjaGFubmVsIHx8IGNoYW5uZWwudG9waWMgIT09IGByZWFsdGltZToke2NoYW5uZWxOYW1lfWApIHtcbiAgICAgIGlmIChjaGFubmVsKSBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpO1xuXG4gICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBTZXR0aW5nIHVwIGNoYW5uZWw6ICR7Y2hhbm5lbE5hbWV9YCk7XG4gICAgICBjaGFubmVsID0gc3VwYWJhc2UuY2hhbm5lbChjaGFubmVsTmFtZSk7XG4gICAgICBjaGFubmVsXG4gICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjYXRlZ29yaWVzJyB9LCBoYW5kbGVSZWFsdGltZUV2ZW50KVxuICAgICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnem9uZXMnIH0sIGhhbmRsZVJlYWx0aW1lRXZlbnQpXG4gICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjYXRlZ29yeV9kaXNjb3JkX3JvbGVfcGVybWlzc2lvbnMnIH0sIGhhbmRsZVJlYWx0aW1lRXZlbnQpXG4gICAgICAgIC5zdWJzY3JpYmUoKHN0YXR1cywgZXJyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIEVmZmVjdF0gU3ViIHN0YXR1cyAke2NoYW5uZWxOYW1lfTpgLCBzdGF0dXMsIGVyciB8fCAnJyk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ1NVQlNDUklCRUQnKSB7XG4gICAgICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IGNoYW5uZWw7XG4gICAgICAgICAgICBpZiAoIWluaXRpYWxMb2FkQ29tcGxldGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBSZS1mZXRjaGluZyBkYXRhIGFmdGVyIHN1Y2Nlc3NmdWwgc3Vic2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgICBsb2FkQ2F0ZWdvcmllcyhjdXJyZW50R3VpbGRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBBbHJlYWR5IHN1YnNjcmliZWQgdG8gJHtjaGFubmVsTmFtZX1gKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIENsZWFudXAgZm9yIGd1aWxkSWQ6ICR7Y3VycmVudEd1aWxkSWR9YCk7XG4gICAgICAvLyBXSUNIVElHOiBOdXIgZGVuIENoYW5uZWwgZW50ZmVybmVuLCB3ZW5uIGVyIG5vY2ggYWt0dWVsbCBpc3QhXG4gICAgICAvLyBXZW5uIGRlciBFZmZla3Qgd2VnZW4gR3VpbGQtV2VjaHNlbCBuZXUgbMOkdWZ0LCB3dXJkZSBkZXIgYWx0ZSBDaGFubmVsIGV2dGwuIHNjaG9uIGVudGZlcm50LlxuICAgICAgY29uc3QgY3VycmVudENoYW5uZWwgPSByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudDtcbiAgICAgIGlmIChjdXJyZW50Q2hhbm5lbCAmJiBjdXJyZW50Q2hhbm5lbC50b3BpYyA9PT0gYHJlYWx0aW1lOiR7Y2hhbm5lbE5hbWV9YCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBSZW1vdmluZyBjaGFubmVsICR7Y3VycmVudENoYW5uZWwudG9waWN9YCk7XG4gICAgICAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwoY3VycmVudENoYW5uZWwpO1xuICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRHdWlsZD8uaWQsIGxvYWRDYXRlZ29yaWVzLCBoYW5kbGVSZWFsdGltZUV2ZW50XSk7XG5cbiAgLy8gLS0tIFJlc3RsaWNoZSBGdW5rdGlvbmVuIChhbmdlcGFzc3QpIC0tLVxuICBjb25zdCB0b2dnbGVDYXRlZ29yeUV4cGFuZCA9IHVzZUNhbGxiYWNrKChjYXRlZ29yeUlkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRFeHBhbmRlZENhdGVnb3JpZXMocHJldiA9PlxuICAgICAgcHJldi5pbmNsdWRlcyhjYXRlZ29yeUlkKVxuICAgICAgICA/IHByZXYuZmlsdGVyKGlkID0+IGlkICE9PSBjYXRlZ29yeUlkKVxuICAgICAgICA6IFsuLi5wcmV2LCBjYXRlZ29yeUlkXVxuICAgICk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzYXZlQ2F0ZWdvcnkgPSB1c2VDYWxsYmFjayhhc3luYyAoY2F0ZWdvcnlEYXRhOiBDYXRlZ29yeUlucHV0KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgIGlmICghZ3VpbGRJZCkgeyB0b2FzdC5lcnJvcignS2VpbmUgR3VpbGQgYXVzZ2V3w6RobHQnKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgIHRyeSB7XG4gICAgICAgaWYgKGNhdGVnb3J5RGF0YS5pZCkge1xuICAgICAgICAgY29uc3QgdXBkYXRlRGF0YTogVXBkYXRlQ2F0ZWdvcnlEdG8gPSB7IC8qIC4uLiBEYXRlbiAuLi4gKi8gfTtcbiAgICAgICAgIGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLnVwZGF0ZUNhdGVnb3J5KGNhdGVnb3J5RGF0YS5pZCwgdXBkYXRlRGF0YSk7XG4gICAgICAgICB0b2FzdC5zdWNjZXNzKCdLYXRlZ29yaWUgYWt0dWFsaXNpZXJ0Jyk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGNvbnN0IGNyZWF0ZURhdGE6IENyZWF0ZUNhdGVnb3J5RHRvID0geyAvKiAuLi4gRGF0ZW4gLi4uICovIH07XG4gICAgICAgICBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5jcmVhdGVDYXRlZ29yeShjcmVhdGVEYXRhKTtcbiAgICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ0thdGVnb3JpZSBlcnN0ZWxsdCcpO1xuICAgICAgIH1cbiAgICAgICAvLyBSZWFsdGltZSBzb2xsdGUgU3RhdGUgYWt0dWFsaXNpZXJlblxuICAgICAgIHJldHVybiB0cnVlO1xuICAgICB9IGNhdGNoIChlcnI6IGFueSkgeyAvKiBFcnJvciBIYW5kbGluZyAqLyByZXR1cm4gZmFsc2U7IH1cbiAgICAgZmluYWxseSB7IHNldExvYWRpbmcoZmFsc2UpOyB9XG4gICB9LCBbZ3VpbGRJZF0pOyAvLyBBYmjDpG5naWdrZWl0IHZvbiBndWlsZElkXG5cbiAgY29uc3QgZGVsZXRlQ2F0ZWdvcnkgPSB1c2VDYWxsYmFjayhhc3luYyAoY2F0ZWdvcnlJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfT4gPT4ge1xuICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICB0cnkge1xuICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLmRlbGV0ZUNhdGVnb3J5KGNhdGVnb3J5SWQpO1xuICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcykgdG9hc3Quc3VjY2VzcygnS2F0ZWdvcmllIGdlbMO2c2NodC4nKTtcbiAgICAgICAvLyBSZWFsdGltZSBzb2xsdGUgU3RhdGUgYWt0dWFsaXNpZXJlblxuICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgIH0gY2F0Y2ggKGVycjogYW55KSB7IC8qIEVycm9yIEhhbmRsaW5nICovIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiAnRmVobGVyJyB9OyB9XG4gICAgIGZpbmFsbHkgeyBzZXRMb2FkaW5nKGZhbHNlKTsgfVxuICB9LCBbXSk7XG5cbiAgY29uc3QgcmVmZXRjaCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXNdIHJlZmV0Y2ggdHJpZ2dlcmVkJyk7XG4gICAgaWYgKGN1cnJlbnRHdWlsZD8uaWQpIHtcbiAgICAgIGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCA9ICcnO1xuICAgICAgaW5pdGlhbExvYWRDb21wbGV0ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBsb2FkQ2F0ZWdvcmllcyhjdXJyZW50R3VpbGQuaWQpO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRHdWlsZD8uaWQsIGxvYWRDYXRlZ29yaWVzXSk7XG5cbiAgY29uc3QgZ2V0VG90YWxTdGF0cyA9IHVzZUNhbGxiYWNrKCgpID0+ICh7XG4gICAgdG90YWxDYXRlZ29yaWVzOiBjYXRlZ29yaWVzLmxlbmd0aCxcbiAgICB0b3RhbFVzZXJzOiBjYXRlZ29yaWVzLnJlZHVjZSgoc3VtLCBjKSA9PiBzdW0gKyBjLnRvdGFsVXNlcnMsIDApLFxuICAgIHRvdGFsVGltZTogY2F0ZWdvcmllcy5yZWR1Y2UoKHN1bSwgYykgPT4gc3VtICsgYy50b3RhbFRpbWVTcGVudCwgMClcbiAgfSksIFtjYXRlZ29yaWVzXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjYXRlZ29yaWVzLCBsb2FkaW5nLCBlcnJvciwgZXhwYW5kZWRDYXRlZ29yaWVzLCBzZWFyY2hRdWVyeSxcbiAgICBzZXRTZWFyY2hRdWVyeSwgdG9nZ2xlQ2F0ZWdvcnlFeHBhbmQsIHNhdmVDYXRlZ29yeSwgZGVsZXRlQ2F0ZWdvcnksXG4gICAgZ2V0VG90YWxTdGF0cywgcmVmZXRjaFxuICB9O1xufTsiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsInRvYXN0IiwidXNlR3VpbGQiLCJjYXRlZ29yaWVzU2VydmljZSIsInpvbmVzU2VydmljZSIsIlNjb3BlVHlwZSIsInN1cGFiYXNlIiwibWFwVG9FbmhhbmNlZFpvbmUiLCJ6b25lIiwiaWQiLCJuYW1lIiwiem9uZUtleSIsIm1pbnV0ZXNSZXF1aXJlZCIsImludGVydmFsTWludXRlcyIsInBvaW50c0dyYW50ZWQiLCJwb2ludHNQZXJJbnRlcnZhbCIsImxhc3RBY3RpdmUiLCJ0b3RhbFRpbWVTcGVudCIsInRvdGFsVXNlcnMiLCJtYXBUb0VuaGFuY2VkQ2F0ZWdvcnkiLCJjYXRlZ29yeSIsImd1aWxkSWQiLCJ6b25lcyIsImd1aWxkX2lkIiwiYWxsb3dlZFJvbGVzIiwiaXNWaXNpYmxlIiwiaXNWaXNpYmxlRGVmYXVsdCIsInNlbmRTZXR1cCIsInNldHVwRmxvd0VuYWJsZWQiLCJ0cmFja2luZ0FjdGl2ZSIsImRlZmF1bHRUcmFja2luZ0VuYWJsZWQiLCJzZXR1cFRleHRDaGFubmVsIiwic2V0dXBDaGFubmVsSWQiLCJ3YWl0aW5nUm9vbU5hbWUiLCJ3YXJ0ZXJhdW1DaGFubmVsSWQiLCJkaXNjb3JkQ2F0ZWdvcnlJZCIsImRlbGV0ZWRJbkRpc2NvcmQiLCJjcmVhdGVkQXQiLCJEYXRlIiwidXBkYXRlZEF0IiwidXNlQ2F0ZWdvcmllcyIsImN1cnJlbnRHdWlsZCIsImNvbnNvbGUiLCJsb2ciLCJjYXRlZ29yaWVzIiwic2V0Q2F0ZWdvcmllcyIsImV4cGFuZGVkQ2F0ZWdvcmllcyIsInNldEV4cGFuZGVkQ2F0ZWdvcmllcyIsInNlYXJjaFF1ZXJ5Iiwic2V0U2VhcmNoUXVlcnkiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJyZWFsdGltZUNoYW5uZWxSZWYiLCJsb2FkZWRHdWlsZElkUmVmIiwiaW5pdGlhbExvYWRDb21wbGV0ZVJlZiIsImxvYWRDYXRlZ29yaWVzIiwiZ3VpbGRJZFRvTG9hZCIsImN1cnJlbnQiLCJjYXRlZ29yaWVzRGF0YSIsImdldENhdGVnb3JpZXMiLCJHVUlMRCIsImVuaGFuY2VkQ2F0ZWdvcmllc1Byb21pc2VzIiwibWFwIiwiem9uZXNEYXRhIiwiZ2V0Wm9uZXNCeUNhdGVnb3J5IiwiZW5oYW5jZWRab25lcyIsImVuaGFuY2VkQ2F0ZWdvcmllcyIsIlByb21pc2UiLCJhbGwiLCJsZW5ndGgiLCJlcnIiLCJoYW5kbGVSZWFsdGltZUV2ZW50IiwicGF5bG9hZCIsImV2ZW50VHlwZSIsIm5ldyIsIm5ld1JlY29yZCIsIm9sZCIsIm9sZFJlY29yZCIsInRhYmxlIiwic2NoZW1hIiwicmVjb3JkIiwiYWZmZWN0ZWRDYXRlZ29yeUlkIiwiY2F0ZWdvcnlfaWQiLCJuZXdDYXRlZ29yeSIsInByZXYiLCJzb21lIiwiYyIsInRoZW4iLCJjYXRjaCIsImlzX3Zpc2libGVfZGVmYXVsdCIsInNldHVwX2Zsb3dfZW5hYmxlZCIsImRlZmF1bHRfdHJhY2tpbmdfZW5hYmxlZCIsInNldHVwX2NoYW5uZWxfaWQiLCJ3YXJ0ZXJhdW1fY2hhbm5lbF9pZCIsImRpc2NvcmRfY2F0ZWdvcnlfaWQiLCJ1cGRhdGVkX2F0IiwiZmlsdGVyIiwiY2F0ZWdvcnlJbmRleCIsImZpbmRJbmRleCIsImN1cnJlbnRDYXRlZ29yeSIsInVwZGF0ZWRab25lcyIsIm5ld1pvbmUiLCJ6IiwicHVzaCIsInVwZGF0ZWRab25lIiwibmV3U3RhdGUiLCJjYXRlZ29yeURhdGEiLCJnZXRDYXRlZ29yeUJ5SWQiLCJjdXJyZW50R3VpbGRJZCIsInJlbW92ZUNoYW5uZWwiLCJjaGFubmVsIiwiY2hhbm5lbE5hbWUiLCJ0b3BpYyIsIm9uIiwiZXZlbnQiLCJzdWJzY3JpYmUiLCJzdGF0dXMiLCJjdXJyZW50Q2hhbm5lbCIsInRvZ2dsZUNhdGVnb3J5RXhwYW5kIiwiY2F0ZWdvcnlJZCIsImluY2x1ZGVzIiwic2F2ZUNhdGVnb3J5IiwidXBkYXRlRGF0YSIsInVwZGF0ZUNhdGVnb3J5Iiwic3VjY2VzcyIsImNyZWF0ZURhdGEiLCJjcmVhdGVDYXRlZ29yeSIsImRlbGV0ZUNhdGVnb3J5IiwicmVzdWx0IiwibWVzc2FnZSIsInJlZmV0Y2giLCJnZXRUb3RhbFN0YXRzIiwidG90YWxDYXRlZ29yaWVzIiwicmVkdWNlIiwic3VtIiwidG90YWxUaW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts\n"));

/***/ })

});