"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/categories/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts":
/*!*****************************************************************************!*\
  !*** ./src/components/dashboard/category-management/hooks/useCategories.ts ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCategories: () => (/* binding */ useCategories)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/core/toaster */ \"(app-pages-browser)/./src/components/core/toaster.tsx\");\n/* harmony import */ var _context_guild_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/context/guild-context */ \"(app-pages-browser)/./src/context/guild-context.tsx\");\n/* harmony import */ var _services_categories__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/categories */ \"(app-pages-browser)/./src/services/categories.ts\");\n/* harmony import */ var _services_zones__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/zones */ \"(app-pages-browser)/./src/services/zones.ts\");\n/* harmony import */ var shared_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! shared-types */ \"(app-pages-browser)/../../packages/shared-types/src/index.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useCategories auto */ \n\n\n\n\n // Import CategoryDto\n\nconst useCategories = ()=>{\n    const { currentGuild } = (0,_context_guild_context__WEBPACK_IMPORTED_MODULE_2__.useGuild)();\n    const guildId = (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) || '';\n    console.log(\"[useCategories] Hook initialisiert/neu gerendert mit guildId: \".concat(guildId));\n    const [categories, setCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [expandedCategories, setExpandedCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [searchQuery, setSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false); // Nur ein Loading-State\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const realtimeChannelRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadedGuildIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(''); // Verfolgt, für welche Guild geladen wurde\n    // --- Memoized Ladefunktion ---\n    const loadCategories = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[loadCategories]\": async (guildIdToLoad)=>{\n            if (!guildIdToLoad) {\n                console.log('[useCategories] loadCategories: Keine Guild ID übergeben.');\n                setCategories([]); // Zustand leeren\n                return;\n            }\n            console.log(\"[useCategories] loadCategories aufgerufen f\\xfcr Guild: \".concat(guildIdToLoad));\n            setLoading(true);\n            setError(null);\n            try {\n                const categoriesData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategories(shared_types__WEBPACK_IMPORTED_MODULE_5__.ScopeType.GUILD, guildIdToLoad);\n                const enhancedCategories = await Promise.all(categoriesData.map({\n                    \"useCategories.useCallback[loadCategories]\": async (category)=>{\n                        const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(category.id);\n                        const enhancedZones = zonesData.map({\n                            \"useCategories.useCallback[loadCategories].enhancedZones\": (zone)=>({\n                                    id: zone.id,\n                                    name: zone.name,\n                                    zoneKey: zone.zoneKey,\n                                    minutesRequired: zone.intervalMinutes,\n                                    pointsGranted: zone.pointsPerInterval,\n                                    lastActive: '-',\n                                    totalTimeSpent: 0,\n                                    totalUsers: 0\n                                })\n                        }[\"useCategories.useCallback[loadCategories].enhancedZones\"]);\n                        return {\n                            id: category.id,\n                            name: category.name,\n                            guild_id: guildIdToLoad,\n                            allowedRoles: category.allowedRoles || [],\n                            isVisible: category.isVisibleDefault,\n                            sendSetup: category.setupFlowEnabled,\n                            trackingActive: category.defaultTrackingEnabled,\n                            setupTextChannel: category.setupChannelId,\n                            waitingRoomName: category.warteraumChannelId,\n                            lastActive: '-',\n                            totalTimeSpent: 0,\n                            totalUsers: 0,\n                            discordCategoryId: category.discordCategoryId || null,\n                            deletedInDiscord: !category.discordCategoryId,\n                            createdAt: new Date(category.createdAt),\n                            updatedAt: new Date(category.updatedAt),\n                            zones: enhancedZones\n                        };\n                    }\n                }[\"useCategories.useCallback[loadCategories]\"]));\n                setCategories(enhancedCategories);\n                loadedGuildIdRef.current = guildIdToLoad; // Markieren als geladen\n                console.log(\"[useCategories] loadCategories: \".concat(enhancedCategories.length, \" Kategorien geladen f\\xfcr \").concat(guildIdToLoad));\n            } catch (err) {\n                console.error(\"[useCategories] Fehler beim Laden der Kategorien f\\xfcr \".concat(guildIdToLoad, \":\"), err);\n                setError('Fehler beim Laden der Kategorien');\n                // Fallback? Oder leeren State lassen?\n                setCategories([]); // Bei Fehler leeren\n                loadedGuildIdRef.current = guildIdToLoad; // Trotz Fehler als geladen markieren, um Loop zu vermeiden\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[loadCategories]\"], []); // Keine Abhängigkeiten, da Services und State-Setter stabil sind\n    // --- Memoized Realtime Handler ---\n    const handleCategoryChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[handleCategoryChange]\": (payload)=>{\n            console.log('[HANDLER CALLED] handleCategoryChange', payload); // <-- Logging hinzufügen\n            console.log(\"[useCategories Realtime] Kategorie-\\xc4nderung erkannt:\", payload);\n            const { eventType, new: newRecord, old: oldRecord, table } = payload;\n            // Nur auf relevante Tabellen reagieren\n            if (table !== 'categories') {\n                console.log(\"[useCategories Realtime] Ignoriere Event f\\xfcr Tabelle: \".concat(table));\n                return;\n            }\n            const record = newRecord || oldRecord;\n            if (!record || !record.id) return; // Brauchen mindestens eine ID\n            const categoryId = record.id;\n            switch(eventType){\n                case 'INSERT':\n                case 'UPDATE':\n                    ({\n                        \"useCategories.useCallback[handleCategoryChange]\": async ()=>{\n                            try {\n                                console.log(\"[Handler Logic START] \".concat(eventType, \" Category\"));\n                                // Lade die (neue/aktualisierte) Kategorie inkl. ihrer Zonen\n                                const categoryData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryById(categoryId);\n                                const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(categoryId);\n                                // Vollständiges Mapping statt Platzhalter\n                                const enhancedZones = zonesData.map({\n                                    \"useCategories.useCallback[handleCategoryChange].enhancedZones\": (zone)=>({\n                                            id: zone.id,\n                                            name: zone.name,\n                                            zoneKey: zone.zoneKey,\n                                            minutesRequired: zone.intervalMinutes,\n                                            pointsGranted: zone.pointsPerInterval,\n                                            lastActive: '-',\n                                            totalTimeSpent: 0,\n                                            totalUsers: 0\n                                        })\n                                }[\"useCategories.useCallback[handleCategoryChange].enhancedZones\"]);\n                                const enhancedCategory = {\n                                    id: categoryData.id,\n                                    name: categoryData.name,\n                                    guild_id: (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) || '',\n                                    allowedRoles: categoryData.allowedRoles || [],\n                                    isVisible: categoryData.isVisibleDefault,\n                                    sendSetup: categoryData.setupFlowEnabled,\n                                    trackingActive: categoryData.defaultTrackingEnabled,\n                                    setupTextChannel: categoryData.setupChannelId,\n                                    waitingRoomName: categoryData.warteraumChannelId,\n                                    lastActive: '-',\n                                    totalTimeSpent: 0,\n                                    totalUsers: 0,\n                                    discordCategoryId: categoryData.discordCategoryId || null,\n                                    deletedInDiscord: !categoryData.discordCategoryId,\n                                    createdAt: new Date(categoryData.createdAt),\n                                    updatedAt: new Date(categoryData.updatedAt),\n                                    zones: enhancedZones\n                                };\n                                console.log('[State BEFORE update]', categories);\n                                setCategories({\n                                    \"useCategories.useCallback[handleCategoryChange]\": (prev)=>{\n                                        const index = prev.findIndex({\n                                            \"useCategories.useCallback[handleCategoryChange].index\": (c)=>c.id === categoryId\n                                        }[\"useCategories.useCallback[handleCategoryChange].index\"]);\n                                        let newState;\n                                        if (index !== -1) {\n                                            // Update\n                                            console.log(\"[Category \".concat(eventType, \"] Updating existing category at index \").concat(index));\n                                            newState = [\n                                                ...prev\n                                            ];\n                                            newState[index] = enhancedCategory;\n                                        } else {\n                                            // Insert (oder Update, falls es fehlte)\n                                            console.log(\"[Category \".concat(eventType, \"] Adding new category\"));\n                                            newState = [\n                                                ...prev,\n                                                enhancedCategory\n                                            ];\n                                        }\n                                        console.log('[State AFTER update (calculated)]', newState);\n                                        return newState;\n                                    }\n                                }[\"useCategories.useCallback[handleCategoryChange]\"]);\n                                // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                                setTimeout({\n                                    \"useCategories.useCallback[handleCategoryChange]\": ()=>{\n                                        console.log('[State AFTER update (actual)]', categories);\n                                    }\n                                }[\"useCategories.useCallback[handleCategoryChange]\"], 0);\n                                console.log(\"[Handler Logic END] \".concat(eventType, \" Category\"));\n                            } catch (error) {\n                                console.error(\"[useCategories Realtime] Fehler beim Verarbeiten \".concat(eventType, \":\"), error);\n                            }\n                        }\n                    })[\"useCategories.useCallback[handleCategoryChange]\"]();\n                    break;\n                case 'DELETE':\n                    if (oldRecord === null || oldRecord === void 0 ? void 0 : oldRecord.id) {\n                        console.log(\"[Handler Logic START] DELETE Category \".concat(oldRecord.id));\n                        console.log('[State BEFORE delete]', categories);\n                        setCategories({\n                            \"useCategories.useCallback[handleCategoryChange]\": (prev)=>{\n                                console.log(\"[Category DELETE] Removing category with id \".concat(oldRecord.id));\n                                const newState = prev.filter({\n                                    \"useCategories.useCallback[handleCategoryChange].newState\": (category)=>category.id !== oldRecord.id\n                                }[\"useCategories.useCallback[handleCategoryChange].newState\"]);\n                                console.log('[State AFTER delete (calculated)]', newState);\n                                return newState;\n                            }\n                        }[\"useCategories.useCallback[handleCategoryChange]\"]);\n                        // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                        setTimeout({\n                            \"useCategories.useCallback[handleCategoryChange]\": ()=>{\n                                console.log('[State AFTER delete (actual)]', categories);\n                            }\n                        }[\"useCategories.useCallback[handleCategoryChange]\"], 0);\n                        console.log(\"[Handler Logic END] DELETE Category \".concat(oldRecord.id));\n                    }\n                    break;\n                default:\n                    console.log(\"[useCategories Realtime] Unbekannter Event-Typ f\\xfcr categories: \".concat(eventType));\n            }\n        }\n    }[\"useCategories.useCallback[handleCategoryChange]\"], [\n        categories,\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        setCategories,\n        _services_categories__WEBPACK_IMPORTED_MODULE_3__,\n        _services_zones__WEBPACK_IMPORTED_MODULE_4__\n    ]); // Abhängigkeiten für korrekte Aktualisierung\n    const handleZoneChangeInCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[handleZoneChangeInCategory]\": (payload)=>{\n            console.log('[HANDLER CALLED] handleZoneChangeInCategory', payload); // <-- Logging hinzufügen\n            console.log(\"[useCategories Realtime] Zonen-\\xc4nderung erkannt:\", payload);\n            const { new: newRecord, old: oldRecord, table } = payload;\n            // Nur auf relevante Tabellen reagieren\n            if (table !== 'zones') {\n                console.log(\"[useCategories Realtime] Ignoriere Event f\\xfcr Tabelle: \".concat(table));\n                return;\n            }\n            const record = newRecord || oldRecord;\n            if (!record || !record.category_id) return;\n            const categoryId = record.category_id;\n            // Lade Zonen für die betroffene Kategorie neu und update die Kategorie im State\n            ({\n                \"useCategories.useCallback[handleZoneChangeInCategory]\": async ()=>{\n                    try {\n                        console.log(\"[Handler Logic START] Update Zones for Category \".concat(categoryId));\n                        const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(categoryId);\n                        // Vollständiges Mapping statt Platzhalter\n                        const enhancedZones = zonesData.map({\n                            \"useCategories.useCallback[handleZoneChangeInCategory].enhancedZones\": (zone)=>({\n                                    id: zone.id,\n                                    name: zone.name,\n                                    zoneKey: zone.zoneKey,\n                                    minutesRequired: zone.intervalMinutes,\n                                    pointsGranted: zone.pointsPerInterval,\n                                    lastActive: '-',\n                                    totalTimeSpent: 0,\n                                    totalUsers: 0\n                                })\n                        }[\"useCategories.useCallback[handleZoneChangeInCategory].enhancedZones\"]);\n                        console.log('[State BEFORE zone update]', categories);\n                        setCategories({\n                            \"useCategories.useCallback[handleZoneChangeInCategory]\": (prev)=>{\n                                console.log(\"[Zone Change] Updating zones for category \".concat(categoryId));\n                                const categoryIndex = prev.findIndex({\n                                    \"useCategories.useCallback[handleZoneChangeInCategory].categoryIndex\": (c)=>c.id === categoryId\n                                }[\"useCategories.useCallback[handleZoneChangeInCategory].categoryIndex\"]);\n                                if (categoryIndex === -1) {\n                                    console.log(\"[Zone Change] Category \".concat(categoryId, \" not found in state, no update needed\"));\n                                    return prev;\n                                }\n                                const newState = [\n                                    ...prev\n                                ];\n                                newState[categoryIndex] = {\n                                    ...newState[categoryIndex],\n                                    zones: enhancedZones\n                                };\n                                console.log('[State AFTER zone update (calculated)]', newState);\n                                return newState;\n                            }\n                        }[\"useCategories.useCallback[handleZoneChangeInCategory]\"]);\n                        // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                        setTimeout({\n                            \"useCategories.useCallback[handleZoneChangeInCategory]\": ()=>{\n                                console.log('[State AFTER zone update (actual)]', categories);\n                            }\n                        }[\"useCategories.useCallback[handleZoneChangeInCategory]\"], 0);\n                        console.log(\"[Handler Logic END] Update Zones for Category \".concat(categoryId));\n                    } catch (error) {\n                        console.error(\"[useCategories Realtime] Fehler beim Laden der Zonen f\\xfcr Kategorie \".concat(categoryId, \":\"), error);\n                    }\n                }\n            })[\"useCategories.useCallback[handleZoneChangeInCategory]\"]();\n        }\n    }[\"useCategories.useCallback[handleZoneChangeInCategory]\"], [\n        setCategories\n    ]); // Nur von stabilen Funktionen abhängig\n    const handleCategoryRoleChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[handleCategoryRoleChange]\": (payload)=>{\n            console.log('[HANDLER CALLED] handleCategoryRoleChange', payload); // <-- Logging hinzufügen\n            console.log(\"[useCategories Realtime] Kategorie-Rollen-\\xc4nderung erkannt:\", payload);\n            const { new: newRecord, old: oldRecord, table } = payload;\n            // Nur auf relevante Tabellen reagieren\n            if (table !== 'category_discord_role_permissions') {\n                console.log(\"[useCategories Realtime] Ignoriere Event f\\xfcr Tabelle: \".concat(table));\n                return;\n            }\n            const record = newRecord || oldRecord;\n            if (!record || !record.category_id) return;\n            const categoryId = record.category_id;\n            ({\n                \"useCategories.useCallback[handleCategoryRoleChange]\": async ()=>{\n                    try {\n                        console.log(\"[Handler Logic START] Update Roles for Category \".concat(categoryId));\n                        const categoryData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryById(categoryId);\n                        if (!categoryData) {\n                            console.log(\"[Handler Logic] Category \".concat(categoryId, \" not found\"));\n                            return;\n                        }\n                        console.log('[State BEFORE role update]', categories);\n                        setCategories({\n                            \"useCategories.useCallback[handleCategoryRoleChange]\": (prev)=>{\n                                console.log(\"[Role Change] Updating roles for category \".concat(categoryId));\n                                const categoryIndex = prev.findIndex({\n                                    \"useCategories.useCallback[handleCategoryRoleChange].categoryIndex\": (c)=>c.id === categoryId\n                                }[\"useCategories.useCallback[handleCategoryRoleChange].categoryIndex\"]);\n                                if (categoryIndex === -1) {\n                                    console.log(\"[Role Change] Category \".concat(categoryId, \" not found in state, no update needed\"));\n                                    return prev;\n                                }\n                                const newState = [\n                                    ...prev\n                                ];\n                                newState[categoryIndex] = {\n                                    ...newState[categoryIndex],\n                                    allowedRoles: categoryData.allowedRoles || []\n                                };\n                                console.log('[State AFTER role update (calculated)]', newState);\n                                return newState;\n                            }\n                        }[\"useCategories.useCallback[handleCategoryRoleChange]\"]);\n                        // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                        setTimeout({\n                            \"useCategories.useCallback[handleCategoryRoleChange]\": ()=>{\n                                console.log('[State AFTER role update (actual)]', categories);\n                            }\n                        }[\"useCategories.useCallback[handleCategoryRoleChange]\"], 0);\n                        console.log(\"[Handler Logic END] Update Roles for Category \".concat(categoryId));\n                    } catch (error) {\n                        console.error(\"[useCategories Realtime] Fehler beim Laden der Rollenberechtigungen f\\xfcr Kategorie \".concat(categoryId, \":\"), error);\n                    }\n                }\n            })[\"useCategories.useCallback[handleCategoryRoleChange]\"]();\n        }\n    }[\"useCategories.useCallback[handleCategoryRoleChange]\"], [\n        setCategories\n    ]); // Nur von stabilen Funktionen abhängig\n    // --- Haupt-useEffect für Laden und Subscription ---\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCategories.useEffect\": ()=>{\n            const currentGuildId = currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id;\n            console.log(\"[useCategories Effect] Running for guildId: \".concat(currentGuildId || 'none'));\n            if (!currentGuildId) {\n                console.log('[useCategories Effect] No guildId, resetting.');\n                setCategories([]);\n                loadedGuildIdRef.current = '';\n                // Alte Subscription entfernen, falls vorhanden\n                if (realtimeChannelRef.current) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(realtimeChannelRef.current).then({\n                        \"useCategories.useEffect\": ()=>{\n                            console.log('[useCategories Effect] Removed old channel on guildId clear.');\n                            realtimeChannelRef.current = null;\n                        }\n                    }[\"useCategories.useEffect\"]);\n                }\n                return;\n            }\n            // Laden, wenn die Guild neu ist oder die Daten fehlen\n            if (loadedGuildIdRef.current !== currentGuildId) {\n                loadCategories(currentGuildId);\n            }\n            // Subscription Logik (unverändert zur letzten Version, nutzt jetzt memoized Handler)\n            let channel = realtimeChannelRef.current;\n            const channelName = \"categories:\".concat(currentGuildId);\n            // Nur subscriben, wenn noch nicht oder für andere Guild subscribed\n            if (!channel || channel.topic !== \"realtime:\".concat(channelName)) {\n                // Alte Subscription sicher entfernen\n                if (channel) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(channel).then({\n                        \"useCategories.useEffect\": ()=>{\n                            console.log('[useCategories Effect] Removed previous channel before new subscription.');\n                            realtimeChannelRef.current = null; // Wichtig: Ref zurücksetzen\n                        }\n                    }[\"useCategories.useEffect\"]);\n                }\n                console.log(\"[useCategories Effect] Setting up channel: \".concat(channelName));\n                channel = _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.channel(channelName);\n                channel.on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'categories'\n                }, {\n                    \"useCategories.useEffect\": (payload)=>{\n                        console.log('[useCategories RAW EVENT categories]', payload); // <-- Logging hinzufügen\n                        handleCategoryChange(payload);\n                    }\n                }[\"useCategories.useEffect\"]).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'zones'\n                }, {\n                    \"useCategories.useEffect\": (payload)=>{\n                        console.log('[useCategories RAW EVENT zones]', payload); // <-- Logging hinzufügen\n                        handleZoneChangeInCategory(payload);\n                    }\n                }[\"useCategories.useEffect\"]).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'category_discord_role_permissions'\n                }, {\n                    \"useCategories.useEffect\": (payload)=>{\n                        console.log('[useCategories RAW EVENT category_roles]', payload); // <-- Logging hinzufügen\n                        handleCategoryRoleChange(payload);\n                    }\n                }[\"useCategories.useEffect\"]).subscribe({\n                    \"useCategories.useEffect\": (status, err)=>{\n                        console.log(\"[useCategories Effect] Sub status \".concat(channelName, \":\"), status, err || '');\n                        if (status === 'SUBSCRIBED') {\n                            realtimeChannelRef.current = channel; // Ref erst bei Erfolg setzen\n                            // Nach erfolgreicher Subscription evtl. nochmals laden, falls initialFetch fehlgeschlagen\n                            if (loadedGuildIdRef.current !== currentGuildId) {\n                                console.log('[useCategories Effect] Re-fetching data after successful subscription.');\n                                loadCategories(currentGuildId);\n                            }\n                        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {\n                            console.error(\"[useCategories Effect] Subscription failed for \".concat(channelName, \":\"), err);\n                            realtimeChannelRef.current = null; // Bei Fehler Ref zurücksetzen\n                        }\n                    }\n                }[\"useCategories.useEffect\"]);\n            } else {\n                console.log(\"[useCategories Effect] Already subscribed to \".concat(channelName));\n            }\n            // Cleanup-Funktion\n            return(({\n                \"useCategories.useEffect\": ()=>{\n                    console.log(\"[useCategories Effect] Cleanup for guildId: \".concat(currentGuildId));\n                    // Nur den Channel entfernen, der *in diesem Effekt* erstellt wurde\n                    if (channel && (!realtimeChannelRef.current || realtimeChannelRef.current === channel)) {\n                        console.log(\"[useCategories Effect] Removing channel \".concat(channel.topic));\n                        _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(channel);\n                        if (realtimeChannelRef.current === channel) {\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }\n            })[\"useCategories.useEffect\"]);\n        // ACHTUNG: Die Handler als Abhängigkeiten stellen sicher, dass der Effekt neu läuft, wenn\n        // sich ihre Referenzen ändern (was sie dank useCallback nur tun sollten, wenn sich *ihre* Deps ändern).\n        // `loadCategories` ist ebenfalls memoisiert.\n        }\n    }[\"useCategories.useEffect\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories,\n        handleCategoryChange,\n        handleZoneChangeInCategory,\n        handleCategoryRoleChange\n    ]);\n    // --- Restliche Funktionen (weitgehend unverändert, nutzen jetzt stabile loadCategories) ---\n    const toggleCategoryExpand = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[toggleCategoryExpand]\": (categoryId)=>{\n            setExpandedCategories({\n                \"useCategories.useCallback[toggleCategoryExpand]\": (prevExpanded)=>prevExpanded.includes(categoryId) ? prevExpanded.filter({\n                        \"useCategories.useCallback[toggleCategoryExpand]\": (id)=>id !== categoryId\n                    }[\"useCategories.useCallback[toggleCategoryExpand]\"]) : [\n                        ...prevExpanded,\n                        categoryId\n                    ]\n            }[\"useCategories.useCallback[toggleCategoryExpand]\"]);\n        }\n    }[\"useCategories.useCallback[toggleCategoryExpand]\"], []);\n    const saveCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[saveCategory]\": async (categoryData)=>{\n            if (!guildId) {\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error('Keine Guild ausgewählt');\n                return false;\n            }\n            setLoading(true);\n            try {\n                if (categoryData.id) {\n                    const updateData = {\n                        name: categoryData.name,\n                        isVisibleDefault: categoryData.isVisible,\n                        setupFlowEnabled: categoryData.sendSetup,\n                        defaultTrackingEnabled: categoryData.trackingActive,\n                        setupChannelName: categoryData.setupTextChannel || undefined,\n                        warteraumChannelName: categoryData.waitingRoomName || undefined,\n                        discordRoleIds: categoryData.allowedRoles\n                    };\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.updateCategory(categoryData.id, updateData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie erfolgreich aktualisiert');\n                } else {\n                    const createData = {\n                        scope: {\n                            id: guildId,\n                            scopeType: shared_types__WEBPACK_IMPORTED_MODULE_5__.ScopeType.GUILD,\n                            scopeId: guildId\n                        },\n                        name: categoryData.name,\n                        isVisibleDefault: categoryData.isVisible,\n                        setupFlowEnabled: categoryData.sendSetup,\n                        defaultTrackingEnabled: categoryData.trackingActive,\n                        setupChannelName: categoryData.setupTextChannel || undefined,\n                        warteraumChannelName: categoryData.waitingRoomName || undefined,\n                        discordRoleIds: categoryData.allowedRoles\n                    };\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.createCategory(createData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie erfolgreich erstellt');\n                }\n                // Realtime sollte die Aktualisierung übernehmen, kein manuelles Laden nötig\n                return true;\n            } catch (err) {\n                var _err_response_data, _err_response;\n                console.error('Fehler beim Speichern der Kategorie:', err);\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error(((_err_response = err.response) === null || _err_response === void 0 ? void 0 : (_err_response_data = _err_response.data) === null || _err_response_data === void 0 ? void 0 : _err_response_data.message) || 'Fehler beim Speichern der Kategorie');\n                return false;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[saveCategory]\"], [\n        guildId\n    ]); // Abhängig von guildId\n    const deleteCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[deleteCategory]\": async (categoryId)=>{\n            setLoading(true);\n            try {\n                const result = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.deleteCategory(categoryId);\n                if (result.success) {\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie erfolgreich gelöscht');\n                }\n                return result;\n            } catch (err) {\n                var _err_response_data, _err_response;\n                console.error('Fehler beim Löschen der Kategorie:', err);\n                const errorMessage = ((_err_response = err.response) === null || _err_response === void 0 ? void 0 : (_err_response_data = _err_response.data) === null || _err_response_data === void 0 ? void 0 : _err_response_data.message) || 'Fehler beim Löschen der Kategorie';\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error(errorMessage);\n                return {\n                    success: false,\n                    message: errorMessage\n                };\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[deleteCategory]\"], []); // Keine Abhängigkeiten nötig\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[refetch]\": ()=>{\n            console.log('[useCategories] refetch: Starte Neuladen');\n            if (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) {\n                loadedGuildIdRef.current = ''; // Erzwingt Neuladen im Effekt\n                loadCategories(currentGuild.id); // Löst manuelles Laden aus\n            }\n        }\n    }[\"useCategories.useCallback[refetch]\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories\n    ]);\n    const getTotalStats = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[getTotalStats]\": ()=>{\n            // ... Berechnung wie bisher ...\n            return {\n                totalCategories: 0,\n                totalUsers: 0,\n                totalTime: 0\n            }; // Placeholder\n        }\n    }[\"useCategories.useCallback[getTotalStats]\"], [\n        categories\n    ]);\n    return {\n        categories,\n        loading,\n        error,\n        expandedCategories,\n        searchQuery,\n        setSearchQuery,\n        toggleCategoryExpand,\n        saveCategory,\n        // updateCategoryWithZones, // Wird jetzt durch Realtime Handler abgedeckt\n        deleteCategory,\n        getTotalStats,\n        refetch\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9jYXRlZ29yeS1tYW5hZ2VtZW50L2hvb2tzL3VzZUNhdGVnb3JpZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O21FQUVpRTtBQUNmO0FBQ0M7QUFDUTtBQUNWO0FBQzJDLENBQUMscUJBQXFCO0FBRXhFO0FBOENuQyxNQUFNVSxnQkFBZ0I7SUFDM0IsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR04sZ0VBQVFBO0lBQ2pDLE1BQU1PLFVBQVVELENBQUFBLHlCQUFBQSxtQ0FBQUEsYUFBY0UsRUFBRSxLQUFJO0lBQ3BDQyxRQUFRQyxHQUFHLENBQUMsaUVBQXlFLE9BQVJIO0lBRTdFLE1BQU0sQ0FBQ0ksWUFBWUMsY0FBYyxHQUFHakIsK0NBQVFBLENBQXFCLEVBQUU7SUFDbkUsTUFBTSxDQUFDa0Isb0JBQW9CQyxzQkFBc0IsR0FBR25CLCtDQUFRQSxDQUFXLEVBQUU7SUFDekUsTUFBTSxDQUFDb0IsYUFBYUMsZUFBZSxHQUFHckIsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDc0IsU0FBU0MsV0FBVyxHQUFHdkIsK0NBQVFBLENBQUMsUUFBUSx3QkFBd0I7SUFDdkUsTUFBTSxDQUFDd0IsT0FBT0MsU0FBUyxHQUFHekIsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU0wQixxQkFBcUJ2Qiw2Q0FBTUEsQ0FBeUI7SUFDMUQsTUFBTXdCLG1CQUFtQnhCLDZDQUFNQSxDQUFTLEtBQUssMkNBQTJDO0lBRXhGLGdDQUFnQztJQUNoQyxNQUFNeUIsaUJBQWlCMUIsa0RBQVdBO3FEQUFDLE9BQU8yQjtZQUN4QyxJQUFJLENBQUNBLGVBQWU7Z0JBQ2xCZixRQUFRQyxHQUFHLENBQUM7Z0JBQ1pFLGNBQWMsRUFBRSxHQUFHLGlCQUFpQjtnQkFDcEM7WUFDRjtZQUNBSCxRQUFRQyxHQUFHLENBQUMsMkRBQXNFLE9BQWRjO1lBQ3BFTixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxJQUFJO2dCQUNG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QUFBQSxhQUFjRSxFQUFFO1FBQUVlO0tBQWU7SUFFckMsTUFBTXNHLGdCQUFnQmhJLGtEQUFXQTtvREFBQztZQUNoQyxnQ0FBZ0M7WUFDaEMsT0FBTztnQkFBRWlJLGlCQUFpQjtnQkFBR2pGLFlBQVk7Z0JBQUdrRixXQUFXO1lBQUMsR0FBRyxjQUFjO1FBQzNFO21EQUFHO1FBQUNwSDtLQUFXO0lBR2YsT0FBTztRQUNMQTtRQUNBTTtRQUNBRTtRQUNBTjtRQUNBRTtRQUNBQztRQUNBc0Y7UUFDQUc7UUFDQSwwRUFBMEU7UUFDMUVnQjtRQUNBSTtRQUNBRDtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxpbmZvXFxEb2N1bWVudHNcXERpc2NvcmQgQm90XFxDaGltZXJhXFxhcHBzXFxmcm9udGVuZFxcc3JjXFxjb21wb25lbnRzXFxkYXNoYm9hcmRcXGNhdGVnb3J5LW1hbmFnZW1lbnRcXGhvb2tzXFx1c2VDYXRlZ29yaWVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAnQC9jb21wb25lbnRzL2NvcmUvdG9hc3Rlcic7XG5pbXBvcnQgeyB1c2VHdWlsZCB9IGZyb20gJ0AvY29udGV4dC9ndWlsZC1jb250ZXh0JztcbmltcG9ydCAqIGFzIGNhdGVnb3JpZXNTZXJ2aWNlIGZyb20gJ0Avc2VydmljZXMvY2F0ZWdvcmllcyc7XG5pbXBvcnQgKiBhcyB6b25lc1NlcnZpY2UgZnJvbSAnQC9zZXJ2aWNlcy96b25lcyc7XG5pbXBvcnQgeyBDcmVhdGVDYXRlZ29yeUR0bywgVXBkYXRlQ2F0ZWdvcnlEdG8sIFNjb3BlVHlwZSwgQ2F0ZWdvcnlEdG8gfSBmcm9tICdzaGFyZWQtdHlwZXMnOyAvLyBJbXBvcnQgQ2F0ZWdvcnlEdG9cbmltcG9ydCB7IFJlYWx0aW1lQ2hhbm5lbCwgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkIH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuXG4vLyBJbnRlcmZhY2VzIGJsZWliZW4gZ2xlaWNoLi4uXG5leHBvcnQgaW50ZXJmYWNlIEVuaGFuY2VkQ2F0ZWdvcnkge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGd1aWxkX2lkOiBzdHJpbmc7XG4gIGFsbG93ZWRSb2xlczogc3RyaW5nW107XG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgc2VuZFNldHVwOiBib29sZWFuO1xuICB0cmFja2luZ0FjdGl2ZTogYm9vbGVhbjtcbiAgc2V0dXBUZXh0Q2hhbm5lbD86IHN0cmluZyB8IG51bGw7XG4gIHdhaXRpbmdSb29tTmFtZT86IHN0cmluZyB8IG51bGw7XG4gIGxhc3RBY3RpdmU6IHN0cmluZztcbiAgdG90YWxUaW1lU3BlbnQ6IG51bWJlcjtcbiAgdG90YWxVc2VyczogbnVtYmVyO1xuICBkaXNjb3JkQ2F0ZWdvcnlJZDogc3RyaW5nIHwgbnVsbDtcbiAgZGVsZXRlZEluRGlzY29yZDogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICB1cGRhdGVkQXQ6IERhdGU7XG4gIHpvbmVzOiBFbmhhbmNlZFpvbmVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbmhhbmNlZFpvbmUge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHpvbmVLZXk6IHN0cmluZztcbiAgbWludXRlc1JlcXVpcmVkOiBudW1iZXI7XG4gIHBvaW50c0dyYW50ZWQ6IG51bWJlcjtcbiAgbGFzdEFjdGl2ZTogc3RyaW5nO1xuICB0b3RhbFRpbWVTcGVudDogbnVtYmVyO1xuICB0b3RhbFVzZXJzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcnlJbnB1dCB7XG4gIGlkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFsbG93ZWRSb2xlczogc3RyaW5nW107XG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgc2VuZFNldHVwOiBib29sZWFuO1xuICB0cmFja2luZ0FjdGl2ZTogYm9vbGVhbjtcbiAgc2V0dXBUZXh0Q2hhbm5lbD86IHN0cmluZyB8IG51bGw7XG4gIHdhaXRpbmdSb29tTmFtZT86IHN0cmluZyB8IG51bGw7XG59XG5cblxuZXhwb3J0IGNvbnN0IHVzZUNhdGVnb3JpZXMgPSAoKSA9PiB7XG4gIGNvbnN0IHsgY3VycmVudEd1aWxkIH0gPSB1c2VHdWlsZCgpO1xuICBjb25zdCBndWlsZElkID0gY3VycmVudEd1aWxkPy5pZCB8fCAnJztcbiAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzXSBIb29rIGluaXRpYWxpc2llcnQvbmV1IGdlcmVuZGVydCBtaXQgZ3VpbGRJZDogJHtndWlsZElkfWApO1xuXG4gIGNvbnN0IFtjYXRlZ29yaWVzLCBzZXRDYXRlZ29yaWVzXSA9IHVzZVN0YXRlPEVuaGFuY2VkQ2F0ZWdvcnlbXT4oW10pO1xuICBjb25zdCBbZXhwYW5kZWRDYXRlZ29yaWVzLCBzZXRFeHBhbmRlZENhdGVnb3JpZXNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcbiAgY29uc3QgW3NlYXJjaFF1ZXJ5LCBzZXRTZWFyY2hRdWVyeV0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTsgLy8gTnVyIGVpbiBMb2FkaW5nLVN0YXRlXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlYWx0aW1lQ2hhbm5lbFJlZiA9IHVzZVJlZjxSZWFsdGltZUNoYW5uZWwgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbG9hZGVkR3VpbGRJZFJlZiA9IHVzZVJlZjxzdHJpbmc+KCcnKTsgLy8gVmVyZm9sZ3QsIGbDvHIgd2VsY2hlIEd1aWxkIGdlbGFkZW4gd3VyZGVcblxuICAvLyAtLS0gTWVtb2l6ZWQgTGFkZWZ1bmt0aW9uIC0tLVxuICBjb25zdCBsb2FkQ2F0ZWdvcmllcyA9IHVzZUNhbGxiYWNrKGFzeW5jIChndWlsZElkVG9Mb2FkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWd1aWxkSWRUb0xvYWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbdXNlQ2F0ZWdvcmllc10gbG9hZENhdGVnb3JpZXM6IEtlaW5lIEd1aWxkIElEIMO8YmVyZ2ViZW4uJyk7XG4gICAgICBzZXRDYXRlZ29yaWVzKFtdKTsgLy8gWnVzdGFuZCBsZWVyZW5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzXSBsb2FkQ2F0ZWdvcmllcyBhdWZnZXJ1ZmVuIGbDvHIgR3VpbGQ6ICR7Z3VpbGRJZFRvTG9hZH1gKTtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhdGVnb3JpZXNEYXRhID0gYXdhaXQgY2F0ZWdvcmllc1NlcnZpY2UuZ2V0Q2F0ZWdvcmllcyhTY29wZVR5cGUuR1VJTEQsIGd1aWxkSWRUb0xvYWQpO1xuICAgICAgY29uc3QgZW5oYW5jZWRDYXRlZ29yaWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGNhdGVnb3JpZXNEYXRhLm1hcChhc3luYyAoY2F0ZWdvcnkpID0+IHtcbiAgICAgICAgICBjb25zdCB6b25lc0RhdGEgPSBhd2FpdCB6b25lc1NlcnZpY2UuZ2V0Wm9uZXNCeUNhdGVnb3J5KGNhdGVnb3J5LmlkKTtcbiAgICAgICAgICBjb25zdCBlbmhhbmNlZFpvbmVzOiBFbmhhbmNlZFpvbmVbXSA9IHpvbmVzRGF0YS5tYXAoem9uZSA9PiAoe1xuICAgICAgICAgICAgaWQ6IHpvbmUuaWQsXG4gICAgICAgICAgICBuYW1lOiB6b25lLm5hbWUsXG4gICAgICAgICAgICB6b25lS2V5OiB6b25lLnpvbmVLZXksXG4gICAgICAgICAgICBtaW51dGVzUmVxdWlyZWQ6IHpvbmUuaW50ZXJ2YWxNaW51dGVzLFxuICAgICAgICAgICAgcG9pbnRzR3JhbnRlZDogem9uZS5wb2ludHNQZXJJbnRlcnZhbCxcbiAgICAgICAgICAgIGxhc3RBY3RpdmU6ICctJyxcbiAgICAgICAgICAgIHRvdGFsVGltZVNwZW50OiAwLFxuICAgICAgICAgICAgdG90YWxVc2VyczogMFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGNhdGVnb3J5LmlkLFxuICAgICAgICAgICAgbmFtZTogY2F0ZWdvcnkubmFtZSxcbiAgICAgICAgICAgIGd1aWxkX2lkOiBndWlsZElkVG9Mb2FkLFxuICAgICAgICAgICAgYWxsb3dlZFJvbGVzOiBjYXRlZ29yeS5hbGxvd2VkUm9sZXMgfHwgW10sXG4gICAgICAgICAgICBpc1Zpc2libGU6IGNhdGVnb3J5LmlzVmlzaWJsZURlZmF1bHQsXG4gICAgICAgICAgICBzZW5kU2V0dXA6IGNhdGVnb3J5LnNldHVwRmxvd0VuYWJsZWQsXG4gICAgICAgICAgICB0cmFja2luZ0FjdGl2ZTogY2F0ZWdvcnkuZGVmYXVsdFRyYWNraW5nRW5hYmxlZCxcbiAgICAgICAgICAgIHNldHVwVGV4dENoYW5uZWw6IGNhdGVnb3J5LnNldHVwQ2hhbm5lbElkLFxuICAgICAgICAgICAgd2FpdGluZ1Jvb21OYW1lOiBjYXRlZ29yeS53YXJ0ZXJhdW1DaGFubmVsSWQsXG4gICAgICAgICAgICBsYXN0QWN0aXZlOiAnLScsXG4gICAgICAgICAgICB0b3RhbFRpbWVTcGVudDogMCxcbiAgICAgICAgICAgIHRvdGFsVXNlcnM6IDAsXG4gICAgICAgICAgICBkaXNjb3JkQ2F0ZWdvcnlJZDogY2F0ZWdvcnkuZGlzY29yZENhdGVnb3J5SWQgfHwgbnVsbCxcbiAgICAgICAgICAgIGRlbGV0ZWRJbkRpc2NvcmQ6ICFjYXRlZ29yeS5kaXNjb3JkQ2F0ZWdvcnlJZCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoY2F0ZWdvcnkuY3JlYXRlZEF0KSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoY2F0ZWdvcnkudXBkYXRlZEF0KSxcbiAgICAgICAgICAgIHpvbmVzOiBlbmhhbmNlZFpvbmVzXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHNldENhdGVnb3JpZXMoZW5oYW5jZWRDYXRlZ29yaWVzKTtcbiAgICAgIGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCA9IGd1aWxkSWRUb0xvYWQ7IC8vIE1hcmtpZXJlbiBhbHMgZ2VsYWRlblxuICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzXSBsb2FkQ2F0ZWdvcmllczogJHtlbmhhbmNlZENhdGVnb3JpZXMubGVuZ3RofSBLYXRlZ29yaWVuIGdlbGFkZW4gZsO8ciAke2d1aWxkSWRUb0xvYWR9YCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbdXNlQ2F0ZWdvcmllc10gRmVobGVyIGJlaW0gTGFkZW4gZGVyIEthdGVnb3JpZW4gZsO8ciAke2d1aWxkSWRUb0xvYWR9OmAsIGVycik7XG4gICAgICBzZXRFcnJvcignRmVobGVyIGJlaW0gTGFkZW4gZGVyIEthdGVnb3JpZW4nKTtcbiAgICAgIC8vIEZhbGxiYWNrPyBPZGVyIGxlZXJlbiBTdGF0ZSBsYXNzZW4/XG4gICAgICBzZXRDYXRlZ29yaWVzKFtdKTsgLy8gQmVpIEZlaGxlciBsZWVyZW5cbiAgICAgIGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCA9IGd1aWxkSWRUb0xvYWQ7IC8vIFRyb3R6IEZlaGxlciBhbHMgZ2VsYWRlbiBtYXJraWVyZW4sIHVtIExvb3AgenUgdmVybWVpZGVuXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW10pOyAvLyBLZWluZSBBYmjDpG5naWdrZWl0ZW4sIGRhIFNlcnZpY2VzIHVuZCBTdGF0ZS1TZXR0ZXIgc3RhYmlsIHNpbmRcblxuICAvLyAtLS0gTWVtb2l6ZWQgUmVhbHRpbWUgSGFuZGxlciAtLS1cbiAgY29uc3QgaGFuZGxlQ2F0ZWdvcnlDaGFuZ2UgPSB1c2VDYWxsYmFjaygocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPGFueT4pID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0hBTkRMRVIgQ0FMTEVEXSBoYW5kbGVDYXRlZ29yeUNoYW5nZScsIHBheWxvYWQpOyAvLyA8LS0gTG9nZ2luZyBoaW56dWbDvGdlblxuICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBSZWFsdGltZV0gS2F0ZWdvcmllLcOEbmRlcnVuZyBlcmthbm50OmAsIHBheWxvYWQpO1xuICAgIGNvbnN0IHsgZXZlbnRUeXBlLCBuZXc6IG5ld1JlY29yZCwgb2xkOiBvbGRSZWNvcmQsIHRhYmxlIH0gPSBwYXlsb2FkO1xuXG4gICAgLy8gTnVyIGF1ZiByZWxldmFudGUgVGFiZWxsZW4gcmVhZ2llcmVuXG4gICAgaWYgKHRhYmxlICE9PSAnY2F0ZWdvcmllcycpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIFJlYWx0aW1lXSBJZ25vcmllcmUgRXZlbnQgZsO8ciBUYWJlbGxlOiAke3RhYmxlfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVjb3JkID0gbmV3UmVjb3JkIHx8IG9sZFJlY29yZDtcbiAgICBpZiAoIXJlY29yZCB8fCAhcmVjb3JkLmlkKSByZXR1cm47IC8vIEJyYXVjaGVuIG1pbmRlc3RlbnMgZWluZSBJRFxuXG4gICAgY29uc3QgY2F0ZWdvcnlJZCA9IHJlY29yZC5pZDtcblxuICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlICdJTlNFUlQnOlxuICAgICAgY2FzZSAnVVBEQVRFJzpcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljIFNUQVJUXSAke2V2ZW50VHlwZX0gQ2F0ZWdvcnlgKTtcbiAgICAgICAgICAgIC8vIExhZGUgZGllIChuZXVlL2FrdHVhbGlzaWVydGUpIEthdGVnb3JpZSBpbmtsLiBpaHJlciBab25lblxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnlEYXRhID0gYXdhaXQgY2F0ZWdvcmllc1NlcnZpY2UuZ2V0Q2F0ZWdvcnlCeUlkKGNhdGVnb3J5SWQpO1xuICAgICAgICAgICAgY29uc3Qgem9uZXNEYXRhID0gYXdhaXQgem9uZXNTZXJ2aWNlLmdldFpvbmVzQnlDYXRlZ29yeShjYXRlZ29yeUlkKTtcblxuICAgICAgICAgICAgLy8gVm9sbHN0w6RuZGlnZXMgTWFwcGluZyBzdGF0dCBQbGF0emhhbHRlclxuICAgICAgICAgICAgY29uc3QgZW5oYW5jZWRab25lcyA9IHpvbmVzRGF0YS5tYXAoem9uZSA9PiAoe1xuICAgICAgICAgICAgICBpZDogem9uZS5pZCxcbiAgICAgICAgICAgICAgbmFtZTogem9uZS5uYW1lLFxuICAgICAgICAgICAgICB6b25lS2V5OiB6b25lLnpvbmVLZXksXG4gICAgICAgICAgICAgIG1pbnV0ZXNSZXF1aXJlZDogem9uZS5pbnRlcnZhbE1pbnV0ZXMsXG4gICAgICAgICAgICAgIHBvaW50c0dyYW50ZWQ6IHpvbmUucG9pbnRzUGVySW50ZXJ2YWwsXG4gICAgICAgICAgICAgIGxhc3RBY3RpdmU6ICctJyxcbiAgICAgICAgICAgICAgdG90YWxUaW1lU3BlbnQ6IDAsXG4gICAgICAgICAgICAgIHRvdGFsVXNlcnM6IDBcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgY29uc3QgZW5oYW5jZWRDYXRlZ29yeTogRW5oYW5jZWRDYXRlZ29yeSA9IHtcbiAgICAgICAgICAgICAgaWQ6IGNhdGVnb3J5RGF0YS5pZCxcbiAgICAgICAgICAgICAgbmFtZTogY2F0ZWdvcnlEYXRhLm5hbWUsXG4gICAgICAgICAgICAgIGd1aWxkX2lkOiBjdXJyZW50R3VpbGQ/LmlkIHx8ICcnLFxuICAgICAgICAgICAgICBhbGxvd2VkUm9sZXM6IGNhdGVnb3J5RGF0YS5hbGxvd2VkUm9sZXMgfHwgW10sXG4gICAgICAgICAgICAgIGlzVmlzaWJsZTogY2F0ZWdvcnlEYXRhLmlzVmlzaWJsZURlZmF1bHQsXG4gICAgICAgICAgICAgIHNlbmRTZXR1cDogY2F0ZWdvcnlEYXRhLnNldHVwRmxvd0VuYWJsZWQsXG4gICAgICAgICAgICAgIHRyYWNraW5nQWN0aXZlOiBjYXRlZ29yeURhdGEuZGVmYXVsdFRyYWNraW5nRW5hYmxlZCxcbiAgICAgICAgICAgICAgc2V0dXBUZXh0Q2hhbm5lbDogY2F0ZWdvcnlEYXRhLnNldHVwQ2hhbm5lbElkLFxuICAgICAgICAgICAgICB3YWl0aW5nUm9vbU5hbWU6IGNhdGVnb3J5RGF0YS53YXJ0ZXJhdW1DaGFubmVsSWQsXG4gICAgICAgICAgICAgIGxhc3RBY3RpdmU6ICctJyxcbiAgICAgICAgICAgICAgdG90YWxUaW1lU3BlbnQ6IDAsXG4gICAgICAgICAgICAgIHRvdGFsVXNlcnM6IDAsXG4gICAgICAgICAgICAgIGRpc2NvcmRDYXRlZ29yeUlkOiBjYXRlZ29yeURhdGEuZGlzY29yZENhdGVnb3J5SWQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgZGVsZXRlZEluRGlzY29yZDogIWNhdGVnb3J5RGF0YS5kaXNjb3JkQ2F0ZWdvcnlJZCxcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShjYXRlZ29yeURhdGEuY3JlYXRlZEF0KSxcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShjYXRlZ29yeURhdGEudXBkYXRlZEF0KSxcbiAgICAgICAgICAgICAgem9uZXM6IGVuaGFuY2VkWm9uZXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQkVGT1JFIHVwZGF0ZV0nLCBjYXRlZ29yaWVzKTtcbiAgICAgICAgICAgIHNldENhdGVnb3JpZXMocHJldiA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcHJldi5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBjYXRlZ29yeUlkKTtcbiAgICAgICAgICAgICAgbGV0IG5ld1N0YXRlO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtDYXRlZ29yeSAke2V2ZW50VHlwZX1dIFVwZGF0aW5nIGV4aXN0aW5nIGNhdGVnb3J5IGF0IGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbLi4ucHJldl07XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVbaW5kZXhdID0gZW5oYW5jZWRDYXRlZ29yeTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgKG9kZXIgVXBkYXRlLCBmYWxscyBlcyBmZWhsdGUpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtDYXRlZ29yeSAke2V2ZW50VHlwZX1dIEFkZGluZyBuZXcgY2F0ZWdvcnlgKTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFsuLi5wcmV2LCBlbmhhbmNlZENhdGVnb3J5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1N0YXRlIEFGVEVSIHVwZGF0ZSAoY2FsY3VsYXRlZCldJywgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTG9nZ2UgZGVuIFN0YXRlIG5hY2ggZGVyIEFrdHVhbGlzaWVydW5nIChpbSBuw6RjaHN0ZW4gUmVuZGVyLVp5a2x1cylcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1N0YXRlIEFGVEVSIHVwZGF0ZSAoYWN0dWFsKV0nLCBjYXRlZ29yaWVzKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljIEVORF0gJHtldmVudFR5cGV9IENhdGVnb3J5YCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFt1c2VDYXRlZ29yaWVzIFJlYWx0aW1lXSBGZWhsZXIgYmVpbSBWZXJhcmJlaXRlbiAke2V2ZW50VHlwZX06YCwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdERUxFVEUnOlxuICAgICAgICBpZiAob2xkUmVjb3JkPy5pZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFuZGxlciBMb2dpYyBTVEFSVF0gREVMRVRFIENhdGVnb3J5ICR7b2xkUmVjb3JkLmlkfWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQkVGT1JFIGRlbGV0ZV0nLCBjYXRlZ29yaWVzKTtcblxuICAgICAgICAgIHNldENhdGVnb3JpZXMocHJldiA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0NhdGVnb3J5IERFTEVURV0gUmVtb3ZpbmcgY2F0ZWdvcnkgd2l0aCBpZCAke29sZFJlY29yZC5pZH1gKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gcHJldi5maWx0ZXIoY2F0ZWdvcnkgPT4gY2F0ZWdvcnkuaWQgIT09IG9sZFJlY29yZC5pZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1N0YXRlIEFGVEVSIGRlbGV0ZSAoY2FsY3VsYXRlZCldJywgbmV3U3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gTG9nZ2UgZGVuIFN0YXRlIG5hY2ggZGVyIEFrdHVhbGlzaWVydW5nIChpbSBuw6RjaHN0ZW4gUmVuZGVyLVp5a2x1cylcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQUZURVIgZGVsZXRlIChhY3R1YWwpXScsIGNhdGVnb3JpZXMpO1xuICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljIEVORF0gREVMRVRFIENhdGVnb3J5ICR7b2xkUmVjb3JkLmlkfWApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIFJlYWx0aW1lXSBVbmJla2FubnRlciBFdmVudC1UeXAgZsO8ciBjYXRlZ29yaWVzOiAke2V2ZW50VHlwZX1gKTtcbiAgICB9XG4gIH0sIFtjYXRlZ29yaWVzLCBjdXJyZW50R3VpbGQ/LmlkLCBzZXRDYXRlZ29yaWVzLCBjYXRlZ29yaWVzU2VydmljZSwgem9uZXNTZXJ2aWNlXSk7IC8vIEFiaMOkbmdpZ2tlaXRlbiBmw7xyIGtvcnJla3RlIEFrdHVhbGlzaWVydW5nXG5cbiAgY29uc3QgaGFuZGxlWm9uZUNoYW5nZUluQ2F0ZWdvcnkgPSB1c2VDYWxsYmFjaygocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPGFueT4pID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0hBTkRMRVIgQ0FMTEVEXSBoYW5kbGVab25lQ2hhbmdlSW5DYXRlZ29yeScsIHBheWxvYWQpOyAvLyA8LS0gTG9nZ2luZyBoaW56dWbDvGdlblxuICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBSZWFsdGltZV0gWm9uZW4tw4RuZGVydW5nIGVya2FubnQ6YCwgcGF5bG9hZCk7XG4gICAgY29uc3QgeyBuZXc6IG5ld1JlY29yZCwgb2xkOiBvbGRSZWNvcmQsIHRhYmxlIH0gPSBwYXlsb2FkO1xuXG4gICAgLy8gTnVyIGF1ZiByZWxldmFudGUgVGFiZWxsZW4gcmVhZ2llcmVuXG4gICAgaWYgKHRhYmxlICE9PSAnem9uZXMnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBSZWFsdGltZV0gSWdub3JpZXJlIEV2ZW50IGbDvHIgVGFiZWxsZTogJHt0YWJsZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY29yZCA9IG5ld1JlY29yZCB8fCBvbGRSZWNvcmQ7XG4gICAgaWYgKCFyZWNvcmQgfHwgIXJlY29yZC5jYXRlZ29yeV9pZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2F0ZWdvcnlJZCA9IHJlY29yZC5jYXRlZ29yeV9pZDtcblxuICAgIC8vIExhZGUgWm9uZW4gZsO8ciBkaWUgYmV0cm9mZmVuZSBLYXRlZ29yaWUgbmV1IHVuZCB1cGRhdGUgZGllIEthdGVnb3JpZSBpbSBTdGF0ZVxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0hhbmRsZXIgTG9naWMgU1RBUlRdIFVwZGF0ZSBab25lcyBmb3IgQ2F0ZWdvcnkgJHtjYXRlZ29yeUlkfWApO1xuICAgICAgICBjb25zdCB6b25lc0RhdGEgPSBhd2FpdCB6b25lc1NlcnZpY2UuZ2V0Wm9uZXNCeUNhdGVnb3J5KGNhdGVnb3J5SWQpO1xuXG4gICAgICAgIC8vIFZvbGxzdMOkbmRpZ2VzIE1hcHBpbmcgc3RhdHQgUGxhdHpoYWx0ZXJcbiAgICAgICAgY29uc3QgZW5oYW5jZWRab25lcyA9IHpvbmVzRGF0YS5tYXAoem9uZSA9PiAoe1xuICAgICAgICAgIGlkOiB6b25lLmlkLFxuICAgICAgICAgIG5hbWU6IHpvbmUubmFtZSxcbiAgICAgICAgICB6b25lS2V5OiB6b25lLnpvbmVLZXksXG4gICAgICAgICAgbWludXRlc1JlcXVpcmVkOiB6b25lLmludGVydmFsTWludXRlcyxcbiAgICAgICAgICBwb2ludHNHcmFudGVkOiB6b25lLnBvaW50c1BlckludGVydmFsLFxuICAgICAgICAgIGxhc3RBY3RpdmU6ICctJyxcbiAgICAgICAgICB0b3RhbFRpbWVTcGVudDogMCxcbiAgICAgICAgICB0b3RhbFVzZXJzOiAwXG4gICAgICAgIH0pKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnW1N0YXRlIEJFRk9SRSB6b25lIHVwZGF0ZV0nLCBjYXRlZ29yaWVzKTtcbiAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1pvbmUgQ2hhbmdlXSBVcGRhdGluZyB6b25lcyBmb3IgY2F0ZWdvcnkgJHtjYXRlZ29yeUlkfWApO1xuICAgICAgICAgIGNvbnN0IGNhdGVnb3J5SW5kZXggPSBwcmV2LmZpbmRJbmRleChjID0+IGMuaWQgPT09IGNhdGVnb3J5SWQpO1xuXG4gICAgICAgICAgaWYgKGNhdGVnb3J5SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1pvbmUgQ2hhbmdlXSBDYXRlZ29yeSAke2NhdGVnb3J5SWR9IG5vdCBmb3VuZCBpbiBzdGF0ZSwgbm8gdXBkYXRlIG5lZWRlZGApO1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBbLi4ucHJldl07XG4gICAgICAgICAgbmV3U3RhdGVbY2F0ZWdvcnlJbmRleF0gPSB7XG4gICAgICAgICAgICAuLi5uZXdTdGF0ZVtjYXRlZ29yeUluZGV4XSxcbiAgICAgICAgICAgIHpvbmVzOiBlbmhhbmNlZFpvbmVzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQUZURVIgem9uZSB1cGRhdGUgKGNhbGN1bGF0ZWQpXScsIG5ld1N0YXRlKTtcbiAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExvZ2dlIGRlbiBTdGF0ZSBuYWNoIGRlciBBa3R1YWxpc2llcnVuZyAoaW0gbsOkY2hzdGVuIFJlbmRlci1aeWtsdXMpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQUZURVIgem9uZSB1cGRhdGUgKGFjdHVhbCldJywgY2F0ZWdvcmllcyk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBjb25zb2xlLmxvZyhgW0hhbmRsZXIgTG9naWMgRU5EXSBVcGRhdGUgWm9uZXMgZm9yIENhdGVnb3J5ICR7Y2F0ZWdvcnlJZH1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFt1c2VDYXRlZ29yaWVzIFJlYWx0aW1lXSBGZWhsZXIgYmVpbSBMYWRlbiBkZXIgWm9uZW4gZsO8ciBLYXRlZ29yaWUgJHtjYXRlZ29yeUlkfTpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfSwgW3NldENhdGVnb3JpZXNdKTsgLy8gTnVyIHZvbiBzdGFiaWxlbiBGdW5rdGlvbmVuIGFiaMOkbmdpZ1xuXG4gIGNvbnN0IGhhbmRsZUNhdGVnb3J5Um9sZUNoYW5nZSA9IHVzZUNhbGxiYWNrKChwYXlsb2FkOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWQ8YW55PikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbSEFORExFUiBDQUxMRURdIGhhbmRsZUNhdGVnb3J5Um9sZUNoYW5nZScsIHBheWxvYWQpOyAvLyA8LS0gTG9nZ2luZyBoaW56dWbDvGdlblxuICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBSZWFsdGltZV0gS2F0ZWdvcmllLVJvbGxlbi3DhG5kZXJ1bmcgZXJrYW5udDpgLCBwYXlsb2FkKTtcbiAgICAgY29uc3QgeyBuZXc6IG5ld1JlY29yZCwgb2xkOiBvbGRSZWNvcmQsIHRhYmxlIH0gPSBwYXlsb2FkO1xuXG4gICAgLy8gTnVyIGF1ZiByZWxldmFudGUgVGFiZWxsZW4gcmVhZ2llcmVuXG4gICAgaWYgKHRhYmxlICE9PSAnY2F0ZWdvcnlfZGlzY29yZF9yb2xlX3Blcm1pc3Npb25zJykge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgUmVhbHRpbWVdIElnbm9yaWVyZSBFdmVudCBmw7xyIFRhYmVsbGU6ICR7dGFibGV9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZWNvcmQgPSBuZXdSZWNvcmQgfHwgb2xkUmVjb3JkO1xuICAgIGlmICghcmVjb3JkIHx8ICFyZWNvcmQuY2F0ZWdvcnlfaWQpIHJldHVybjtcblxuICAgIGNvbnN0IGNhdGVnb3J5SWQgPSByZWNvcmQuY2F0ZWdvcnlfaWQ7XG5cbiAgICAvLyBMYWRlIGRpZSBiZXRyb2ZmZW5lIEthdGVnb3JpZSBuZXUsIHVtIGRpZSBSb2xsZW4genUgYWt0dWFsaXNpZXJlblxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0hhbmRsZXIgTG9naWMgU1RBUlRdIFVwZGF0ZSBSb2xlcyBmb3IgQ2F0ZWdvcnkgJHtjYXRlZ29yeUlkfWApO1xuICAgICAgICBjb25zdCBjYXRlZ29yeURhdGEgPSBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5nZXRDYXRlZ29yeUJ5SWQoY2F0ZWdvcnlJZCk7XG4gICAgICAgIGlmICghY2F0ZWdvcnlEYXRhKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljXSBDYXRlZ29yeSAke2NhdGVnb3J5SWR9IG5vdCBmb3VuZGApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQkVGT1JFIHJvbGUgdXBkYXRlXScsIGNhdGVnb3JpZXMpO1xuICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbUm9sZSBDaGFuZ2VdIFVwZGF0aW5nIHJvbGVzIGZvciBjYXRlZ29yeSAke2NhdGVnb3J5SWR9YCk7XG4gICAgICAgICAgY29uc3QgY2F0ZWdvcnlJbmRleCA9IHByZXYuZmluZEluZGV4KGMgPT4gYy5pZCA9PT0gY2F0ZWdvcnlJZCk7XG5cbiAgICAgICAgICBpZiAoY2F0ZWdvcnlJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUm9sZSBDaGFuZ2VdIENhdGVnb3J5ICR7Y2F0ZWdvcnlJZH0gbm90IGZvdW5kIGluIHN0YXRlLCBubyB1cGRhdGUgbmVlZGVkYCk7XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IFsuLi5wcmV2XTtcbiAgICAgICAgICBuZXdTdGF0ZVtjYXRlZ29yeUluZGV4XSA9IHtcbiAgICAgICAgICAgIC4uLm5ld1N0YXRlW2NhdGVnb3J5SW5kZXhdLFxuICAgICAgICAgICAgYWxsb3dlZFJvbGVzOiBjYXRlZ29yeURhdGEuYWxsb3dlZFJvbGVzIHx8IFtdXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQUZURVIgcm9sZSB1cGRhdGUgKGNhbGN1bGF0ZWQpXScsIG5ld1N0YXRlKTtcbiAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExvZ2dlIGRlbiBTdGF0ZSBuYWNoIGRlciBBa3R1YWxpc2llcnVuZyAoaW0gbsOkY2hzdGVuIFJlbmRlci1aeWtsdXMpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQUZURVIgcm9sZSB1cGRhdGUgKGFjdHVhbCldJywgY2F0ZWdvcmllcyk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBjb25zb2xlLmxvZyhgW0hhbmRsZXIgTG9naWMgRU5EXSBVcGRhdGUgUm9sZXMgZm9yIENhdGVnb3J5ICR7Y2F0ZWdvcnlJZH1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFt1c2VDYXRlZ29yaWVzIFJlYWx0aW1lXSBGZWhsZXIgYmVpbSBMYWRlbiBkZXIgUm9sbGVuYmVyZWNodGlndW5nZW4gZsO8ciBLYXRlZ29yaWUgJHtjYXRlZ29yeUlkfTpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfSwgW3NldENhdGVnb3JpZXNdKTsgLy8gTnVyIHZvbiBzdGFiaWxlbiBGdW5rdGlvbmVuIGFiaMOkbmdpZ1xuXG5cbiAgLy8gLS0tIEhhdXB0LXVzZUVmZmVjdCBmw7xyIExhZGVuIHVuZCBTdWJzY3JpcHRpb24gLS0tXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudEd1aWxkSWQgPSBjdXJyZW50R3VpbGQ/LmlkO1xuICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIFJ1bm5pbmcgZm9yIGd1aWxkSWQ6ICR7Y3VycmVudEd1aWxkSWQgfHwgJ25vbmUnfWApO1xuXG4gICAgaWYgKCFjdXJyZW50R3VpbGRJZCkge1xuICAgICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIEVmZmVjdF0gTm8gZ3VpbGRJZCwgcmVzZXR0aW5nLicpO1xuICAgICAgc2V0Q2F0ZWdvcmllcyhbXSk7XG4gICAgICBsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgIC8vIEFsdGUgU3Vic2NyaXB0aW9uIGVudGZlcm5lbiwgZmFsbHMgdm9yaGFuZGVuXG4gICAgICBpZiAocmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc3VwYWJhc2UucmVtb3ZlQ2hhbm5lbChyZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgIGNvbnNvbGUubG9nKCdbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIFJlbW92ZWQgb2xkIGNoYW5uZWwgb24gZ3VpbGRJZCBjbGVhci4nKTtcbiAgICAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBMYWRlbiwgd2VubiBkaWUgR3VpbGQgbmV1IGlzdCBvZGVyIGRpZSBEYXRlbiBmZWhsZW5cbiAgICBpZiAobG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ICE9PSBjdXJyZW50R3VpbGRJZCkge1xuICAgICAgbG9hZENhdGVnb3JpZXMoY3VycmVudEd1aWxkSWQpO1xuICAgIH1cblxuICAgIC8vIFN1YnNjcmlwdGlvbiBMb2dpayAodW52ZXLDpG5kZXJ0IHp1ciBsZXR6dGVuIFZlcnNpb24sIG51dHp0IGpldHp0IG1lbW9pemVkIEhhbmRsZXIpXG4gICAgbGV0IGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCB8IG51bGwgPSByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudDtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IGBjYXRlZ29yaWVzOiR7Y3VycmVudEd1aWxkSWR9YDtcblxuICAgIC8vIE51ciBzdWJzY3JpYmVuLCB3ZW5uIG5vY2ggbmljaHQgb2RlciBmw7xyIGFuZGVyZSBHdWlsZCBzdWJzY3JpYmVkXG4gICAgaWYgKCFjaGFubmVsIHx8IGNoYW5uZWwudG9waWMgIT09IGByZWFsdGltZToke2NoYW5uZWxOYW1lfWApIHtcbiAgICAgICAgLy8gQWx0ZSBTdWJzY3JpcHRpb24gc2ljaGVyIGVudGZlcm5lblxuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgc3VwYWJhc2UucmVtb3ZlQ2hhbm5lbChjaGFubmVsKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIFJlbW92ZWQgcHJldmlvdXMgY2hhbm5lbCBiZWZvcmUgbmV3IHN1YnNjcmlwdGlvbi4nKTtcbiAgICAgICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gbnVsbDsgLy8gV2ljaHRpZzogUmVmIHp1csO8Y2tzZXR6ZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIEVmZmVjdF0gU2V0dGluZyB1cCBjaGFubmVsOiAke2NoYW5uZWxOYW1lfWApO1xuICAgICAgICBjaGFubmVsID0gc3VwYWJhc2UuY2hhbm5lbChjaGFubmVsTmFtZSk7XG5cbiAgICAgICAgY2hhbm5lbFxuICAgICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjYXRlZ29yaWVzJyB9LCAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIFJBVyBFVkVOVCBjYXRlZ29yaWVzXScsIHBheWxvYWQpOyAvLyA8LS0gTG9nZ2luZyBoaW56dWbDvGdlblxuICAgICAgICAgICAgaGFuZGxlQ2F0ZWdvcnlDaGFuZ2UocGF5bG9hZCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnem9uZXMnIH0sIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXMgUkFXIEVWRU5UIHpvbmVzXScsIHBheWxvYWQpOyAvLyA8LS0gTG9nZ2luZyBoaW56dWbDvGdlblxuICAgICAgICAgICAgaGFuZGxlWm9uZUNoYW5nZUluQ2F0ZWdvcnkocGF5bG9hZCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnY2F0ZWdvcnlfZGlzY29yZF9yb2xlX3Blcm1pc3Npb25zJyB9LCAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIFJBVyBFVkVOVCBjYXRlZ29yeV9yb2xlc10nLCBwYXlsb2FkKTsgLy8gPC0tIExvZ2dpbmcgaGluenVmw7xnZW5cbiAgICAgICAgICAgIGhhbmRsZUNhdGVnb3J5Um9sZUNoYW5nZShwYXlsb2FkKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zdWJzY3JpYmUoKHN0YXR1cywgZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBTdWIgc3RhdHVzICR7Y2hhbm5lbE5hbWV9OmAsIHN0YXR1cywgZXJyIHx8ICcnKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdTVUJTQ1JJQkVEJykge1xuICAgICAgICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IGNoYW5uZWw7IC8vIFJlZiBlcnN0IGJlaSBFcmZvbGcgc2V0emVuXG4gICAgICAgICAgICAgIC8vIE5hY2ggZXJmb2xncmVpY2hlciBTdWJzY3JpcHRpb24gZXZ0bC4gbm9jaG1hbHMgbGFkZW4sIGZhbGxzIGluaXRpYWxGZXRjaCBmZWhsZ2VzY2hsYWdlblxuICAgICAgICAgICAgICBpZiAobG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ICE9PSBjdXJyZW50R3VpbGRJZCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIEVmZmVjdF0gUmUtZmV0Y2hpbmcgZGF0YSBhZnRlciBzdWNjZXNzZnVsIHN1YnNjcmlwdGlvbi4nKTtcbiAgICAgICAgICAgICAgICAgIGxvYWRDYXRlZ29yaWVzKGN1cnJlbnRHdWlsZElkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdDSEFOTkVMX0VSUk9SJyB8fCBzdGF0dXMgPT09ICdUSU1FRF9PVVQnKSB7XG4gICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIFN1YnNjcmlwdGlvbiBmYWlsZWQgZm9yICR7Y2hhbm5lbE5hbWV9OmAsIGVycik7XG4gICAgICAgICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IG51bGw7IC8vIEJlaSBGZWhsZXIgUmVmIHp1csO8Y2tzZXR6ZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBBbHJlYWR5IHN1YnNjcmliZWQgdG8gJHtjaGFubmVsTmFtZX1gKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwLUZ1bmt0aW9uXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIENsZWFudXAgZm9yIGd1aWxkSWQ6ICR7Y3VycmVudEd1aWxkSWR9YCk7XG4gICAgICAvLyBOdXIgZGVuIENoYW5uZWwgZW50ZmVybmVuLCBkZXIgKmluIGRpZXNlbSBFZmZla3QqIGVyc3RlbGx0IHd1cmRlXG4gICAgICBpZiAoY2hhbm5lbCAmJiAoIXJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50IHx8IHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID09PSBjaGFubmVsKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBSZW1vdmluZyBjaGFubmVsICR7Y2hhbm5lbC50b3BpY31gKTtcbiAgICAgICAgc3VwYWJhc2UucmVtb3ZlQ2hhbm5lbChjaGFubmVsKTtcbiAgICAgICAgaWYgKHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID09PSBjaGFubmVsKSB7XG4gICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIC8vIEFDSFRVTkc6IERpZSBIYW5kbGVyIGFscyBBYmjDpG5naWdrZWl0ZW4gc3RlbGxlbiBzaWNoZXIsIGRhc3MgZGVyIEVmZmVrdCBuZXUgbMOkdWZ0LCB3ZW5uXG4gIC8vIHNpY2ggaWhyZSBSZWZlcmVuemVuIMOkbmRlcm4gKHdhcyBzaWUgZGFuayB1c2VDYWxsYmFjayBudXIgdHVuIHNvbGx0ZW4sIHdlbm4gc2ljaCAqaWhyZSogRGVwcyDDpG5kZXJuKS5cbiAgLy8gYGxvYWRDYXRlZ29yaWVzYCBpc3QgZWJlbmZhbGxzIG1lbW9pc2llcnQuXG4gIH0sIFtjdXJyZW50R3VpbGQ/LmlkLCBsb2FkQ2F0ZWdvcmllcywgaGFuZGxlQ2F0ZWdvcnlDaGFuZ2UsIGhhbmRsZVpvbmVDaGFuZ2VJbkNhdGVnb3J5LCBoYW5kbGVDYXRlZ29yeVJvbGVDaGFuZ2VdKTtcblxuICAvLyAtLS0gUmVzdGxpY2hlIEZ1bmt0aW9uZW4gKHdlaXRnZWhlbmQgdW52ZXLDpG5kZXJ0LCBudXR6ZW4gamV0enQgc3RhYmlsZSBsb2FkQ2F0ZWdvcmllcykgLS0tXG4gIGNvbnN0IHRvZ2dsZUNhdGVnb3J5RXhwYW5kID0gdXNlQ2FsbGJhY2soKGNhdGVnb3J5SWQ6IHN0cmluZykgPT4ge1xuICAgIHNldEV4cGFuZGVkQ2F0ZWdvcmllcyhwcmV2RXhwYW5kZWQgPT5cbiAgICAgIHByZXZFeHBhbmRlZC5pbmNsdWRlcyhjYXRlZ29yeUlkKVxuICAgICAgICA/IHByZXZFeHBhbmRlZC5maWx0ZXIoaWQgPT4gaWQgIT09IGNhdGVnb3J5SWQpXG4gICAgICAgIDogWy4uLnByZXZFeHBhbmRlZCwgY2F0ZWdvcnlJZF1cbiAgICApO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2F2ZUNhdGVnb3J5ID0gdXNlQ2FsbGJhY2soYXN5bmMgKGNhdGVnb3J5RGF0YTogQ2F0ZWdvcnlJbnB1dCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGlmICghZ3VpbGRJZCkge1xuICAgICAgICB0b2FzdC5lcnJvcignS2VpbmUgR3VpbGQgYXVzZ2V3w6RobHQnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChjYXRlZ29yeURhdGEuaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZURhdGE6IFVwZGF0ZUNhdGVnb3J5RHRvID0ge1xuICAgICAgICAgICAgICBuYW1lOiBjYXRlZ29yeURhdGEubmFtZSxcbiAgICAgICAgICAgICAgaXNWaXNpYmxlRGVmYXVsdDogY2F0ZWdvcnlEYXRhLmlzVmlzaWJsZSxcbiAgICAgICAgICAgICAgc2V0dXBGbG93RW5hYmxlZDogY2F0ZWdvcnlEYXRhLnNlbmRTZXR1cCxcbiAgICAgICAgICAgICAgZGVmYXVsdFRyYWNraW5nRW5hYmxlZDogY2F0ZWdvcnlEYXRhLnRyYWNraW5nQWN0aXZlLFxuICAgICAgICAgICAgICBzZXR1cENoYW5uZWxOYW1lOiBjYXRlZ29yeURhdGEuc2V0dXBUZXh0Q2hhbm5lbCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHdhcnRlcmF1bUNoYW5uZWxOYW1lOiBjYXRlZ29yeURhdGEud2FpdGluZ1Jvb21OYW1lIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZGlzY29yZFJvbGVJZHM6IGNhdGVnb3J5RGF0YS5hbGxvd2VkUm9sZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS51cGRhdGVDYXRlZ29yeShjYXRlZ29yeURhdGEuaWQsIHVwZGF0ZURhdGEpO1xuICAgICAgICAgICAgdG9hc3Quc3VjY2VzcygnS2F0ZWdvcmllIGVyZm9sZ3JlaWNoIGFrdHVhbGlzaWVydCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlRGF0YTogQ3JlYXRlQ2F0ZWdvcnlEdG8gPSB7XG4gICAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGd1aWxkSWQsXG4gICAgICAgICAgICAgICAgc2NvcGVUeXBlOiBTY29wZVR5cGUuR1VJTEQsXG4gICAgICAgICAgICAgICAgc2NvcGVJZDogZ3VpbGRJZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBuYW1lOiBjYXRlZ29yeURhdGEubmFtZSxcbiAgICAgICAgICAgICAgaXNWaXNpYmxlRGVmYXVsdDogY2F0ZWdvcnlEYXRhLmlzVmlzaWJsZSxcbiAgICAgICAgICAgICAgc2V0dXBGbG93RW5hYmxlZDogY2F0ZWdvcnlEYXRhLnNlbmRTZXR1cCxcbiAgICAgICAgICAgICAgZGVmYXVsdFRyYWNraW5nRW5hYmxlZDogY2F0ZWdvcnlEYXRhLnRyYWNraW5nQWN0aXZlLFxuICAgICAgICAgICAgICBzZXR1cENoYW5uZWxOYW1lOiBjYXRlZ29yeURhdGEuc2V0dXBUZXh0Q2hhbm5lbCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHdhcnRlcmF1bUNoYW5uZWxOYW1lOiBjYXRlZ29yeURhdGEud2FpdGluZ1Jvb21OYW1lIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZGlzY29yZFJvbGVJZHM6IGNhdGVnb3J5RGF0YS5hbGxvd2VkUm9sZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5jcmVhdGVDYXRlZ29yeShjcmVhdGVEYXRhKTtcbiAgICAgICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ0thdGVnb3JpZSBlcmZvbGdyZWljaCBlcnN0ZWxsdCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlYWx0aW1lIHNvbGx0ZSBkaWUgQWt0dWFsaXNpZXJ1bmcgw7xiZXJuZWhtZW4sIGtlaW4gbWFudWVsbGVzIExhZGVuIG7DtnRpZ1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRmVobGVyIGJlaW0gU3BlaWNoZXJuIGRlciBLYXRlZ29yaWU6JywgZXJyKTtcbiAgICAgIHRvYXN0LmVycm9yKGVyci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnRmVobGVyIGJlaW0gU3BlaWNoZXJuIGRlciBLYXRlZ29yaWUnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbZ3VpbGRJZF0pOyAvLyBBYmjDpG5naWcgdm9uIGd1aWxkSWRcblxuICBjb25zdCBkZWxldGVDYXRlZ29yeSA9IHVzZUNhbGxiYWNrKGFzeW5jIChjYXRlZ29yeUlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZT86IHN0cmluZyB9PiA9PiB7XG4gICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgIHRyeSB7XG4gICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5kZWxldGVDYXRlZ29yeShjYXRlZ29yeUlkKTtcbiAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICB0b2FzdC5zdWNjZXNzKCdLYXRlZ29yaWUgZXJmb2xncmVpY2ggZ2Vsw7ZzY2h0Jyk7XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZlaGxlciBiZWltIEzDtnNjaGVuIGRlciBLYXRlZ29yaWU6JywgZXJyKTtcbiAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgJ0ZlaGxlciBiZWltIEzDtnNjaGVuIGRlciBLYXRlZ29yaWUnO1xuICAgICAgIHRvYXN0LmVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSB9O1xuICAgICB9IGZpbmFsbHkge1xuICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICB9XG4gIH0sIFtdKTsgLy8gS2VpbmUgQWJow6RuZ2lna2VpdGVuIG7DtnRpZ1xuXG4gIGNvbnN0IHJlZmV0Y2ggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzXSByZWZldGNoOiBTdGFydGUgTmV1bGFkZW4nKTtcbiAgICBpZiAoY3VycmVudEd1aWxkPy5pZCkge1xuICAgICAgbG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ID0gJyc7IC8vIEVyendpbmd0IE5ldWxhZGVuIGltIEVmZmVrdFxuICAgICAgbG9hZENhdGVnb3JpZXMoY3VycmVudEd1aWxkLmlkKTsgLy8gTMO2c3QgbWFudWVsbGVzIExhZGVuIGF1c1xuICAgIH1cbiAgfSwgW2N1cnJlbnRHdWlsZD8uaWQsIGxvYWRDYXRlZ29yaWVzXSk7XG5cbiAgY29uc3QgZ2V0VG90YWxTdGF0cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAvLyAuLi4gQmVyZWNobnVuZyB3aWUgYmlzaGVyIC4uLlxuICAgIHJldHVybiB7IHRvdGFsQ2F0ZWdvcmllczogMCwgdG90YWxVc2VyczogMCwgdG90YWxUaW1lOiAwfTsgLy8gUGxhY2Vob2xkZXJcbiAgfSwgW2NhdGVnb3JpZXNdKTtcblxuXG4gIHJldHVybiB7XG4gICAgY2F0ZWdvcmllcyxcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIGV4cGFuZGVkQ2F0ZWdvcmllcyxcbiAgICBzZWFyY2hRdWVyeSxcbiAgICBzZXRTZWFyY2hRdWVyeSxcbiAgICB0b2dnbGVDYXRlZ29yeUV4cGFuZCxcbiAgICBzYXZlQ2F0ZWdvcnksXG4gICAgLy8gdXBkYXRlQ2F0ZWdvcnlXaXRoWm9uZXMsIC8vIFdpcmQgamV0enQgZHVyY2ggUmVhbHRpbWUgSGFuZGxlciBhYmdlZGVja3RcbiAgICBkZWxldGVDYXRlZ29yeSxcbiAgICBnZXRUb3RhbFN0YXRzLFxuICAgIHJlZmV0Y2hcbiAgfTtcbn07Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ0b2FzdCIsInVzZUd1aWxkIiwiY2F0ZWdvcmllc1NlcnZpY2UiLCJ6b25lc1NlcnZpY2UiLCJTY29wZVR5cGUiLCJzdXBhYmFzZSIsInVzZUNhdGVnb3JpZXMiLCJjdXJyZW50R3VpbGQiLCJndWlsZElkIiwiaWQiLCJjb25zb2xlIiwibG9nIiwiY2F0ZWdvcmllcyIsInNldENhdGVnb3JpZXMiLCJleHBhbmRlZENhdGVnb3JpZXMiLCJzZXRFeHBhbmRlZENhdGVnb3JpZXMiLCJzZWFyY2hRdWVyeSIsInNldFNlYXJjaFF1ZXJ5IiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwicmVhbHRpbWVDaGFubmVsUmVmIiwibG9hZGVkR3VpbGRJZFJlZiIsImxvYWRDYXRlZ29yaWVzIiwiZ3VpbGRJZFRvTG9hZCIsImNhdGVnb3JpZXNEYXRhIiwiZ2V0Q2F0ZWdvcmllcyIsIkdVSUxEIiwiZW5oYW5jZWRDYXRlZ29yaWVzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImNhdGVnb3J5Iiwiem9uZXNEYXRhIiwiZ2V0Wm9uZXNCeUNhdGVnb3J5IiwiZW5oYW5jZWRab25lcyIsInpvbmUiLCJuYW1lIiwiem9uZUtleSIsIm1pbnV0ZXNSZXF1aXJlZCIsImludGVydmFsTWludXRlcyIsInBvaW50c0dyYW50ZWQiLCJwb2ludHNQZXJJbnRlcnZhbCIsImxhc3RBY3RpdmUiLCJ0b3RhbFRpbWVTcGVudCIsInRvdGFsVXNlcnMiLCJndWlsZF9pZCIsImFsbG93ZWRSb2xlcyIsImlzVmlzaWJsZSIsImlzVmlzaWJsZURlZmF1bHQiLCJzZW5kU2V0dXAiLCJzZXR1cEZsb3dFbmFibGVkIiwidHJhY2tpbmdBY3RpdmUiLCJkZWZhdWx0VHJhY2tpbmdFbmFibGVkIiwic2V0dXBUZXh0Q2hhbm5lbCIsInNldHVwQ2hhbm5lbElkIiwid2FpdGluZ1Jvb21OYW1lIiwid2FydGVyYXVtQ2hhbm5lbElkIiwiZGlzY29yZENhdGVnb3J5SWQiLCJkZWxldGVkSW5EaXNjb3JkIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInVwZGF0ZWRBdCIsInpvbmVzIiwiY3VycmVudCIsImxlbmd0aCIsImVyciIsImhhbmRsZUNhdGVnb3J5Q2hhbmdlIiwicGF5bG9hZCIsImV2ZW50VHlwZSIsIm5ldyIsIm5ld1JlY29yZCIsIm9sZCIsIm9sZFJlY29yZCIsInRhYmxlIiwicmVjb3JkIiwiY2F0ZWdvcnlJZCIsImNhdGVnb3J5RGF0YSIsImdldENhdGVnb3J5QnlJZCIsImVuaGFuY2VkQ2F0ZWdvcnkiLCJwcmV2IiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJjIiwibmV3U3RhdGUiLCJzZXRUaW1lb3V0IiwiZmlsdGVyIiwiaGFuZGxlWm9uZUNoYW5nZUluQ2F0ZWdvcnkiLCJjYXRlZ29yeV9pZCIsImNhdGVnb3J5SW5kZXgiLCJoYW5kbGVDYXRlZ29yeVJvbGVDaGFuZ2UiLCJjdXJyZW50R3VpbGRJZCIsInJlbW92ZUNoYW5uZWwiLCJ0aGVuIiwiY2hhbm5lbCIsImNoYW5uZWxOYW1lIiwidG9waWMiLCJvbiIsImV2ZW50Iiwic2NoZW1hIiwic3Vic2NyaWJlIiwic3RhdHVzIiwidG9nZ2xlQ2F0ZWdvcnlFeHBhbmQiLCJwcmV2RXhwYW5kZWQiLCJpbmNsdWRlcyIsInNhdmVDYXRlZ29yeSIsInVwZGF0ZURhdGEiLCJzZXR1cENoYW5uZWxOYW1lIiwidW5kZWZpbmVkIiwid2FydGVyYXVtQ2hhbm5lbE5hbWUiLCJkaXNjb3JkUm9sZUlkcyIsInVwZGF0ZUNhdGVnb3J5Iiwic3VjY2VzcyIsImNyZWF0ZURhdGEiLCJzY29wZSIsInNjb3BlVHlwZSIsInNjb3BlSWQiLCJjcmVhdGVDYXRlZ29yeSIsInJlc3BvbnNlIiwiZGF0YSIsIm1lc3NhZ2UiLCJkZWxldGVDYXRlZ29yeSIsInJlc3VsdCIsImVycm9yTWVzc2FnZSIsInJlZmV0Y2giLCJnZXRUb3RhbFN0YXRzIiwidG90YWxDYXRlZ29yaWVzIiwidG90YWxUaW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts\n"));

/***/ })

});