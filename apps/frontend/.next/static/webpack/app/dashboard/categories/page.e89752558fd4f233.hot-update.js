"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/categories/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/category-management/hooks/useZones.ts":
/*!************************************************************************!*\
  !*** ./src/components/dashboard/category-management/hooks/useZones.ts ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useZones: () => (/* binding */ useZones)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/core/toaster */ \"(app-pages-browser)/./src/components/core/toaster.tsx\");\n/* harmony import */ var _services_zones__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/services/zones */ \"(app-pages-browser)/./src/services/zones.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useZones auto */ \n\n// import { formatDate } from '../utils/formatters'; // Wahrscheinlich nicht benötigt\n// import { useGuild } from '@/context/guild-context'; // Nicht direkt benötigt\n\n\nconst useZones = (categoryId)=>{\n    // guildId wird hier nicht direkt benötigt\n    const [zones, setZones] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const realtimeChannelRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadedCategoryIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)('');\n    // --- Memoized Ladefunktion ---\n    const loadZones = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[loadZones]\": async (categoryIdToLoad)=>{\n            if (!categoryIdToLoad) {\n                console.log('[useZones] loadZones: Keine Kategorie ID.');\n                setZones([]);\n                return;\n            }\n            console.log(\"[useZones] loadZones aufgerufen f\\xfcr Kategorie: \".concat(categoryIdToLoad));\n            setLoading(true);\n            setError(null);\n            try {\n                const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_2__.getZonesByCategory(categoryIdToLoad);\n                const enhancedZones = zonesData.map({\n                    \"useZones.useCallback[loadZones].enhancedZones\": (zone)=>({\n                            id: zone.id,\n                            name: zone.name,\n                            zoneKey: zone.zoneKey,\n                            minutesRequired: zone.intervalMinutes,\n                            pointsGranted: zone.pointsPerInterval,\n                            lastActive: '-',\n                            totalTimeSpent: 0,\n                            totalUsers: 0\n                        })\n                }[\"useZones.useCallback[loadZones].enhancedZones\"]);\n                setZones(enhancedZones);\n                loadedCategoryIdRef.current = categoryIdToLoad;\n                console.log(\"[useZones] loadZones: \".concat(enhancedZones.length, \" Zonen geladen f\\xfcr \").concat(categoryIdToLoad));\n            } catch (err) {\n                console.error(\"[useZones] Fehler beim Laden der Zonen f\\xfcr \".concat(categoryIdToLoad, \":\"), err);\n                setError('Fehler beim Laden der Zonen');\n                setZones([]);\n                loadedCategoryIdRef.current = categoryIdToLoad; // Trotz Fehler als geladen markieren\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useZones.useCallback[loadZones]\"], []); // Keine Abhängigkeiten\n    // --- Memoized Realtime Handler ---\n    const handleZoneChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[handleZoneChange]\": (payload)=>{\n            console.log('[HANDLER CALLED] handleZoneChange', payload); // <-- Logging hinzufügen\n            console.log(\"[useZones Realtime] Zonen-\\xc4nderung erkannt:\", payload);\n            const { eventType, new: newRecord, old: oldRecord, table, schema } = payload;\n            // Filterung: Nur auf 'zones' Tabelle und korrektes Schema reagieren\n            if (schema !== 'public' || table !== 'zones') return;\n            // Filterung: Nur auf Änderungen reagieren, die die aktuelle categoryId betreffen\n            const newRecordCategoryId = newRecord ? newRecord.category_id : null;\n            const oldRecordCategoryId = oldRecord ? oldRecord.category_id : null;\n            if (newRecordCategoryId !== categoryId && oldRecordCategoryId !== categoryId) {\n                console.log(\"[useZones Realtime] Event ignoriert, falsche Category ID.\");\n                return;\n            }\n            const record = newRecord || oldRecord;\n            if (!record || !record.id) return;\n            const zoneId = record.id;\n            switch(eventType){\n                case 'INSERT':\n                case 'UPDATE':\n                    ({\n                        \"useZones.useCallback[handleZoneChange]\": async ()=>{\n                            try {\n                                console.log(\"[Handler Logic START] \".concat(eventType, \" Zone\"));\n                                // Lade die (neue/aktualisierte) Zone\n                                const zoneData = await _services_zones__WEBPACK_IMPORTED_MODULE_2__.getZoneById(zoneId);\n                                // Vollständiges Mapping statt Platzhalter\n                                const enhancedZone = {\n                                    id: zoneData.id,\n                                    name: zoneData.name,\n                                    zoneKey: zoneData.zoneKey,\n                                    minutesRequired: zoneData.intervalMinutes,\n                                    pointsGranted: zoneData.pointsPerInterval,\n                                    lastActive: '-',\n                                    totalTimeSpent: 0,\n                                    totalUsers: 0\n                                };\n                                console.log('[Zones State BEFORE update]', zones);\n                                setZones({\n                                    \"useZones.useCallback[handleZoneChange]\": (prev)=>{\n                                        const index = prev.findIndex({\n                                            \"useZones.useCallback[handleZoneChange].index\": (z)=>z.id === zoneId\n                                        }[\"useZones.useCallback[handleZoneChange].index\"]);\n                                        let newState;\n                                        if (index !== -1) {\n                                            console.log(\"[Zone \".concat(eventType, \"] Updating existing zone at index \").concat(index));\n                                            newState = [\n                                                ...prev\n                                            ];\n                                            newState[index] = enhancedZone;\n                                        } else {\n                                            // Nur hinzufügen, wenn es wirklich zu dieser Kategorie gehört\n                                            if (zoneData.categoryId === categoryId) {\n                                                console.log(\"[Zone \".concat(eventType, \"] Adding new zone to category \").concat(categoryId));\n                                                newState = [\n                                                    ...prev,\n                                                    enhancedZone\n                                                ];\n                                            } else {\n                                                console.log(\"[Zone \".concat(eventType, \"] Zone belongs to different category, ignoring\"));\n                                                newState = prev;\n                                            }\n                                        }\n                                        console.log('[Zones State AFTER update (calculated)]', newState);\n                                        return newState;\n                                    }\n                                }[\"useZones.useCallback[handleZoneChange]\"]);\n                                // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                                setTimeout({\n                                    \"useZones.useCallback[handleZoneChange]\": ()=>{\n                                        console.log('[Zones State AFTER update (actual)]', zones);\n                                    }\n                                }[\"useZones.useCallback[handleZoneChange]\"], 0);\n                                console.log(\"[Handler Logic END] \".concat(eventType, \" Zone\"));\n                            } catch (error) {\n                                console.error(\"[useZones Realtime] Fehler beim Verarbeiten \".concat(eventType, \":\"), error);\n                            }\n                        }\n                    })[\"useZones.useCallback[handleZoneChange]\"]();\n                    break;\n                case 'DELETE':\n                    if (oldRecord === null || oldRecord === void 0 ? void 0 : oldRecord.id) {\n                        console.log(\"[Handler Logic START] DELETE Zone \".concat(oldRecord.id));\n                        console.log('[Zones State BEFORE delete]', zones);\n                        setZones({\n                            \"useZones.useCallback[handleZoneChange]\": (prev)=>{\n                                console.log(\"[Zone DELETE] Removing zone with id \".concat(oldRecord.id));\n                                const newState = prev.filter({\n                                    \"useZones.useCallback[handleZoneChange].newState\": (zone)=>zone.id !== oldRecord.id\n                                }[\"useZones.useCallback[handleZoneChange].newState\"]);\n                                console.log('[Zones State AFTER delete (calculated)]', newState);\n                                return newState;\n                            }\n                        }[\"useZones.useCallback[handleZoneChange]\"]);\n                        // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                        setTimeout({\n                            \"useZones.useCallback[handleZoneChange]\": ()=>{\n                                console.log('[Zones State AFTER delete (actual)]', zones);\n                            }\n                        }[\"useZones.useCallback[handleZoneChange]\"], 0);\n                        console.log(\"[Handler Logic END] DELETE Zone \".concat(oldRecord.id));\n                    }\n                    break;\n                default:\n                    console.log(\"[useZones Realtime] Unbekannter Event-Typ f\\xfcr zones: \".concat(eventType));\n            }\n        }\n    }[\"useZones.useCallback[handleZoneChange]\"], [\n        categoryId,\n        zones,\n        setZones,\n        _services_zones__WEBPACK_IMPORTED_MODULE_2__\n    ]); // Abhängigkeiten für korrekte Aktualisierung\n    // --- Haupt-useEffect ---\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useZones.useEffect\": ()=>{\n            console.log(\"[useZones Effect] Running for categoryId: \".concat(categoryId || 'none'));\n            if (!categoryId) {\n                console.log('[useZones Effect] No categoryId, resetting.');\n                setZones([]);\n                loadedCategoryIdRef.current = '';\n                if (realtimeChannelRef.current) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.removeChannel(realtimeChannelRef.current).then({\n                        \"useZones.useEffect\": ()=>{\n                            console.log('[useZones Effect] Removed old channel on categoryId clear.');\n                            realtimeChannelRef.current = null;\n                        }\n                    }[\"useZones.useEffect\"]);\n                }\n                return;\n            }\n            if (loadedCategoryIdRef.current !== categoryId) {\n                loadZones(categoryId);\n            }\n            // Subscription Logik\n            let channel = realtimeChannelRef.current;\n            const channelName = \"zones:\".concat(categoryId);\n            if (!channel || channel.topic !== \"realtime:\".concat(channelName)) {\n                if (channel) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.removeChannel(channel).then({\n                        \"useZones.useEffect\": ()=>{\n                            console.log('[useZones Effect] Removed previous channel.');\n                            realtimeChannelRef.current = null;\n                        }\n                    }[\"useZones.useEffect\"]);\n                }\n                console.log(\"[useZones Effect] Setting up channel: \".concat(channelName));\n                channel = _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.channel(channelName);\n                channel.on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'zones',\n                    filter: \"category_id=eq.\".concat(categoryId) // Filter auf Server-Seite!\n                }, {\n                    \"useZones.useEffect\": (payload)=>{\n                        console.log('[useZones RAW EVENT zones]', payload); // <-- Logging hinzufügen\n                        handleZoneChange(payload);\n                    }\n                }[\"useZones.useEffect\"]).subscribe({\n                    \"useZones.useEffect\": (status, err)=>{\n                        console.log(\"[useZones Effect] Sub status \".concat(channelName, \":\"), status, err || '');\n                        if (status === 'SUBSCRIBED') {\n                            realtimeChannelRef.current = channel;\n                            if (loadedCategoryIdRef.current !== categoryId) {\n                                loadZones(categoryId); // Erneutes Laden nach erfolgreicher Subscription\n                            }\n                        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {\n                            console.error(\"[useZones Effect] Subscription failed for \".concat(channelName, \":\"), err);\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }[\"useZones.useEffect\"]);\n            }\n            // Cleanup\n            return ({\n                \"useZones.useEffect\": ()=>{\n                    console.log(\"[useZones Effect] Cleanup for categoryId: \".concat(categoryId));\n                    if (channel && (!realtimeChannelRef.current || realtimeChannelRef.current === channel)) {\n                        console.log(\"[useZones Effect] Removing channel \".concat(channel.topic));\n                        _lib_supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.removeChannel(channel);\n                        if (realtimeChannelRef.current === channel) {\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }\n            })[\"useZones.useEffect\"];\n        }\n    }[\"useZones.useEffect\"], [\n        categoryId,\n        loadZones,\n        handleZoneChange\n    ]); // Korrekte Abhängigkeiten\n    // --- Restliche Funktionen (weitgehend unverändert) ---\n    const saveZone = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[saveZone]\": async (zoneData)=>{\n            if (!categoryId) {\n                return false;\n            }\n            setLoading(true);\n            try {\n                if (zoneData.id) {} else {}\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Zone gespeichert.');\n                return true;\n            } catch (err) {\n                return false;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useZones.useCallback[saveZone]\"], [\n        categoryId\n    ]);\n    const deleteZone = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[deleteZone]\": async (zoneId)=>{\n            setLoading(true);\n            try {\n                const result = await _services_zones__WEBPACK_IMPORTED_MODULE_2__.deleteZone(zoneId);\n                if (result.success) _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Zone gelöscht.');\n                return result;\n            } catch (err) {\n                return {\n                    success: false,\n                    message: 'Fehler'\n                };\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useZones.useCallback[deleteZone]\"], []);\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useZones.useCallback[refetch]\": ()=>{\n            console.log('[useZones] refetch: Starte Neuladen');\n            if (categoryId) {\n                loadedCategoryIdRef.current = '';\n                loadZones(categoryId);\n            }\n        }\n    }[\"useZones.useCallback[refetch]\"], [\n        categoryId,\n        loadZones\n    ]);\n    return {\n        zones,\n        loading,\n        error,\n        saveZone,\n        deleteZone,\n        refetch\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9jYXRlZ29yeS1tYW5hZ2VtZW50L2hvb2tzL3VzZVpvbmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs4REFFaUU7QUFDZjtBQUVsRCxxRkFBcUY7QUFDckYsK0VBQStFO0FBQzlCO0FBR1A7QUFXbkMsTUFBTU8sV0FBVyxDQUFDQztJQUN2QiwwQ0FBMEM7SUFDMUMsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdWLCtDQUFRQSxDQUFpQixFQUFFO0lBQ3JELE1BQU0sQ0FBQ1csU0FBU0MsV0FBVyxHQUFHWiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNhLE9BQU9DLFNBQVMsR0FBR2QsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU1lLHFCQUFxQlosNkNBQU1BLENBQXlCO0lBQzFELE1BQU1hLHNCQUFzQmIsNkNBQU1BLENBQVM7SUFFM0MsZ0NBQWdDO0lBQ2hDLE1BQU1jLFlBQVlmLGtEQUFXQTsyQ0FBQyxPQUFPZ0I7WUFDbkMsSUFBSSxDQUFDQSxrQkFBa0I7Z0JBQ3JCQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1pWLFNBQVMsRUFBRTtnQkFDWDtZQUNGO1lBQ0FTLFFBQVFDLEdBQUcsQ0FBQyxxREFBbUUsT0FBakJGO1lBQzlETixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxJQUFJO2dCQUNGLE1BQU1PLFlBQVksTUFBTWhCLCtEQUErQixDQUFDYTtnQkFDeEQsTUFBTUssZ0JBQWdDRixVQUFVRyxHQUFHO3FFQUFDQyxDQUFBQSxPQUFTOzRCQUMzREMsSUFBSUQsS0FBS0MsRUFBRTs0QkFDWEMsTUFBTUYsS0FBS0UsSUFBSTs0QkFDZkMsU0FBU0gsS0FBS0csT0FBTzs0QkFDckJDLGlCQUFpQkosS0FBS0ssZUFBZTs0QkFDckNDLGVBQWVOLEtBQUtPLGlCQUFpQjs0QkFDckNDLFlBQVk7NEJBQ1pDLGdCQUFnQjs0QkFDaEJDLFlBQVk7d0JBQ2Q7O2dCQUVBekIsU0FBU2E7Z0JBQ1RQ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Q0FBRztRQUFDSjtLQUFXO0lBRWYsTUFBTWtFLGFBQWF4RSxrREFBV0E7NENBQUMsT0FBT2tEO1lBQ2xDeEMsV0FBVztZQUNYLElBQUk7Z0JBQ0QsTUFBTStELFNBQVMsTUFBTXRFLHVEQUF1QixDQUFDK0M7Z0JBQzdDLElBQUl1QixPQUFPRixPQUFPLEVBQUVyRSwyREFBS0EsQ0FBQ3FFLE9BQU8sQ0FBQztnQkFDbEMsT0FBT0U7WUFDVixFQUFFLE9BQU9yQyxLQUFVO2dCQUF1QixPQUFPO29CQUFFbUMsU0FBUztvQkFBT0csU0FBUztnQkFBUztZQUFHLFNBQ2hGO2dCQUFFaEUsV0FBVztZQUFRO1FBQ2pDOzJDQUFHLEVBQUU7SUFFTCxNQUFNaUUsVUFBVTNFLGtEQUFXQTt5Q0FBQztZQUMxQmlCLFFBQVFDLEdBQUcsQ0FBQztZQUNaLElBQUlaLFlBQVk7Z0JBQ2RRLG9CQUFvQm9CLE9BQU8sR0FBRztnQkFDOUJuQixVQUFVVDtZQUNaO1FBQ0Y7d0NBQUc7UUFBQ0E7UUFBWVM7S0FBVTtJQUcxQixPQUFPO1FBQUVSO1FBQU9FO1FBQVNFO1FBQU8yRDtRQUFVRTtRQUFZRztJQUFRO0FBQ2hFLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaW5mb1xcRG9jdW1lbnRzXFxEaXNjb3JkIEJvdFxcQ2hpbWVyYVxcYXBwc1xcZnJvbnRlbmRcXHNyY1xcY29tcG9uZW50c1xcZGFzaGJvYXJkXFxjYXRlZ29yeS1tYW5hZ2VtZW50XFxob29rc1xcdXNlWm9uZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdG9hc3QgfSBmcm9tICdAL2NvbXBvbmVudHMvY29yZS90b2FzdGVyJztcbmltcG9ydCB7IEVuaGFuY2VkWm9uZSB9IGZyb20gJy4vdXNlQ2F0ZWdvcmllcyc7IC8vIFR5cCBpbXBvcnRpZXJlblxuLy8gaW1wb3J0IHsgZm9ybWF0RGF0ZSB9IGZyb20gJy4uL3V0aWxzL2Zvcm1hdHRlcnMnOyAvLyBXYWhyc2NoZWlubGljaCBuaWNodCBiZW7DtnRpZ3Rcbi8vIGltcG9ydCB7IHVzZUd1aWxkIH0gZnJvbSAnQC9jb250ZXh0L2d1aWxkLWNvbnRleHQnOyAvLyBOaWNodCBkaXJla3QgYmVuw7Z0aWd0XG5pbXBvcnQgKiBhcyB6b25lc1NlcnZpY2UgZnJvbSAnQC9zZXJ2aWNlcy96b25lcyc7XG5pbXBvcnQgeyBDcmVhdGVab25lRHRvLCBVcGRhdGVab25lRHRvLCBab25lRHRvIH0gZnJvbSAnc2hhcmVkLXR5cGVzJzsgLy8gSW1wb3J0IFpvbmVEdG9cbmltcG9ydCB7IFJlYWx0aW1lQ2hhbm5lbCwgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkIH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuXG4vLyBJbnRlcmZhY2UgYmxlaWJ0IGdsZWljaC4uLlxuZXhwb3J0IGludGVyZmFjZSBab25lSW5wdXQge1xuICBpZD86IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB6b25lS2V5OiBzdHJpbmc7XG4gIG1pbnV0ZXNSZXF1aXJlZDogbnVtYmVyO1xuICBwb2ludHNHcmFudGVkOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCB1c2Vab25lcyA9IChjYXRlZ29yeUlkPzogc3RyaW5nKSA9PiB7XG4gIC8vIGd1aWxkSWQgd2lyZCBoaWVyIG5pY2h0IGRpcmVrdCBiZW7DtnRpZ3RcbiAgY29uc3QgW3pvbmVzLCBzZXRab25lc10gPSB1c2VTdGF0ZTxFbmhhbmNlZFpvbmVbXT4oW10pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlYWx0aW1lQ2hhbm5lbFJlZiA9IHVzZVJlZjxSZWFsdGltZUNoYW5uZWwgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbG9hZGVkQ2F0ZWdvcnlJZFJlZiA9IHVzZVJlZjxzdHJpbmc+KCcnKTtcblxuICAvLyAtLS0gTWVtb2l6ZWQgTGFkZWZ1bmt0aW9uIC0tLVxuICBjb25zdCBsb2FkWm9uZXMgPSB1c2VDYWxsYmFjayhhc3luYyAoY2F0ZWdvcnlJZFRvTG9hZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFjYXRlZ29yeUlkVG9Mb2FkKSB7XG4gICAgICBjb25zb2xlLmxvZygnW3VzZVpvbmVzXSBsb2FkWm9uZXM6IEtlaW5lIEthdGVnb3JpZSBJRC4nKTtcbiAgICAgIHNldFpvbmVzKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coYFt1c2Vab25lc10gbG9hZFpvbmVzIGF1ZmdlcnVmZW4gZsO8ciBLYXRlZ29yaWU6ICR7Y2F0ZWdvcnlJZFRvTG9hZH1gKTtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHpvbmVzRGF0YSA9IGF3YWl0IHpvbmVzU2VydmljZS5nZXRab25lc0J5Q2F0ZWdvcnkoY2F0ZWdvcnlJZFRvTG9hZCk7XG4gICAgICBjb25zdCBlbmhhbmNlZFpvbmVzOiBFbmhhbmNlZFpvbmVbXSA9IHpvbmVzRGF0YS5tYXAoem9uZSA9PiAoe1xuICAgICAgICBpZDogem9uZS5pZCxcbiAgICAgICAgbmFtZTogem9uZS5uYW1lLFxuICAgICAgICB6b25lS2V5OiB6b25lLnpvbmVLZXksXG4gICAgICAgIG1pbnV0ZXNSZXF1aXJlZDogem9uZS5pbnRlcnZhbE1pbnV0ZXMsXG4gICAgICAgIHBvaW50c0dyYW50ZWQ6IHpvbmUucG9pbnRzUGVySW50ZXJ2YWwsXG4gICAgICAgIGxhc3RBY3RpdmU6ICctJyxcbiAgICAgICAgdG90YWxUaW1lU3BlbnQ6IDAsXG4gICAgICAgIHRvdGFsVXNlcnM6IDBcbiAgICAgIH0pKTtcblxuICAgICAgc2V0Wm9uZXMoZW5oYW5jZWRab25lcyk7XG4gICAgICBsb2FkZWRDYXRlZ29yeUlkUmVmLmN1cnJlbnQgPSBjYXRlZ29yeUlkVG9Mb2FkO1xuICAgICAgY29uc29sZS5sb2coYFt1c2Vab25lc10gbG9hZFpvbmVzOiAke2VuaGFuY2VkWm9uZXMubGVuZ3RofSBab25lbiBnZWxhZGVuIGbDvHIgJHtjYXRlZ29yeUlkVG9Mb2FkfWApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgW3VzZVpvbmVzXSBGZWhsZXIgYmVpbSBMYWRlbiBkZXIgWm9uZW4gZsO8ciAke2NhdGVnb3J5SWRUb0xvYWR9OmAsIGVycik7XG4gICAgICBzZXRFcnJvcignRmVobGVyIGJlaW0gTGFkZW4gZGVyIFpvbmVuJyk7XG4gICAgICBzZXRab25lcyhbXSk7XG4gICAgICBsb2FkZWRDYXRlZ29yeUlkUmVmLmN1cnJlbnQgPSBjYXRlZ29yeUlkVG9Mb2FkOyAvLyBUcm90eiBGZWhsZXIgYWxzIGdlbGFkZW4gbWFya2llcmVuXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW10pOyAvLyBLZWluZSBBYmjDpG5naWdrZWl0ZW5cblxuICAvLyAtLS0gTWVtb2l6ZWQgUmVhbHRpbWUgSGFuZGxlciAtLS1cbiAgY29uc3QgaGFuZGxlWm9uZUNoYW5nZSA9IHVzZUNhbGxiYWNrKChwYXlsb2FkOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWQ8YW55PikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbSEFORExFUiBDQUxMRURdIGhhbmRsZVpvbmVDaGFuZ2UnLCBwYXlsb2FkKTsgLy8gPC0tIExvZ2dpbmcgaGluenVmw7xnZW5cbiAgICBjb25zb2xlLmxvZyhgW3VzZVpvbmVzIFJlYWx0aW1lXSBab25lbi3DhG5kZXJ1bmcgZXJrYW5udDpgLCBwYXlsb2FkKTtcbiAgICBjb25zdCB7IGV2ZW50VHlwZSwgbmV3OiBuZXdSZWNvcmQsIG9sZDogb2xkUmVjb3JkLCB0YWJsZSwgc2NoZW1hIH0gPSBwYXlsb2FkO1xuXG4gICAgLy8gRmlsdGVydW5nOiBOdXIgYXVmICd6b25lcycgVGFiZWxsZSB1bmQga29ycmVrdGVzIFNjaGVtYSByZWFnaWVyZW5cbiAgICBpZiAoc2NoZW1hICE9PSAncHVibGljJyB8fCB0YWJsZSAhPT0gJ3pvbmVzJykgcmV0dXJuO1xuICAgIC8vIEZpbHRlcnVuZzogTnVyIGF1ZiDDhG5kZXJ1bmdlbiByZWFnaWVyZW4sIGRpZSBkaWUgYWt0dWVsbGUgY2F0ZWdvcnlJZCBiZXRyZWZmZW5cbiAgICBjb25zdCBuZXdSZWNvcmRDYXRlZ29yeUlkID0gbmV3UmVjb3JkID8gKG5ld1JlY29yZCBhcyBhbnkpLmNhdGVnb3J5X2lkIDogbnVsbDtcbiAgICBjb25zdCBvbGRSZWNvcmRDYXRlZ29yeUlkID0gb2xkUmVjb3JkID8gKG9sZFJlY29yZCBhcyBhbnkpLmNhdGVnb3J5X2lkIDogbnVsbDtcblxuICAgIGlmIChuZXdSZWNvcmRDYXRlZ29yeUlkICE9PSBjYXRlZ29yeUlkICYmIG9sZFJlY29yZENhdGVnb3J5SWQgIT09IGNhdGVnb3J5SWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2Vab25lcyBSZWFsdGltZV0gRXZlbnQgaWdub3JpZXJ0LCBmYWxzY2hlIENhdGVnb3J5IElELmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICBjb25zdCByZWNvcmQgPSBuZXdSZWNvcmQgfHwgb2xkUmVjb3JkO1xuICAgIGlmICghcmVjb3JkIHx8ICFyZWNvcmQuaWQpIHJldHVybjtcblxuICAgIGNvbnN0IHpvbmVJZCA9IHJlY29yZC5pZDtcblxuICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlICdJTlNFUlQnOlxuICAgICAgY2FzZSAnVVBEQVRFJzpcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljIFNUQVJUXSAke2V2ZW50VHlwZX0gWm9uZWApO1xuICAgICAgICAgICAgLy8gTGFkZSBkaWUgKG5ldWUvYWt0dWFsaXNpZXJ0ZSkgWm9uZVxuICAgICAgICAgICAgY29uc3Qgem9uZURhdGEgPSBhd2FpdCB6b25lc1NlcnZpY2UuZ2V0Wm9uZUJ5SWQoem9uZUlkKTtcblxuICAgICAgICAgICAgLy8gVm9sbHN0w6RuZGlnZXMgTWFwcGluZyBzdGF0dCBQbGF0emhhbHRlclxuICAgICAgICAgICAgY29uc3QgZW5oYW5jZWRab25lOiBFbmhhbmNlZFpvbmUgPSB7XG4gICAgICAgICAgICAgIGlkOiB6b25lRGF0YS5pZCxcbiAgICAgICAgICAgICAgbmFtZTogem9uZURhdGEubmFtZSxcbiAgICAgICAgICAgICAgem9uZUtleTogem9uZURhdGEuem9uZUtleSxcbiAgICAgICAgICAgICAgbWludXRlc1JlcXVpcmVkOiB6b25lRGF0YS5pbnRlcnZhbE1pbnV0ZXMsXG4gICAgICAgICAgICAgIHBvaW50c0dyYW50ZWQ6IHpvbmVEYXRhLnBvaW50c1BlckludGVydmFsLFxuICAgICAgICAgICAgICBsYXN0QWN0aXZlOiAnLScsXG4gICAgICAgICAgICAgIHRvdGFsVGltZVNwZW50OiAwLFxuICAgICAgICAgICAgICB0b3RhbFVzZXJzOiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1pvbmVzIFN0YXRlIEJFRk9SRSB1cGRhdGVdJywgem9uZXMpO1xuICAgICAgICAgICAgc2V0Wm9uZXMocHJldiA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcHJldi5maW5kSW5kZXgoeiA9PiB6LmlkID09PSB6b25lSWQpO1xuICAgICAgICAgICAgICBsZXQgbmV3U3RhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbWm9uZSAke2V2ZW50VHlwZX1dIFVwZGF0aW5nIGV4aXN0aW5nIHpvbmUgYXQgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFsuLi5wcmV2XTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZVtpbmRleF0gPSBlbmhhbmNlZFpvbmU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTnVyIGhpbnp1ZsO8Z2VuLCB3ZW5uIGVzIHdpcmtsaWNoIHp1IGRpZXNlciBLYXRlZ29yaWUgZ2Vow7ZydFxuICAgICAgICAgICAgICAgIGlmICh6b25lRGF0YS5jYXRlZ29yeUlkID09PSBjYXRlZ29yeUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbWm9uZSAke2V2ZW50VHlwZX1dIEFkZGluZyBuZXcgem9uZSB0byBjYXRlZ29yeSAke2NhdGVnb3J5SWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gWy4uLnByZXYsIGVuaGFuY2VkWm9uZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtab25lICR7ZXZlbnRUeXBlfV0gWm9uZSBiZWxvbmdzIHRvIGRpZmZlcmVudCBjYXRlZ29yeSwgaWdub3JpbmdgKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbWm9uZXMgU3RhdGUgQUZURVIgdXBkYXRlIChjYWxjdWxhdGVkKV0nLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBMb2dnZSBkZW4gU3RhdGUgbmFjaCBkZXIgQWt0dWFsaXNpZXJ1bmcgKGltIG7DpGNoc3RlbiBSZW5kZXItWnlrbHVzKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbWm9uZXMgU3RhdGUgQUZURVIgdXBkYXRlIChhY3R1YWwpXScsIHpvbmVzKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljIEVORF0gJHtldmVudFR5cGV9IFpvbmVgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW3VzZVpvbmVzIFJlYWx0aW1lXSBGZWhsZXIgYmVpbSBWZXJhcmJlaXRlbiAke2V2ZW50VHlwZX06YCwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdERUxFVEUnOlxuICAgICAgICBpZiAob2xkUmVjb3JkPy5pZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFuZGxlciBMb2dpYyBTVEFSVF0gREVMRVRFIFpvbmUgJHtvbGRSZWNvcmQuaWR9YCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tab25lcyBTdGF0ZSBCRUZPUkUgZGVsZXRlXScsIHpvbmVzKTtcblxuICAgICAgICAgIHNldFpvbmVzKHByZXYgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtab25lIERFTEVURV0gUmVtb3Zpbmcgem9uZSB3aXRoIGlkICR7b2xkUmVjb3JkLmlkfWApO1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBwcmV2LmZpbHRlcih6b25lID0+IHpvbmUuaWQgIT09IG9sZFJlY29yZC5pZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1pvbmVzIFN0YXRlIEFGVEVSIGRlbGV0ZSAoY2FsY3VsYXRlZCldJywgbmV3U3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gTG9nZ2UgZGVuIFN0YXRlIG5hY2ggZGVyIEFrdHVhbGlzaWVydW5nIChpbSBuw6RjaHN0ZW4gUmVuZGVyLVp5a2x1cylcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbWm9uZXMgU3RhdGUgQUZURVIgZGVsZXRlIChhY3R1YWwpXScsIHpvbmVzKTtcbiAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFuZGxlciBMb2dpYyBFTkRdIERFTEVURSBab25lICR7b2xkUmVjb3JkLmlkfWApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2Vab25lcyBSZWFsdGltZV0gVW5iZWthbm50ZXIgRXZlbnQtVHlwIGbDvHIgem9uZXM6ICR7ZXZlbnRUeXBlfWApO1xuICAgIH1cbiAgfSwgW2NhdGVnb3J5SWQsIHpvbmVzLCBzZXRab25lcywgem9uZXNTZXJ2aWNlXSk7IC8vIEFiaMOkbmdpZ2tlaXRlbiBmw7xyIGtvcnJla3RlIEFrdHVhbGlzaWVydW5nXG5cbiAgLy8gLS0tIEhhdXB0LXVzZUVmZmVjdCAtLS1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhgW3VzZVpvbmVzIEVmZmVjdF0gUnVubmluZyBmb3IgY2F0ZWdvcnlJZDogJHtjYXRlZ29yeUlkIHx8ICdub25lJ31gKTtcblxuICAgIGlmICghY2F0ZWdvcnlJZCkge1xuICAgICAgY29uc29sZS5sb2coJ1t1c2Vab25lcyBFZmZlY3RdIE5vIGNhdGVnb3J5SWQsIHJlc2V0dGluZy4nKTtcbiAgICAgIHNldFpvbmVzKFtdKTtcbiAgICAgIGxvYWRlZENhdGVnb3J5SWRSZWYuY3VycmVudCA9ICcnO1xuICAgICAgaWYgKHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwocmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2Vab25lcyBFZmZlY3RdIFJlbW92ZWQgb2xkIGNoYW5uZWwgb24gY2F0ZWdvcnlJZCBjbGVhci4nKTtcbiAgICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxvYWRlZENhdGVnb3J5SWRSZWYuY3VycmVudCAhPT0gY2F0ZWdvcnlJZCkge1xuICAgICAgbG9hZFpvbmVzKGNhdGVnb3J5SWQpO1xuICAgIH1cblxuICAgIC8vIFN1YnNjcmlwdGlvbiBMb2dpa1xuICAgIGxldCBjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwgfCBudWxsID0gcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgem9uZXM6JHtjYXRlZ29yeUlkfWA7XG5cbiAgICBpZiAoIWNoYW5uZWwgfHwgY2hhbm5lbC50b3BpYyAhPT0gYHJlYWx0aW1lOiR7Y2hhbm5lbE5hbWV9YCkge1xuICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgc3VwYWJhc2UucmVtb3ZlQ2hhbm5lbChjaGFubmVsKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2Vab25lcyBFZmZlY3RdIFJlbW92ZWQgcHJldmlvdXMgY2hhbm5lbC4nKTtcbiAgICAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFt1c2Vab25lcyBFZmZlY3RdIFNldHRpbmcgdXAgY2hhbm5lbDogJHtjaGFubmVsTmFtZX1gKTtcbiAgICAgIGNoYW5uZWwgPSBzdXBhYmFzZS5jaGFubmVsKGNoYW5uZWxOYW1lKTtcblxuICAgICAgY2hhbm5lbFxuICAgICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7XG4gICAgICAgICAgZXZlbnQ6ICcqJywgLy8gTGF1c2NoZSBhdWYgYWxsZSBFdmVudHNcbiAgICAgICAgICBzY2hlbWE6ICdwdWJsaWMnLFxuICAgICAgICAgIHRhYmxlOiAnem9uZXMnLFxuICAgICAgICAgIGZpbHRlcjogYGNhdGVnb3J5X2lkPWVxLiR7Y2F0ZWdvcnlJZH1gIC8vIEZpbHRlciBhdWYgU2VydmVyLVNlaXRlIVxuICAgICAgICB9LCAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbdXNlWm9uZXMgUkFXIEVWRU5UIHpvbmVzXScsIHBheWxvYWQpOyAvLyA8LS0gTG9nZ2luZyBoaW56dWbDvGdlblxuICAgICAgICAgIGhhbmRsZVpvbmVDaGFuZ2UocGF5bG9hZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdWJzY3JpYmUoKHN0YXR1cywgZXJyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFt1c2Vab25lcyBFZmZlY3RdIFN1YiBzdGF0dXMgJHtjaGFubmVsTmFtZX06YCwgc3RhdHVzLCBlcnIgfHwgJycpO1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdTVUJTQ1JJQkVEJykge1xuICAgICAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBjaGFubmVsO1xuICAgICAgICAgICAgaWYgKGxvYWRlZENhdGVnb3J5SWRSZWYuY3VycmVudCAhPT0gY2F0ZWdvcnlJZCkge1xuICAgICAgICAgICAgICBsb2FkWm9uZXMoY2F0ZWdvcnlJZCk7IC8vIEVybmV1dGVzIExhZGVuIG5hY2ggZXJmb2xncmVpY2hlciBTdWJzY3JpcHRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gJ0NIQU5ORUxfRVJST1InIHx8IHN0YXR1cyA9PT0gJ1RJTUVEX09VVCcpIHtcbiAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbdXNlWm9uZXMgRWZmZWN0XSBTdWJzY3JpcHRpb24gZmFpbGVkIGZvciAke2NoYW5uZWxOYW1lfTpgLCBlcnIpO1xuICAgICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENsZWFudXBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coYFt1c2Vab25lcyBFZmZlY3RdIENsZWFudXAgZm9yIGNhdGVnb3J5SWQ6ICR7Y2F0ZWdvcnlJZH1gKTtcbiAgICAgIGlmIChjaGFubmVsICYmICghcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgfHwgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPT09IGNoYW5uZWwpKSB7XG4gICAgICAgICBjb25zb2xlLmxvZyhgW3VzZVpvbmVzIEVmZmVjdF0gUmVtb3ZpbmcgY2hhbm5lbCAke2NoYW5uZWwudG9waWN9YCk7XG4gICAgICAgICBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpO1xuICAgICAgICAgaWYgKHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID09PSBjaGFubmVsKSB7XG4gICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY2F0ZWdvcnlJZCwgbG9hZFpvbmVzLCBoYW5kbGVab25lQ2hhbmdlXSk7IC8vIEtvcnJla3RlIEFiaMOkbmdpZ2tlaXRlblxuXG4gIC8vIC0tLSBSZXN0bGljaGUgRnVua3Rpb25lbiAod2VpdGdlaGVuZCB1bnZlcsOkbmRlcnQpIC0tLVxuICBjb25zdCBzYXZlWm9uZSA9IHVzZUNhbGxiYWNrKGFzeW5jICh6b25lRGF0YTogWm9uZUlucHV0KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgICBpZiAoIWNhdGVnb3J5SWQpIHsgLyogLi4uIEZlaGxlciAuLi4gKi8gcmV0dXJuIGZhbHNlOyB9XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgIGlmICh6b25lRGF0YS5pZCkgeyAvKiAuLi4gVXBkYXRlIC4uLiAqLyB9XG4gICAgICAgICBlbHNlIHsgLyogLi4uIENyZWF0ZSAuLi4gKi8gfVxuICAgICAgICAgdG9hc3Quc3VjY2VzcygnWm9uZSBnZXNwZWljaGVydC4nKTtcbiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHsgLyogLi4uIEZlaGxlciAuLi4gKi8gcmV0dXJuIGZhbHNlOyB9XG4gICAgICBmaW5hbGx5IHsgc2V0TG9hZGluZyhmYWxzZSk7IH1cbiAgfSwgW2NhdGVnb3J5SWRdKTtcblxuICBjb25zdCBkZWxldGVab25lID0gdXNlQ2FsbGJhY2soYXN5bmMgKHpvbmVJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfT4gPT4ge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB6b25lc1NlcnZpY2UuZGVsZXRlWm9uZSh6b25lSWQpO1xuICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB0b2FzdC5zdWNjZXNzKCdab25lIGdlbMO2c2NodC4nKTtcbiAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlcnI6IGFueSkgeyAvKiAuLi4gRmVobGVyIC4uLiAqLyByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogJ0ZlaGxlcicgfTsgfVxuICAgICAgZmluYWxseSB7IHNldExvYWRpbmcoZmFsc2UpOyB9XG4gIH0sIFtdKTtcblxuICBjb25zdCByZWZldGNoID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbdXNlWm9uZXNdIHJlZmV0Y2g6IFN0YXJ0ZSBOZXVsYWRlbicpO1xuICAgIGlmIChjYXRlZ29yeUlkKSB7XG4gICAgICBsb2FkZWRDYXRlZ29yeUlkUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgIGxvYWRab25lcyhjYXRlZ29yeUlkKTtcbiAgICB9XG4gIH0sIFtjYXRlZ29yeUlkLCBsb2FkWm9uZXNdKTtcblxuXG4gIHJldHVybiB7IHpvbmVzLCBsb2FkaW5nLCBlcnJvciwgc2F2ZVpvbmUsIGRlbGV0ZVpvbmUsIHJlZmV0Y2ggfTtcbn07Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ0b2FzdCIsInpvbmVzU2VydmljZSIsInN1cGFiYXNlIiwidXNlWm9uZXMiLCJjYXRlZ29yeUlkIiwiem9uZXMiLCJzZXRab25lcyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInJlYWx0aW1lQ2hhbm5lbFJlZiIsImxvYWRlZENhdGVnb3J5SWRSZWYiLCJsb2FkWm9uZXMiLCJjYXRlZ29yeUlkVG9Mb2FkIiwiY29uc29sZSIsImxvZyIsInpvbmVzRGF0YSIsImdldFpvbmVzQnlDYXRlZ29yeSIsImVuaGFuY2VkWm9uZXMiLCJtYXAiLCJ6b25lIiwiaWQiLCJuYW1lIiwiem9uZUtleSIsIm1pbnV0ZXNSZXF1aXJlZCIsImludGVydmFsTWludXRlcyIsInBvaW50c0dyYW50ZWQiLCJwb2ludHNQZXJJbnRlcnZhbCIsImxhc3RBY3RpdmUiLCJ0b3RhbFRpbWVTcGVudCIsInRvdGFsVXNlcnMiLCJjdXJyZW50IiwibGVuZ3RoIiwiZXJyIiwiaGFuZGxlWm9uZUNoYW5nZSIsInBheWxvYWQiLCJldmVudFR5cGUiLCJuZXciLCJuZXdSZWNvcmQiLCJvbGQiLCJvbGRSZWNvcmQiLCJ0YWJsZSIsInNjaGVtYSIsIm5ld1JlY29yZENhdGVnb3J5SWQiLCJjYXRlZ29yeV9pZCIsIm9sZFJlY29yZENhdGVnb3J5SWQiLCJyZWNvcmQiLCJ6b25lSWQiLCJ6b25lRGF0YSIsImdldFpvbmVCeUlkIiwiZW5oYW5jZWRab25lIiwicHJldiIsImluZGV4IiwiZmluZEluZGV4IiwieiIsIm5ld1N0YXRlIiwic2V0VGltZW91dCIsImZpbHRlciIsInJlbW92ZUNoYW5uZWwiLCJ0aGVuIiwiY2hhbm5lbCIsImNoYW5uZWxOYW1lIiwidG9waWMiLCJvbiIsImV2ZW50Iiwic3Vic2NyaWJlIiwic3RhdHVzIiwic2F2ZVpvbmUiLCJzdWNjZXNzIiwiZGVsZXRlWm9uZSIsInJlc3VsdCIsIm1lc3NhZ2UiLCJyZWZldGNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/category-management/hooks/useZones.ts\n"));

/***/ })

});