"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/categories/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts":
/*!*****************************************************************************!*\
  !*** ./src/components/dashboard/category-management/hooks/useCategories.ts ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCategories: () => (/* binding */ useCategories)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@15.3.0_@babel+core@7.2_be93e11acbbedc130c6eb3d215a0d5e8/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/core/toaster */ \"(app-pages-browser)/./src/components/core/toaster.tsx\");\n/* harmony import */ var _context_guild_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/context/guild-context */ \"(app-pages-browser)/./src/context/guild-context.tsx\");\n/* harmony import */ var _services_categories__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/categories */ \"(app-pages-browser)/./src/services/categories.ts\");\n/* harmony import */ var _services_zones__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/zones */ \"(app-pages-browser)/./src/services/zones.ts\");\n/* harmony import */ var shared_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! shared-types */ \"(app-pages-browser)/../../packages/shared-types/src/index.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useCategories auto */ \n\n\n\n\n // Import CategoryDto\n\nconst useCategories = ()=>{\n    const { currentGuild } = (0,_context_guild_context__WEBPACK_IMPORTED_MODULE_2__.useGuild)();\n    const guildId = (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) || '';\n    console.log(\"[useCategories] Hook initialisiert/neu gerendert mit guildId: \".concat(guildId));\n    const [categories, setCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [expandedCategories, setExpandedCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [searchQuery, setSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false); // Nur ein Loading-State\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const realtimeChannelRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const loadedGuildIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(''); // Verfolgt, für welche Guild geladen wurde\n    // --- Memoized Ladefunktion ---\n    const loadCategories = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[loadCategories]\": async (guildIdToLoad)=>{\n            if (!guildIdToLoad) {\n                console.log('[useCategories] loadCategories: Keine Guild ID übergeben.');\n                setCategories([]); // Zustand leeren\n                return;\n            }\n            console.log(\"[useCategories] loadCategories aufgerufen f\\xfcr Guild: \".concat(guildIdToLoad));\n            setLoading(true);\n            setError(null);\n            try {\n                const categoriesData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategories(shared_types__WEBPACK_IMPORTED_MODULE_5__.ScopeType.GUILD, guildIdToLoad);\n                const enhancedCategories = await Promise.all(categoriesData.map({\n                    \"useCategories.useCallback[loadCategories]\": async (category)=>{\n                        const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(category.id);\n                        const enhancedZones = zonesData.map({\n                            \"useCategories.useCallback[loadCategories].enhancedZones\": (zone)=>({\n                                    id: zone.id,\n                                    name: zone.name,\n                                    zoneKey: zone.zoneKey,\n                                    minutesRequired: zone.intervalMinutes,\n                                    pointsGranted: zone.pointsPerInterval,\n                                    lastActive: '-',\n                                    totalTimeSpent: 0,\n                                    totalUsers: 0\n                                })\n                        }[\"useCategories.useCallback[loadCategories].enhancedZones\"]);\n                        return {\n                            id: category.id,\n                            name: category.name,\n                            guild_id: guildIdToLoad,\n                            allowedRoles: category.allowedRoles || [],\n                            isVisible: category.isVisibleDefault,\n                            sendSetup: category.setupFlowEnabled,\n                            trackingActive: category.defaultTrackingEnabled,\n                            setupTextChannel: category.setupChannelId,\n                            waitingRoomName: category.warteraumChannelId,\n                            lastActive: '-',\n                            totalTimeSpent: 0,\n                            totalUsers: 0,\n                            discordCategoryId: category.discordCategoryId || null,\n                            deletedInDiscord: !category.discordCategoryId,\n                            createdAt: new Date(category.createdAt),\n                            updatedAt: new Date(category.updatedAt),\n                            zones: enhancedZones\n                        };\n                    }\n                }[\"useCategories.useCallback[loadCategories]\"]));\n                setCategories(enhancedCategories);\n                loadedGuildIdRef.current = guildIdToLoad; // Markieren als geladen\n                console.log(\"[useCategories] loadCategories: \".concat(enhancedCategories.length, \" Kategorien geladen f\\xfcr \").concat(guildIdToLoad));\n            } catch (err) {\n                console.error(\"[useCategories] Fehler beim Laden der Kategorien f\\xfcr \".concat(guildIdToLoad, \":\"), err);\n                setError('Fehler beim Laden der Kategorien');\n                // Fallback? Oder leeren State lassen?\n                setCategories([]); // Bei Fehler leeren\n                loadedGuildIdRef.current = guildIdToLoad; // Trotz Fehler als geladen markieren, um Loop zu vermeiden\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[loadCategories]\"], []); // Keine Abhängigkeiten, da Services und State-Setter stabil sind\n    // --- Memoized Realtime Handler ---\n    const handleCategoryChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[handleCategoryChange]\": (payload)=>{\n            console.log('[HANDLER CALLED] handleCategoryChange', payload); // <-- Logging hinzufügen\n            console.log(\"[useCategories Realtime] Kategorie-\\xc4nderung erkannt:\", payload);\n            const { eventType, new: newRecord, old: oldRecord, table } = payload;\n            // Nur auf relevante Tabellen reagieren\n            if (table !== 'categories') {\n                console.log(\"[useCategories Realtime] Ignoriere Event f\\xfcr Tabelle: \".concat(table));\n                return;\n            }\n            const record = newRecord || oldRecord;\n            if (!record || !record.id) return; // Brauchen mindestens eine ID\n            const categoryId = record.id;\n            switch(eventType){\n                case 'INSERT':\n                case 'UPDATE':\n                    ({\n                        \"useCategories.useCallback[handleCategoryChange]\": async ()=>{\n                            try {\n                                console.log(\"[Handler Logic START] \".concat(eventType, \" Category\"));\n                                // Lade die (neue/aktualisierte) Kategorie inkl. ihrer Zonen\n                                const categoryData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryById(categoryId);\n                                const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(categoryId);\n                                // Vollständiges Mapping statt Platzhalter\n                                const enhancedZones = zonesData.map({\n                                    \"useCategories.useCallback[handleCategoryChange].enhancedZones\": (zone)=>({\n                                            id: zone.id,\n                                            name: zone.name,\n                                            zoneKey: zone.zoneKey,\n                                            minutesRequired: zone.intervalMinutes,\n                                            pointsGranted: zone.pointsPerInterval,\n                                            lastActive: '-',\n                                            totalTimeSpent: 0,\n                                            totalUsers: 0\n                                        })\n                                }[\"useCategories.useCallback[handleCategoryChange].enhancedZones\"]);\n                                const enhancedCategory = {\n                                    id: categoryData.id,\n                                    name: categoryData.name,\n                                    guild_id: (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) || '',\n                                    allowedRoles: categoryData.allowedRoles || [],\n                                    isVisible: categoryData.isVisibleDefault,\n                                    sendSetup: categoryData.setupFlowEnabled,\n                                    trackingActive: categoryData.defaultTrackingEnabled,\n                                    setupTextChannel: categoryData.setupChannelId,\n                                    waitingRoomName: categoryData.warteraumChannelId,\n                                    lastActive: '-',\n                                    totalTimeSpent: 0,\n                                    totalUsers: 0,\n                                    discordCategoryId: categoryData.discordCategoryId || null,\n                                    deletedInDiscord: !categoryData.discordCategoryId,\n                                    createdAt: new Date(categoryData.createdAt),\n                                    updatedAt: new Date(categoryData.updatedAt),\n                                    zones: enhancedZones\n                                };\n                                console.log('[State BEFORE update]', categories);\n                                setCategories({\n                                    \"useCategories.useCallback[handleCategoryChange]\": (prev)=>{\n                                        const index = prev.findIndex({\n                                            \"useCategories.useCallback[handleCategoryChange].index\": (c)=>c.id === categoryId\n                                        }[\"useCategories.useCallback[handleCategoryChange].index\"]);\n                                        let newState;\n                                        if (index !== -1) {\n                                            // Update\n                                            console.log(\"[Category \".concat(eventType, \"] Updating existing category at index \").concat(index));\n                                            newState = [\n                                                ...prev\n                                            ];\n                                            newState[index] = enhancedCategory;\n                                        } else {\n                                            // Insert (oder Update, falls es fehlte)\n                                            console.log(\"[Category \".concat(eventType, \"] Adding new category\"));\n                                            newState = [\n                                                ...prev,\n                                                enhancedCategory\n                                            ];\n                                        }\n                                        console.log('[State AFTER update (calculated)]', newState);\n                                        return newState;\n                                    }\n                                }[\"useCategories.useCallback[handleCategoryChange]\"]);\n                                // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                                setTimeout({\n                                    \"useCategories.useCallback[handleCategoryChange]\": ()=>{\n                                        console.log('[State AFTER update (actual)]', categories);\n                                    }\n                                }[\"useCategories.useCallback[handleCategoryChange]\"], 0);\n                                console.log(\"[Handler Logic END] \".concat(eventType, \" Category\"));\n                            } catch (error) {\n                                console.error(\"[useCategories Realtime] Fehler beim Verarbeiten \".concat(eventType, \":\"), error);\n                            }\n                        }\n                    })[\"useCategories.useCallback[handleCategoryChange]\"]();\n                    break;\n                case 'DELETE':\n                    if (oldRecord === null || oldRecord === void 0 ? void 0 : oldRecord.id) {\n                        console.log(\"[Handler Logic START] DELETE Category \".concat(oldRecord.id));\n                        console.log('[State BEFORE delete]', categories);\n                        setCategories({\n                            \"useCategories.useCallback[handleCategoryChange]\": (prev)=>{\n                                console.log(\"[Category DELETE] Removing category with id \".concat(oldRecord.id));\n                                const newState = prev.filter({\n                                    \"useCategories.useCallback[handleCategoryChange].newState\": (category)=>category.id !== oldRecord.id\n                                }[\"useCategories.useCallback[handleCategoryChange].newState\"]);\n                                console.log('[State AFTER delete (calculated)]', newState);\n                                return newState;\n                            }\n                        }[\"useCategories.useCallback[handleCategoryChange]\"]);\n                        // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                        setTimeout({\n                            \"useCategories.useCallback[handleCategoryChange]\": ()=>{\n                                console.log('[State AFTER delete (actual)]', categories);\n                            }\n                        }[\"useCategories.useCallback[handleCategoryChange]\"], 0);\n                        console.log(\"[Handler Logic END] DELETE Category \".concat(oldRecord.id));\n                    }\n                    break;\n                default:\n                    console.log(\"[useCategories Realtime] Unbekannter Event-Typ f\\xfcr categories: \".concat(eventType));\n            }\n        }\n    }[\"useCategories.useCallback[handleCategoryChange]\"], [\n        setCategories\n    ]); // Nur von stabilen Funktionen abhängig\n    const handleZoneChangeInCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[handleZoneChangeInCategory]\": (payload)=>{\n            console.log('[HANDLER CALLED] handleZoneChangeInCategory', payload); // <-- Logging hinzufügen\n            console.log(\"[useCategories Realtime] Zonen-\\xc4nderung erkannt:\", payload);\n            const { new: newRecord, old: oldRecord, table } = payload;\n            // Nur auf relevante Tabellen reagieren\n            if (table !== 'zones') {\n                console.log(\"[useCategories Realtime] Ignoriere Event f\\xfcr Tabelle: \".concat(table));\n                return;\n            }\n            const record = newRecord || oldRecord;\n            if (!record || !record.category_id) return;\n            const categoryId = record.category_id;\n            // Lade Zonen für die betroffene Kategorie neu und update die Kategorie im State\n            ({\n                \"useCategories.useCallback[handleZoneChangeInCategory]\": async ()=>{\n                    try {\n                        console.log(\"[Handler Logic START] Update Zones for Category \".concat(categoryId));\n                        const zonesData = await _services_zones__WEBPACK_IMPORTED_MODULE_4__.getZonesByCategory(categoryId);\n                        // Vollständiges Mapping statt Platzhalter\n                        const enhancedZones = zonesData.map({\n                            \"useCategories.useCallback[handleZoneChangeInCategory].enhancedZones\": (zone)=>({\n                                    id: zone.id,\n                                    name: zone.name,\n                                    zoneKey: zone.zoneKey,\n                                    minutesRequired: zone.intervalMinutes,\n                                    pointsGranted: zone.pointsPerInterval,\n                                    lastActive: '-',\n                                    totalTimeSpent: 0,\n                                    totalUsers: 0\n                                })\n                        }[\"useCategories.useCallback[handleZoneChangeInCategory].enhancedZones\"]);\n                        console.log('[State BEFORE zone update]', categories);\n                        setCategories({\n                            \"useCategories.useCallback[handleZoneChangeInCategory]\": (prev)=>{\n                                console.log(\"[Zone Change] Updating zones for category \".concat(categoryId));\n                                const categoryIndex = prev.findIndex({\n                                    \"useCategories.useCallback[handleZoneChangeInCategory].categoryIndex\": (c)=>c.id === categoryId\n                                }[\"useCategories.useCallback[handleZoneChangeInCategory].categoryIndex\"]);\n                                if (categoryIndex === -1) {\n                                    console.log(\"[Zone Change] Category \".concat(categoryId, \" not found in state, no update needed\"));\n                                    return prev;\n                                }\n                                const newState = [\n                                    ...prev\n                                ];\n                                newState[categoryIndex] = {\n                                    ...newState[categoryIndex],\n                                    zones: enhancedZones\n                                };\n                                console.log('[State AFTER zone update (calculated)]', newState);\n                                return newState;\n                            }\n                        }[\"useCategories.useCallback[handleZoneChangeInCategory]\"]);\n                        // Logge den State nach der Aktualisierung (im nächsten Render-Zyklus)\n                        setTimeout({\n                            \"useCategories.useCallback[handleZoneChangeInCategory]\": ()=>{\n                                console.log('[State AFTER zone update (actual)]', categories);\n                            }\n                        }[\"useCategories.useCallback[handleZoneChangeInCategory]\"], 0);\n                        console.log(\"[Handler Logic END] Update Zones for Category \".concat(categoryId));\n                    } catch (error) {\n                        console.error(\"[useCategories Realtime] Fehler beim Laden der Zonen f\\xfcr Kategorie \".concat(categoryId, \":\"), error);\n                    }\n                }\n            })[\"useCategories.useCallback[handleZoneChangeInCategory]\"]();\n        }\n    }[\"useCategories.useCallback[handleZoneChangeInCategory]\"], [\n        setCategories\n    ]); // Nur von stabilen Funktionen abhängig\n    const handleCategoryRoleChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[handleCategoryRoleChange]\": (payload)=>{\n            console.log('[HANDLER CALLED] handleCategoryRoleChange', payload); // <-- Logging hinzufügen\n            console.log(\"[useCategories Realtime] Kategorie-Rollen-\\xc4nderung erkannt:\", payload);\n            const { new: newRecord, old: oldRecord, table } = payload;\n            // Nur auf relevante Tabellen reagieren\n            if (table !== 'category_discord_role_permissions') {\n                console.log(\"[useCategories Realtime] Ignoriere Event f\\xfcr Tabelle: \".concat(table));\n                return;\n            }\n            const record = newRecord || oldRecord;\n            if (!record || !record.category_id) return;\n            const categoryId = record.category_id;\n            ({\n                \"useCategories.useCallback[handleCategoryRoleChange]\": async ()=>{\n                    try {\n                        console.log(\"[Handler Logic START] Update Roles for Category \".concat(categoryId));\n                        const categoryData = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.getCategoryById(categoryId);\n                        if (!categoryData) {\n                            console.log(\"[Handler Logic] Category \".concat(categoryId, \" not found\"));\n                            return;\n                        }\n                        setCategories({\n                            \"useCategories.useCallback[handleCategoryRoleChange]\": (prev)=>prev.map({\n                                    \"useCategories.useCallback[handleCategoryRoleChange]\": (category)=>category.id === categoryId ? {\n                                            ...category,\n                                            allowedRoles: categoryData.allowedRoles || []\n                                        } : category\n                                }[\"useCategories.useCallback[handleCategoryRoleChange]\"])\n                        }[\"useCategories.useCallback[handleCategoryRoleChange]\"]);\n                        console.log(\"[Handler Logic END] Update Roles for Category \".concat(categoryId));\n                    } catch (error) {\n                        console.error(\"[useCategories Realtime] Fehler beim Laden der Rollenberechtigungen f\\xfcr Kategorie \".concat(categoryId, \":\"), error);\n                    }\n                }\n            })[\"useCategories.useCallback[handleCategoryRoleChange]\"]();\n        }\n    }[\"useCategories.useCallback[handleCategoryRoleChange]\"], [\n        setCategories\n    ]); // Nur von stabilen Funktionen abhängig\n    // --- Haupt-useEffect für Laden und Subscription ---\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCategories.useEffect\": ()=>{\n            const currentGuildId = currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id;\n            console.log(\"[useCategories Effect] Running for guildId: \".concat(currentGuildId || 'none'));\n            if (!currentGuildId) {\n                console.log('[useCategories Effect] No guildId, resetting.');\n                setCategories([]);\n                loadedGuildIdRef.current = '';\n                // Alte Subscription entfernen, falls vorhanden\n                if (realtimeChannelRef.current) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(realtimeChannelRef.current).then({\n                        \"useCategories.useEffect\": ()=>{\n                            console.log('[useCategories Effect] Removed old channel on guildId clear.');\n                            realtimeChannelRef.current = null;\n                        }\n                    }[\"useCategories.useEffect\"]);\n                }\n                return;\n            }\n            // Laden, wenn die Guild neu ist oder die Daten fehlen\n            if (loadedGuildIdRef.current !== currentGuildId) {\n                loadCategories(currentGuildId);\n            }\n            // Subscription Logik (unverändert zur letzten Version, nutzt jetzt memoized Handler)\n            let channel = realtimeChannelRef.current;\n            const channelName = \"categories:\".concat(currentGuildId);\n            // Nur subscriben, wenn noch nicht oder für andere Guild subscribed\n            if (!channel || channel.topic !== \"realtime:\".concat(channelName)) {\n                // Alte Subscription sicher entfernen\n                if (channel) {\n                    _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(channel).then({\n                        \"useCategories.useEffect\": ()=>{\n                            console.log('[useCategories Effect] Removed previous channel before new subscription.');\n                            realtimeChannelRef.current = null; // Wichtig: Ref zurücksetzen\n                        }\n                    }[\"useCategories.useEffect\"]);\n                }\n                console.log(\"[useCategories Effect] Setting up channel: \".concat(channelName));\n                channel = _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.channel(channelName);\n                channel.on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'categories'\n                }, {\n                    \"useCategories.useEffect\": (payload)=>{\n                        console.log('[useCategories RAW EVENT categories]', payload); // <-- Logging hinzufügen\n                        handleCategoryChange(payload);\n                    }\n                }[\"useCategories.useEffect\"]).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'zones'\n                }, {\n                    \"useCategories.useEffect\": (payload)=>{\n                        console.log('[useCategories RAW EVENT zones]', payload); // <-- Logging hinzufügen\n                        handleZoneChangeInCategory(payload);\n                    }\n                }[\"useCategories.useEffect\"]).on('postgres_changes', {\n                    event: '*',\n                    schema: 'public',\n                    table: 'category_discord_role_permissions'\n                }, {\n                    \"useCategories.useEffect\": (payload)=>{\n                        console.log('[useCategories RAW EVENT category_roles]', payload); // <-- Logging hinzufügen\n                        handleCategoryRoleChange(payload);\n                    }\n                }[\"useCategories.useEffect\"]).subscribe({\n                    \"useCategories.useEffect\": (status, err)=>{\n                        console.log(\"[useCategories Effect] Sub status \".concat(channelName, \":\"), status, err || '');\n                        if (status === 'SUBSCRIBED') {\n                            realtimeChannelRef.current = channel; // Ref erst bei Erfolg setzen\n                            // Nach erfolgreicher Subscription evtl. nochmals laden, falls initialFetch fehlgeschlagen\n                            if (loadedGuildIdRef.current !== currentGuildId) {\n                                console.log('[useCategories Effect] Re-fetching data after successful subscription.');\n                                loadCategories(currentGuildId);\n                            }\n                        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {\n                            console.error(\"[useCategories Effect] Subscription failed for \".concat(channelName, \":\"), err);\n                            realtimeChannelRef.current = null; // Bei Fehler Ref zurücksetzen\n                        }\n                    }\n                }[\"useCategories.useEffect\"]);\n            } else {\n                console.log(\"[useCategories Effect] Already subscribed to \".concat(channelName));\n            }\n            // Cleanup-Funktion\n            return(({\n                \"useCategories.useEffect\": ()=>{\n                    console.log(\"[useCategories Effect] Cleanup for guildId: \".concat(currentGuildId));\n                    // Nur den Channel entfernen, der *in diesem Effekt* erstellt wurde\n                    if (channel && (!realtimeChannelRef.current || realtimeChannelRef.current === channel)) {\n                        console.log(\"[useCategories Effect] Removing channel \".concat(channel.topic));\n                        _lib_supabase__WEBPACK_IMPORTED_MODULE_6__.supabase.removeChannel(channel);\n                        if (realtimeChannelRef.current === channel) {\n                            realtimeChannelRef.current = null;\n                        }\n                    }\n                }\n            })[\"useCategories.useEffect\"]);\n        // ACHTUNG: Die Handler als Abhängigkeiten stellen sicher, dass der Effekt neu läuft, wenn\n        // sich ihre Referenzen ändern (was sie dank useCallback nur tun sollten, wenn sich *ihre* Deps ändern).\n        // `loadCategories` ist ebenfalls memoisiert.\n        }\n    }[\"useCategories.useEffect\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories,\n        handleCategoryChange,\n        handleZoneChangeInCategory,\n        handleCategoryRoleChange\n    ]);\n    // --- Restliche Funktionen (weitgehend unverändert, nutzen jetzt stabile loadCategories) ---\n    const toggleCategoryExpand = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[toggleCategoryExpand]\": (categoryId)=>{\n            setExpandedCategories({\n                \"useCategories.useCallback[toggleCategoryExpand]\": (prevExpanded)=>prevExpanded.includes(categoryId) ? prevExpanded.filter({\n                        \"useCategories.useCallback[toggleCategoryExpand]\": (id)=>id !== categoryId\n                    }[\"useCategories.useCallback[toggleCategoryExpand]\"]) : [\n                        ...prevExpanded,\n                        categoryId\n                    ]\n            }[\"useCategories.useCallback[toggleCategoryExpand]\"]);\n        }\n    }[\"useCategories.useCallback[toggleCategoryExpand]\"], []);\n    const saveCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[saveCategory]\": async (categoryData)=>{\n            if (!guildId) {\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error('Keine Guild ausgewählt');\n                return false;\n            }\n            setLoading(true);\n            try {\n                if (categoryData.id) {\n                    const updateData = {\n                        name: categoryData.name,\n                        isVisibleDefault: categoryData.isVisible,\n                        setupFlowEnabled: categoryData.sendSetup,\n                        defaultTrackingEnabled: categoryData.trackingActive,\n                        setupChannelName: categoryData.setupTextChannel || undefined,\n                        warteraumChannelName: categoryData.waitingRoomName || undefined,\n                        discordRoleIds: categoryData.allowedRoles\n                    };\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.updateCategory(categoryData.id, updateData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie erfolgreich aktualisiert');\n                } else {\n                    const createData = {\n                        scope: {\n                            id: guildId,\n                            scopeType: shared_types__WEBPACK_IMPORTED_MODULE_5__.ScopeType.GUILD,\n                            scopeId: guildId\n                        },\n                        name: categoryData.name,\n                        isVisibleDefault: categoryData.isVisible,\n                        setupFlowEnabled: categoryData.sendSetup,\n                        defaultTrackingEnabled: categoryData.trackingActive,\n                        setupChannelName: categoryData.setupTextChannel || undefined,\n                        warteraumChannelName: categoryData.waitingRoomName || undefined,\n                        discordRoleIds: categoryData.allowedRoles\n                    };\n                    await _services_categories__WEBPACK_IMPORTED_MODULE_3__.createCategory(createData);\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie erfolgreich erstellt');\n                }\n                // Realtime sollte die Aktualisierung übernehmen, kein manuelles Laden nötig\n                return true;\n            } catch (err) {\n                var _err_response_data, _err_response;\n                console.error('Fehler beim Speichern der Kategorie:', err);\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error(((_err_response = err.response) === null || _err_response === void 0 ? void 0 : (_err_response_data = _err_response.data) === null || _err_response_data === void 0 ? void 0 : _err_response_data.message) || 'Fehler beim Speichern der Kategorie');\n                return false;\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[saveCategory]\"], [\n        guildId\n    ]); // Abhängig von guildId\n    const deleteCategory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[deleteCategory]\": async (categoryId)=>{\n            setLoading(true);\n            try {\n                const result = await _services_categories__WEBPACK_IMPORTED_MODULE_3__.deleteCategory(categoryId);\n                if (result.success) {\n                    _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.success('Kategorie erfolgreich gelöscht');\n                }\n                return result;\n            } catch (err) {\n                var _err_response_data, _err_response;\n                console.error('Fehler beim Löschen der Kategorie:', err);\n                const errorMessage = ((_err_response = err.response) === null || _err_response === void 0 ? void 0 : (_err_response_data = _err_response.data) === null || _err_response_data === void 0 ? void 0 : _err_response_data.message) || 'Fehler beim Löschen der Kategorie';\n                _components_core_toaster__WEBPACK_IMPORTED_MODULE_1__.toast.error(errorMessage);\n                return {\n                    success: false,\n                    message: errorMessage\n                };\n            } finally{\n                setLoading(false);\n            }\n        }\n    }[\"useCategories.useCallback[deleteCategory]\"], []); // Keine Abhängigkeiten nötig\n    const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[refetch]\": ()=>{\n            console.log('[useCategories] refetch: Starte Neuladen');\n            if (currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id) {\n                loadedGuildIdRef.current = ''; // Erzwingt Neuladen im Effekt\n                loadCategories(currentGuild.id); // Löst manuelles Laden aus\n            }\n        }\n    }[\"useCategories.useCallback[refetch]\"], [\n        currentGuild === null || currentGuild === void 0 ? void 0 : currentGuild.id,\n        loadCategories\n    ]);\n    const getTotalStats = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCategories.useCallback[getTotalStats]\": ()=>{\n            // ... Berechnung wie bisher ...\n            return {\n                totalCategories: 0,\n                totalUsers: 0,\n                totalTime: 0\n            }; // Placeholder\n        }\n    }[\"useCategories.useCallback[getTotalStats]\"], [\n        categories\n    ]);\n    return {\n        categories,\n        loading,\n        error,\n        expandedCategories,\n        searchQuery,\n        setSearchQuery,\n        toggleCategoryExpand,\n        saveCategory,\n        // updateCategoryWithZones, // Wird jetzt durch Realtime Handler abgedeckt\n        deleteCategory,\n        getTotalStats,\n        refetch\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9jYXRlZ29yeS1tYW5hZ2VtZW50L2hvb2tzL3VzZUNhdGVnb3JpZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O21FQUVpRTtBQUNmO0FBQ0M7QUFDUTtBQUNWO0FBQzJDLENBQUMscUJBQXFCO0FBRXhFO0FBOENuQyxNQUFNVSxnQkFBZ0I7SUFDM0IsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR04sZ0VBQVFBO0lBQ2pDLE1BQU1PLFVBQVVELENBQUFBLHlCQUFBQSxtQ0FBQUEsYUFBY0UsRUFBRSxLQUFJO0lBQ3BDQyxRQUFRQyxHQUFHLENBQUMsaUVBQXlFLE9BQVJIO0lBRTdFLE1BQU0sQ0FBQ0ksWUFBWUMsY0FBYyxHQUFHakIsK0NBQVFBLENBQXFCLEVBQUU7SUFDbkUsTUFBTSxDQUFDa0Isb0JBQW9CQyxzQkFBc0IsR0FBR25CLCtDQUFRQSxDQUFXLEVBQUU7SUFDekUsTUFBTSxDQUFDb0IsYUFBYUMsZUFBZSxHQUFHckIsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDc0IsU0FBU0MsV0FBVyxHQUFHdkIsK0NBQVFBLENBQUMsUUFBUSx3QkFBd0I7SUFDdkUsTUFBTSxDQUFDd0IsT0FBT0MsU0FBUyxHQUFHekIsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU0wQixxQkFBcUJ2Qiw2Q0FBTUEsQ0FBeUI7SUFDMUQsTUFBTXdCLG1CQUFtQnhCLDZDQUFNQSxDQUFTLEtBQUssMkNBQTJDO0lBRXhGLGdDQUFnQztJQUNoQyxNQUFNeUIsaUJBQWlCMUIsa0RBQVdBO3FEQUFDLE9BQU8yQjtZQUN4QyxJQUFJLENBQUNBLGVBQWU7Z0JBQ2xCZixRQUFRQyxHQUFHLENBQUM7Z0JBQ1pFLGNBQWMsRUFBRSxHQUFHLGlCQUFpQjtnQkFDcEM7WUFDRjtZQUNBSCxRQUFRQyxHQUFHLENBQUMsMkRBQXNFLE9BQWRjO1lBQ3BFTixXQUFXO1lBQ1hFLFNBQVM7WUFFVCxJQUFJO2dCQUNG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UVUsS0FBSyxDQUFDLHNDQUFzQytDO2dCQUNwRCxNQUFNeUQsZUFBZXpELEVBQUFBLGdCQUFBQSxJQUFJb0QsUUFBUSxjQUFacEQscUNBQUFBLHFCQUFBQSxjQUFjcUQsSUFBSSxjQUFsQnJELHlDQUFBQSxtQkFBb0JzRCxPQUFPLEtBQUk7Z0JBQ3BEekgsMkRBQUtBLENBQUNvQixLQUFLLENBQUN3RztnQkFDWixPQUFPO29CQUFFWCxTQUFTO29CQUFPUSxTQUFTRztnQkFBYTtZQUNqRCxTQUFVO2dCQUNSekcsV0FBVztZQUNiO1FBQ0g7b0RBQUcsRUFBRSxHQUFHLDZCQUE2QjtJQUVyQyxNQUFNMEcsVUFBVS9ILGtEQUFXQTs4Q0FBQztZQUMxQlksUUFBUUMsR0FBRyxDQUFDO1lBQ1osSUFBSUoseUJBQUFBLG1DQUFBQSxhQUFjRSxFQUFFLEVBQUU7Z0JBQ3BCYyxpQkFBaUIwQyxPQUFPLEdBQUcsSUFBSSw4QkFBOEI7Z0JBQzdEekMsZUFBZWpCLGFBQWFFLEVBQUUsR0FBRywyQkFBMkI7WUFDOUQ7UUFDRjs2Q0FBRztRQUFDRix5QkFBQUEsbUNBQUFBLGFBQWNFLEVBQUU7UUFBRWU7S0FBZTtJQUVyQyxNQUFNc0csZ0JBQWdCaEksa0RBQVdBO29EQUFDO1lBQ2hDLGdDQUFnQztZQUNoQyxPQUFPO2dCQUFFaUksaUJBQWlCO2dCQUFHakYsWUFBWTtnQkFBR2tGLFdBQVc7WUFBQyxHQUFHLGNBQWM7UUFDM0U7bURBQUc7UUFBQ3BIO0tBQVc7SUFHZixPQUFPO1FBQ0xBO1FBQ0FNO1FBQ0FFO1FBQ0FOO1FBQ0FFO1FBQ0FDO1FBQ0FzRjtRQUNBRztRQUNBLDBFQUEwRTtRQUMxRWdCO1FBQ0FJO1FBQ0FEO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGluZm9cXERvY3VtZW50c1xcRGlzY29yZCBCb3RcXENoaW1lcmFcXGFwcHNcXGZyb250ZW5kXFxzcmNcXGNvbXBvbmVudHNcXGRhc2hib2FyZFxcY2F0ZWdvcnktbWFuYWdlbWVudFxcaG9va3NcXHVzZUNhdGVnb3JpZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdG9hc3QgfSBmcm9tICdAL2NvbXBvbmVudHMvY29yZS90b2FzdGVyJztcbmltcG9ydCB7IHVzZUd1aWxkIH0gZnJvbSAnQC9jb250ZXh0L2d1aWxkLWNvbnRleHQnO1xuaW1wb3J0ICogYXMgY2F0ZWdvcmllc1NlcnZpY2UgZnJvbSAnQC9zZXJ2aWNlcy9jYXRlZ29yaWVzJztcbmltcG9ydCAqIGFzIHpvbmVzU2VydmljZSBmcm9tICdAL3NlcnZpY2VzL3pvbmVzJztcbmltcG9ydCB7IENyZWF0ZUNhdGVnb3J5RHRvLCBVcGRhdGVDYXRlZ29yeUR0bywgU2NvcGVUeXBlLCBDYXRlZ29yeUR0byB9IGZyb20gJ3NoYXJlZC10eXBlcyc7IC8vIEltcG9ydCBDYXRlZ29yeUR0b1xuaW1wb3J0IHsgUmVhbHRpbWVDaGFubmVsLCBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSc7XG5cbi8vIEludGVyZmFjZXMgYmxlaWJlbiBnbGVpY2guLi5cbmV4cG9ydCBpbnRlcmZhY2UgRW5oYW5jZWRDYXRlZ29yeSB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZ3VpbGRfaWQ6IHN0cmluZztcbiAgYWxsb3dlZFJvbGVzOiBzdHJpbmdbXTtcbiAgaXNWaXNpYmxlOiBib29sZWFuO1xuICBzZW5kU2V0dXA6IGJvb2xlYW47XG4gIHRyYWNraW5nQWN0aXZlOiBib29sZWFuO1xuICBzZXR1cFRleHRDaGFubmVsPzogc3RyaW5nIHwgbnVsbDtcbiAgd2FpdGluZ1Jvb21OYW1lPzogc3RyaW5nIHwgbnVsbDtcbiAgbGFzdEFjdGl2ZTogc3RyaW5nO1xuICB0b3RhbFRpbWVTcGVudDogbnVtYmVyO1xuICB0b3RhbFVzZXJzOiBudW1iZXI7XG4gIGRpc2NvcmRDYXRlZ29yeUlkOiBzdHJpbmcgfCBudWxsO1xuICBkZWxldGVkSW5EaXNjb3JkOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbiAgem9uZXM6IEVuaGFuY2VkWm9uZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVuaGFuY2VkWm9uZSB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgem9uZUtleTogc3RyaW5nO1xuICBtaW51dGVzUmVxdWlyZWQ6IG51bWJlcjtcbiAgcG9pbnRzR3JhbnRlZDogbnVtYmVyO1xuICBsYXN0QWN0aXZlOiBzdHJpbmc7XG4gIHRvdGFsVGltZVNwZW50OiBudW1iZXI7XG4gIHRvdGFsVXNlcnM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yeUlucHV0IHtcbiAgaWQ/OiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgYWxsb3dlZFJvbGVzOiBzdHJpbmdbXTtcbiAgaXNWaXNpYmxlOiBib29sZWFuO1xuICBzZW5kU2V0dXA6IGJvb2xlYW47XG4gIHRyYWNraW5nQWN0aXZlOiBib29sZWFuO1xuICBzZXR1cFRleHRDaGFubmVsPzogc3RyaW5nIHwgbnVsbDtcbiAgd2FpdGluZ1Jvb21OYW1lPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuXG5leHBvcnQgY29uc3QgdXNlQ2F0ZWdvcmllcyA9ICgpID0+IHtcbiAgY29uc3QgeyBjdXJyZW50R3VpbGQgfSA9IHVzZUd1aWxkKCk7XG4gIGNvbnN0IGd1aWxkSWQgPSBjdXJyZW50R3VpbGQ/LmlkIHx8ICcnO1xuICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXNdIEhvb2sgaW5pdGlhbGlzaWVydC9uZXUgZ2VyZW5kZXJ0IG1pdCBndWlsZElkOiAke2d1aWxkSWR9YCk7XG5cbiAgY29uc3QgW2NhdGVnb3JpZXMsIHNldENhdGVnb3JpZXNdID0gdXNlU3RhdGU8RW5oYW5jZWRDYXRlZ29yeVtdPihbXSk7XG4gIGNvbnN0IFtleHBhbmRlZENhdGVnb3JpZXMsIHNldEV4cGFuZGVkQ2F0ZWdvcmllc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuICBjb25zdCBbc2VhcmNoUXVlcnksIHNldFNlYXJjaFF1ZXJ5XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpOyAvLyBOdXIgZWluIExvYWRpbmctU3RhdGVcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgcmVhbHRpbWVDaGFubmVsUmVmID0gdXNlUmVmPFJlYWx0aW1lQ2hhbm5lbCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBsb2FkZWRHdWlsZElkUmVmID0gdXNlUmVmPHN0cmluZz4oJycpOyAvLyBWZXJmb2xndCwgZsO8ciB3ZWxjaGUgR3VpbGQgZ2VsYWRlbiB3dXJkZVxuXG4gIC8vIC0tLSBNZW1vaXplZCBMYWRlZnVua3Rpb24gLS0tXG4gIGNvbnN0IGxvYWRDYXRlZ29yaWVzID0gdXNlQ2FsbGJhY2soYXN5bmMgKGd1aWxkSWRUb0xvYWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghZ3VpbGRJZFRvTG9hZCkge1xuICAgICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzXSBsb2FkQ2F0ZWdvcmllczogS2VpbmUgR3VpbGQgSUQgw7xiZXJnZWJlbi4nKTtcbiAgICAgIHNldENhdGVnb3JpZXMoW10pOyAvLyBadXN0YW5kIGxlZXJlblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXNdIGxvYWRDYXRlZ29yaWVzIGF1ZmdlcnVmZW4gZsO8ciBHdWlsZDogJHtndWlsZElkVG9Mb2FkfWApO1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2F0ZWdvcmllc0RhdGEgPSBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5nZXRDYXRlZ29yaWVzKFNjb3BlVHlwZS5HVUlMRCwgZ3VpbGRJZFRvTG9hZCk7XG4gICAgICBjb25zdCBlbmhhbmNlZENhdGVnb3JpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgY2F0ZWdvcmllc0RhdGEubWFwKGFzeW5jIChjYXRlZ29yeSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHpvbmVzRGF0YSA9IGF3YWl0IHpvbmVzU2VydmljZS5nZXRab25lc0J5Q2F0ZWdvcnkoY2F0ZWdvcnkuaWQpO1xuICAgICAgICAgIGNvbnN0IGVuaGFuY2VkWm9uZXM6IEVuaGFuY2VkWm9uZVtdID0gem9uZXNEYXRhLm1hcCh6b25lID0+ICh7XG4gICAgICAgICAgICBpZDogem9uZS5pZCxcbiAgICAgICAgICAgIG5hbWU6IHpvbmUubmFtZSxcbiAgICAgICAgICAgIHpvbmVLZXk6IHpvbmUuem9uZUtleSxcbiAgICAgICAgICAgIG1pbnV0ZXNSZXF1aXJlZDogem9uZS5pbnRlcnZhbE1pbnV0ZXMsXG4gICAgICAgICAgICBwb2ludHNHcmFudGVkOiB6b25lLnBvaW50c1BlckludGVydmFsLFxuICAgICAgICAgICAgbGFzdEFjdGl2ZTogJy0nLFxuICAgICAgICAgICAgdG90YWxUaW1lU3BlbnQ6IDAsXG4gICAgICAgICAgICB0b3RhbFVzZXJzOiAwXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogY2F0ZWdvcnkuaWQsXG4gICAgICAgICAgICBuYW1lOiBjYXRlZ29yeS5uYW1lLFxuICAgICAgICAgICAgZ3VpbGRfaWQ6IGd1aWxkSWRUb0xvYWQsXG4gICAgICAgICAgICBhbGxvd2VkUm9sZXM6IGNhdGVnb3J5LmFsbG93ZWRSb2xlcyB8fCBbXSxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogY2F0ZWdvcnkuaXNWaXNpYmxlRGVmYXVsdCxcbiAgICAgICAgICAgIHNlbmRTZXR1cDogY2F0ZWdvcnkuc2V0dXBGbG93RW5hYmxlZCxcbiAgICAgICAgICAgIHRyYWNraW5nQWN0aXZlOiBjYXRlZ29yeS5kZWZhdWx0VHJhY2tpbmdFbmFibGVkLFxuICAgICAgICAgICAgc2V0dXBUZXh0Q2hhbm5lbDogY2F0ZWdvcnkuc2V0dXBDaGFubmVsSWQsXG4gICAgICAgICAgICB3YWl0aW5nUm9vbU5hbWU6IGNhdGVnb3J5LndhcnRlcmF1bUNoYW5uZWxJZCxcbiAgICAgICAgICAgIGxhc3RBY3RpdmU6ICctJyxcbiAgICAgICAgICAgIHRvdGFsVGltZVNwZW50OiAwLFxuICAgICAgICAgICAgdG90YWxVc2VyczogMCxcbiAgICAgICAgICAgIGRpc2NvcmRDYXRlZ29yeUlkOiBjYXRlZ29yeS5kaXNjb3JkQ2F0ZWdvcnlJZCB8fCBudWxsLFxuICAgICAgICAgICAgZGVsZXRlZEluRGlzY29yZDogIWNhdGVnb3J5LmRpc2NvcmRDYXRlZ29yeUlkLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShjYXRlZ29yeS5jcmVhdGVkQXQpLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShjYXRlZ29yeS51cGRhdGVkQXQpLFxuICAgICAgICAgICAgem9uZXM6IGVuaGFuY2VkWm9uZXNcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgc2V0Q2F0ZWdvcmllcyhlbmhhbmNlZENhdGVnb3JpZXMpO1xuICAgICAgbG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ID0gZ3VpbGRJZFRvTG9hZDsgLy8gTWFya2llcmVuIGFscyBnZWxhZGVuXG4gICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXNdIGxvYWRDYXRlZ29yaWVzOiAke2VuaGFuY2VkQ2F0ZWdvcmllcy5sZW5ndGh9IEthdGVnb3JpZW4gZ2VsYWRlbiBmw7xyICR7Z3VpbGRJZFRvTG9hZH1gKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFt1c2VDYXRlZ29yaWVzXSBGZWhsZXIgYmVpbSBMYWRlbiBkZXIgS2F0ZWdvcmllbiBmw7xyICR7Z3VpbGRJZFRvTG9hZH06YCwgZXJyKTtcbiAgICAgIHNldEVycm9yKCdGZWhsZXIgYmVpbSBMYWRlbiBkZXIgS2F0ZWdvcmllbicpO1xuICAgICAgLy8gRmFsbGJhY2s/IE9kZXIgbGVlcmVuIFN0YXRlIGxhc3Nlbj9cbiAgICAgIHNldENhdGVnb3JpZXMoW10pOyAvLyBCZWkgRmVobGVyIGxlZXJlblxuICAgICAgbG9hZGVkR3VpbGRJZFJlZi5jdXJyZW50ID0gZ3VpbGRJZFRvTG9hZDsgLy8gVHJvdHogRmVobGVyIGFscyBnZWxhZGVuIG1hcmtpZXJlbiwgdW0gTG9vcCB6dSB2ZXJtZWlkZW5cbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbXSk7IC8vIEtlaW5lIEFiaMOkbmdpZ2tlaXRlbiwgZGEgU2VydmljZXMgdW5kIFN0YXRlLVNldHRlciBzdGFiaWwgc2luZFxuXG4gIC8vIC0tLSBNZW1vaXplZCBSZWFsdGltZSBIYW5kbGVyIC0tLVxuICBjb25zdCBoYW5kbGVDYXRlZ29yeUNoYW5nZSA9IHVzZUNhbGxiYWNrKChwYXlsb2FkOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWQ8YW55PikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbSEFORExFUiBDQUxMRURdIGhhbmRsZUNhdGVnb3J5Q2hhbmdlJywgcGF5bG9hZCk7IC8vIDwtLSBMb2dnaW5nIGhpbnp1ZsO8Z2VuXG4gICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIFJlYWx0aW1lXSBLYXRlZ29yaWUtw4RuZGVydW5nIGVya2FubnQ6YCwgcGF5bG9hZCk7XG4gICAgY29uc3QgeyBldmVudFR5cGUsIG5ldzogbmV3UmVjb3JkLCBvbGQ6IG9sZFJlY29yZCwgdGFibGUgfSA9IHBheWxvYWQ7XG5cbiAgICAvLyBOdXIgYXVmIHJlbGV2YW50ZSBUYWJlbGxlbiByZWFnaWVyZW5cbiAgICBpZiAodGFibGUgIT09ICdjYXRlZ29yaWVzJykge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgUmVhbHRpbWVdIElnbm9yaWVyZSBFdmVudCBmw7xyIFRhYmVsbGU6ICR7dGFibGV9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZWNvcmQgPSBuZXdSZWNvcmQgfHwgb2xkUmVjb3JkO1xuICAgIGlmICghcmVjb3JkIHx8ICFyZWNvcmQuaWQpIHJldHVybjsgLy8gQnJhdWNoZW4gbWluZGVzdGVucyBlaW5lIElEXG5cbiAgICBjb25zdCBjYXRlZ29yeUlkID0gcmVjb3JkLmlkO1xuXG4gICAgc3dpdGNoIChldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgJ0lOU0VSVCc6XG4gICAgICBjYXNlICdVUERBVEUnOlxuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0hhbmRsZXIgTG9naWMgU1RBUlRdICR7ZXZlbnRUeXBlfSBDYXRlZ29yeWApO1xuICAgICAgICAgICAgLy8gTGFkZSBkaWUgKG5ldWUvYWt0dWFsaXNpZXJ0ZSkgS2F0ZWdvcmllIGlua2wuIGlocmVyIFpvbmVuXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeURhdGEgPSBhd2FpdCBjYXRlZ29yaWVzU2VydmljZS5nZXRDYXRlZ29yeUJ5SWQoY2F0ZWdvcnlJZCk7XG4gICAgICAgICAgICBjb25zdCB6b25lc0RhdGEgPSBhd2FpdCB6b25lc1NlcnZpY2UuZ2V0Wm9uZXNCeUNhdGVnb3J5KGNhdGVnb3J5SWQpO1xuXG4gICAgICAgICAgICAvLyBWb2xsc3TDpG5kaWdlcyBNYXBwaW5nIHN0YXR0IFBsYXR6aGFsdGVyXG4gICAgICAgICAgICBjb25zdCBlbmhhbmNlZFpvbmVzID0gem9uZXNEYXRhLm1hcCh6b25lID0+ICh7XG4gICAgICAgICAgICAgIGlkOiB6b25lLmlkLFxuICAgICAgICAgICAgICBuYW1lOiB6b25lLm5hbWUsXG4gICAgICAgICAgICAgIHpvbmVLZXk6IHpvbmUuem9uZUtleSxcbiAgICAgICAgICAgICAgbWludXRlc1JlcXVpcmVkOiB6b25lLmludGVydmFsTWludXRlcyxcbiAgICAgICAgICAgICAgcG9pbnRzR3JhbnRlZDogem9uZS5wb2ludHNQZXJJbnRlcnZhbCxcbiAgICAgICAgICAgICAgbGFzdEFjdGl2ZTogJy0nLFxuICAgICAgICAgICAgICB0b3RhbFRpbWVTcGVudDogMCxcbiAgICAgICAgICAgICAgdG90YWxVc2VyczogMFxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBjb25zdCBlbmhhbmNlZENhdGVnb3J5OiBFbmhhbmNlZENhdGVnb3J5ID0ge1xuICAgICAgICAgICAgICBpZDogY2F0ZWdvcnlEYXRhLmlkLFxuICAgICAgICAgICAgICBuYW1lOiBjYXRlZ29yeURhdGEubmFtZSxcbiAgICAgICAgICAgICAgZ3VpbGRfaWQ6IGN1cnJlbnRHdWlsZD8uaWQgfHwgJycsXG4gICAgICAgICAgICAgIGFsbG93ZWRSb2xlczogY2F0ZWdvcnlEYXRhLmFsbG93ZWRSb2xlcyB8fCBbXSxcbiAgICAgICAgICAgICAgaXNWaXNpYmxlOiBjYXRlZ29yeURhdGEuaXNWaXNpYmxlRGVmYXVsdCxcbiAgICAgICAgICAgICAgc2VuZFNldHVwOiBjYXRlZ29yeURhdGEuc2V0dXBGbG93RW5hYmxlZCxcbiAgICAgICAgICAgICAgdHJhY2tpbmdBY3RpdmU6IGNhdGVnb3J5RGF0YS5kZWZhdWx0VHJhY2tpbmdFbmFibGVkLFxuICAgICAgICAgICAgICBzZXR1cFRleHRDaGFubmVsOiBjYXRlZ29yeURhdGEuc2V0dXBDaGFubmVsSWQsXG4gICAgICAgICAgICAgIHdhaXRpbmdSb29tTmFtZTogY2F0ZWdvcnlEYXRhLndhcnRlcmF1bUNoYW5uZWxJZCxcbiAgICAgICAgICAgICAgbGFzdEFjdGl2ZTogJy0nLFxuICAgICAgICAgICAgICB0b3RhbFRpbWVTcGVudDogMCxcbiAgICAgICAgICAgICAgdG90YWxVc2VyczogMCxcbiAgICAgICAgICAgICAgZGlzY29yZENhdGVnb3J5SWQ6IGNhdGVnb3J5RGF0YS5kaXNjb3JkQ2F0ZWdvcnlJZCB8fCBudWxsLFxuICAgICAgICAgICAgICBkZWxldGVkSW5EaXNjb3JkOiAhY2F0ZWdvcnlEYXRhLmRpc2NvcmRDYXRlZ29yeUlkLFxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGNhdGVnb3J5RGF0YS5jcmVhdGVkQXQpLFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKGNhdGVnb3J5RGF0YS51cGRhdGVkQXQpLFxuICAgICAgICAgICAgICB6b25lczogZW5oYW5jZWRab25lc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTdGF0ZSBCRUZPUkUgdXBkYXRlXScsIGNhdGVnb3JpZXMpO1xuICAgICAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcmV2LmZpbmRJbmRleChjID0+IGMuaWQgPT09IGNhdGVnb3J5SWQpO1xuICAgICAgICAgICAgICBsZXQgbmV3U3RhdGU7XG4gICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0NhdGVnb3J5ICR7ZXZlbnRUeXBlfV0gVXBkYXRpbmcgZXhpc3RpbmcgY2F0ZWdvcnkgYXQgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFsuLi5wcmV2XTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZVtpbmRleF0gPSBlbmhhbmNlZENhdGVnb3J5O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCAob2RlciBVcGRhdGUsIGZhbGxzIGVzIGZlaGx0ZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0NhdGVnb3J5ICR7ZXZlbnRUeXBlfV0gQWRkaW5nIG5ldyBjYXRlZ29yeWApO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gWy4uLnByZXYsIGVuaGFuY2VkQ2F0ZWdvcnldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQUZURVIgdXBkYXRlIChjYWxjdWxhdGVkKV0nLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBMb2dnZSBkZW4gU3RhdGUgbmFjaCBkZXIgQWt0dWFsaXNpZXJ1bmcgKGltIG7DpGNoc3RlbiBSZW5kZXItWnlrbHVzKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQUZURVIgdXBkYXRlIChhY3R1YWwpXScsIGNhdGVnb3JpZXMpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0hhbmRsZXIgTG9naWMgRU5EXSAke2V2ZW50VHlwZX0gQ2F0ZWdvcnlgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW3VzZUNhdGVnb3JpZXMgUmVhbHRpbWVdIEZlaGxlciBiZWltIFZlcmFyYmVpdGVuICR7ZXZlbnRUeXBlfTpgLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0RFTEVURSc6XG4gICAgICAgIGlmIChvbGRSZWNvcmQ/LmlkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljIFNUQVJUXSBERUxFVEUgQ2F0ZWdvcnkgJHtvbGRSZWNvcmQuaWR9YCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tTdGF0ZSBCRUZPUkUgZGVsZXRlXScsIGNhdGVnb3JpZXMpO1xuXG4gICAgICAgICAgc2V0Q2F0ZWdvcmllcyhwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbQ2F0ZWdvcnkgREVMRVRFXSBSZW1vdmluZyBjYXRlZ29yeSB3aXRoIGlkICR7b2xkUmVjb3JkLmlkfWApO1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBwcmV2LmZpbHRlcihjYXRlZ29yeSA9PiBjYXRlZ29yeS5pZCAhPT0gb2xkUmVjb3JkLmlkKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RhdGUgQUZURVIgZGVsZXRlIChjYWxjdWxhdGVkKV0nLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBMb2dnZSBkZW4gU3RhdGUgbmFjaCBkZXIgQWt0dWFsaXNpZXJ1bmcgKGltIG7DpGNoc3RlbiBSZW5kZXItWnlrbHVzKVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTdGF0ZSBBRlRFUiBkZWxldGUgKGFjdHVhbCldJywgY2F0ZWdvcmllcyk7XG4gICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0hhbmRsZXIgTG9naWMgRU5EXSBERUxFVEUgQ2F0ZWdvcnkgJHtvbGRSZWNvcmQuaWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgUmVhbHRpbWVdIFVuYmVrYW5udGVyIEV2ZW50LVR5cCBmw7xyIGNhdGVnb3JpZXM6ICR7ZXZlbnRUeXBlfWApO1xuICAgIH1cbiAgfSwgW3NldENhdGVnb3JpZXNdKTsgLy8gTnVyIHZvbiBzdGFiaWxlbiBGdW5rdGlvbmVuIGFiaMOkbmdpZ1xuXG4gIGNvbnN0IGhhbmRsZVpvbmVDaGFuZ2VJbkNhdGVnb3J5ID0gdXNlQ2FsbGJhY2soKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZDxhbnk+KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1tIQU5ETEVSIENBTExFRF0gaGFuZGxlWm9uZUNoYW5nZUluQ2F0ZWdvcnknLCBwYXlsb2FkKTsgLy8gPC0tIExvZ2dpbmcgaGluenVmw7xnZW5cbiAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgUmVhbHRpbWVdIFpvbmVuLcOEbmRlcnVuZyBlcmthbm50OmAsIHBheWxvYWQpO1xuICAgIGNvbnN0IHsgbmV3OiBuZXdSZWNvcmQsIG9sZDogb2xkUmVjb3JkLCB0YWJsZSB9ID0gcGF5bG9hZDtcblxuICAgIC8vIE51ciBhdWYgcmVsZXZhbnRlIFRhYmVsbGVuIHJlYWdpZXJlblxuICAgIGlmICh0YWJsZSAhPT0gJ3pvbmVzJykge1xuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgUmVhbHRpbWVdIElnbm9yaWVyZSBFdmVudCBmw7xyIFRhYmVsbGU6ICR7dGFibGV9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZWNvcmQgPSBuZXdSZWNvcmQgfHwgb2xkUmVjb3JkO1xuICAgIGlmICghcmVjb3JkIHx8ICFyZWNvcmQuY2F0ZWdvcnlfaWQpIHJldHVybjtcblxuICAgIGNvbnN0IGNhdGVnb3J5SWQgPSByZWNvcmQuY2F0ZWdvcnlfaWQ7XG5cbiAgICAvLyBMYWRlIFpvbmVuIGbDvHIgZGllIGJldHJvZmZlbmUgS2F0ZWdvcmllIG5ldSB1bmQgdXBkYXRlIGRpZSBLYXRlZ29yaWUgaW0gU3RhdGVcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljIFNUQVJUXSBVcGRhdGUgWm9uZXMgZm9yIENhdGVnb3J5ICR7Y2F0ZWdvcnlJZH1gKTtcbiAgICAgICAgY29uc3Qgem9uZXNEYXRhID0gYXdhaXQgem9uZXNTZXJ2aWNlLmdldFpvbmVzQnlDYXRlZ29yeShjYXRlZ29yeUlkKTtcblxuICAgICAgICAvLyBWb2xsc3TDpG5kaWdlcyBNYXBwaW5nIHN0YXR0IFBsYXR6aGFsdGVyXG4gICAgICAgIGNvbnN0IGVuaGFuY2VkWm9uZXMgPSB6b25lc0RhdGEubWFwKHpvbmUgPT4gKHtcbiAgICAgICAgICBpZDogem9uZS5pZCxcbiAgICAgICAgICBuYW1lOiB6b25lLm5hbWUsXG4gICAgICAgICAgem9uZUtleTogem9uZS56b25lS2V5LFxuICAgICAgICAgIG1pbnV0ZXNSZXF1aXJlZDogem9uZS5pbnRlcnZhbE1pbnV0ZXMsXG4gICAgICAgICAgcG9pbnRzR3JhbnRlZDogem9uZS5wb2ludHNQZXJJbnRlcnZhbCxcbiAgICAgICAgICBsYXN0QWN0aXZlOiAnLScsXG4gICAgICAgICAgdG90YWxUaW1lU3BlbnQ6IDAsXG4gICAgICAgICAgdG90YWxVc2VyczogMFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1tTdGF0ZSBCRUZPUkUgem9uZSB1cGRhdGVdJywgY2F0ZWdvcmllcyk7XG4gICAgICAgIHNldENhdGVnb3JpZXMocHJldiA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtab25lIENoYW5nZV0gVXBkYXRpbmcgem9uZXMgZm9yIGNhdGVnb3J5ICR7Y2F0ZWdvcnlJZH1gKTtcbiAgICAgICAgICBjb25zdCBjYXRlZ29yeUluZGV4ID0gcHJldi5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBjYXRlZ29yeUlkKTtcblxuICAgICAgICAgIGlmIChjYXRlZ29yeUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtab25lIENoYW5nZV0gQ2F0ZWdvcnkgJHtjYXRlZ29yeUlkfSBub3QgZm91bmQgaW4gc3RhdGUsIG5vIHVwZGF0ZSBuZWVkZWRgKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gWy4uLnByZXZdO1xuICAgICAgICAgIG5ld1N0YXRlW2NhdGVnb3J5SW5kZXhdID0ge1xuICAgICAgICAgICAgLi4ubmV3U3RhdGVbY2F0ZWdvcnlJbmRleF0sXG4gICAgICAgICAgICB6b25lczogZW5oYW5jZWRab25lc1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zb2xlLmxvZygnW1N0YXRlIEFGVEVSIHpvbmUgdXBkYXRlIChjYWxjdWxhdGVkKV0nLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMb2dnZSBkZW4gU3RhdGUgbmFjaCBkZXIgQWt0dWFsaXNpZXJ1bmcgKGltIG7DpGNoc3RlbiBSZW5kZXItWnlrbHVzKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW1N0YXRlIEFGVEVSIHpvbmUgdXBkYXRlIChhY3R1YWwpXScsIGNhdGVnb3JpZXMpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljIEVORF0gVXBkYXRlIFpvbmVzIGZvciBDYXRlZ29yeSAke2NhdGVnb3J5SWR9YCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbdXNlQ2F0ZWdvcmllcyBSZWFsdGltZV0gRmVobGVyIGJlaW0gTGFkZW4gZGVyIFpvbmVuIGbDvHIgS2F0ZWdvcmllICR7Y2F0ZWdvcnlJZH06YCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH0sIFtzZXRDYXRlZ29yaWVzXSk7IC8vIE51ciB2b24gc3RhYmlsZW4gRnVua3Rpb25lbiBhYmjDpG5naWdcblxuICBjb25zdCBoYW5kbGVDYXRlZ29yeVJvbGVDaGFuZ2UgPSB1c2VDYWxsYmFjaygocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPGFueT4pID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0hBTkRMRVIgQ0FMTEVEXSBoYW5kbGVDYXRlZ29yeVJvbGVDaGFuZ2UnLCBwYXlsb2FkKTsgLy8gPC0tIExvZ2dpbmcgaGluenVmw7xnZW5cbiAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgUmVhbHRpbWVdIEthdGVnb3JpZS1Sb2xsZW4tw4RuZGVydW5nIGVya2FubnQ6YCwgcGF5bG9hZCk7XG4gICAgIGNvbnN0IHsgbmV3OiBuZXdSZWNvcmQsIG9sZDogb2xkUmVjb3JkLCB0YWJsZSB9ID0gcGF5bG9hZDtcblxuICAgIC8vIE51ciBhdWYgcmVsZXZhbnRlIFRhYmVsbGVuIHJlYWdpZXJlblxuICAgIGlmICh0YWJsZSAhPT0gJ2NhdGVnb3J5X2Rpc2NvcmRfcm9sZV9wZXJtaXNzaW9ucycpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIFJlYWx0aW1lXSBJZ25vcmllcmUgRXZlbnQgZsO8ciBUYWJlbGxlOiAke3RhYmxlfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVjb3JkID0gbmV3UmVjb3JkIHx8IG9sZFJlY29yZDtcbiAgICBpZiAoIXJlY29yZCB8fCAhcmVjb3JkLmNhdGVnb3J5X2lkKSByZXR1cm47XG5cbiAgICBjb25zdCBjYXRlZ29yeUlkID0gcmVjb3JkLmNhdGVnb3J5X2lkO1xuXG4gICAgLy8gTGFkZSBkaWUgYmV0cm9mZmVuZSBLYXRlZ29yaWUgbmV1LCB1bSBkaWUgUm9sbGVuIHp1IGFrdHVhbGlzaWVyZW5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFtIYW5kbGVyIExvZ2ljIFNUQVJUXSBVcGRhdGUgUm9sZXMgZm9yIENhdGVnb3J5ICR7Y2F0ZWdvcnlJZH1gKTtcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlEYXRhID0gYXdhaXQgY2F0ZWdvcmllc1NlcnZpY2UuZ2V0Q2F0ZWdvcnlCeUlkKGNhdGVnb3J5SWQpO1xuICAgICAgICBpZiAoIWNhdGVnb3J5RGF0YSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbSGFuZGxlciBMb2dpY10gQ2F0ZWdvcnkgJHtjYXRlZ29yeUlkfSBub3QgZm91bmRgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRDYXRlZ29yaWVzKHByZXYgPT4gcHJldi5tYXAoY2F0ZWdvcnkgPT5cbiAgICAgICAgICBjYXRlZ29yeS5pZCA9PT0gY2F0ZWdvcnlJZCA/IHsgLi4uY2F0ZWdvcnksIGFsbG93ZWRSb2xlczogY2F0ZWdvcnlEYXRhLmFsbG93ZWRSb2xlcyB8fCBbXSB9IDogY2F0ZWdvcnlcbiAgICAgICAgKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbSGFuZGxlciBMb2dpYyBFTkRdIFVwZGF0ZSBSb2xlcyBmb3IgQ2F0ZWdvcnkgJHtjYXRlZ29yeUlkfWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW3VzZUNhdGVnb3JpZXMgUmVhbHRpbWVdIEZlaGxlciBiZWltIExhZGVuIGRlciBSb2xsZW5iZXJlY2h0aWd1bmdlbiBmw7xyIEthdGVnb3JpZSAke2NhdGVnb3J5SWR9OmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9LCBbc2V0Q2F0ZWdvcmllc10pOyAvLyBOdXIgdm9uIHN0YWJpbGVuIEZ1bmt0aW9uZW4gYWJow6RuZ2lnXG5cblxuICAvLyAtLS0gSGF1cHQtdXNlRWZmZWN0IGbDvHIgTGFkZW4gdW5kIFN1YnNjcmlwdGlvbiAtLS1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50R3VpbGRJZCA9IGN1cnJlbnRHdWlsZD8uaWQ7XG4gICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIEVmZmVjdF0gUnVubmluZyBmb3IgZ3VpbGRJZDogJHtjdXJyZW50R3VpbGRJZCB8fCAnbm9uZSd9YCk7XG5cbiAgICBpZiAoIWN1cnJlbnRHdWlsZElkKSB7XG4gICAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBObyBndWlsZElkLCByZXNldHRpbmcuJyk7XG4gICAgICBzZXRDYXRlZ29yaWVzKFtdKTtcbiAgICAgIGxvYWRlZEd1aWxkSWRSZWYuY3VycmVudCA9ICcnO1xuICAgICAgLy8gQWx0ZSBTdWJzY3JpcHRpb24gZW50ZmVybmVuLCBmYWxscyB2b3JoYW5kZW5cbiAgICAgIGlmIChyZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCkge1xuICAgICAgICBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIEVmZmVjdF0gUmVtb3ZlZCBvbGQgY2hhbm5lbCBvbiBndWlsZElkIGNsZWFyLicpO1xuICAgICAgICAgICByZWFsdGltZUNoYW5uZWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIExhZGVuLCB3ZW5uIGRpZSBHdWlsZCBuZXUgaXN0IG9kZXIgZGllIERhdGVuIGZlaGxlblxuICAgIGlmIChsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgIT09IGN1cnJlbnRHdWlsZElkKSB7XG4gICAgICBsb2FkQ2F0ZWdvcmllcyhjdXJyZW50R3VpbGRJZCk7XG4gICAgfVxuXG4gICAgLy8gU3Vic2NyaXB0aW9uIExvZ2lrICh1bnZlcsOkbmRlcnQgenVyIGxldHp0ZW4gVmVyc2lvbiwgbnV0enQgamV0enQgbWVtb2l6ZWQgSGFuZGxlcilcbiAgICBsZXQgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsIHwgbnVsbCA9IHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYGNhdGVnb3JpZXM6JHtjdXJyZW50R3VpbGRJZH1gO1xuXG4gICAgLy8gTnVyIHN1YnNjcmliZW4sIHdlbm4gbm9jaCBuaWNodCBvZGVyIGbDvHIgYW5kZXJlIEd1aWxkIHN1YnNjcmliZWRcbiAgICBpZiAoIWNoYW5uZWwgfHwgY2hhbm5lbC50b3BpYyAhPT0gYHJlYWx0aW1lOiR7Y2hhbm5lbE5hbWV9YCkge1xuICAgICAgICAvLyBBbHRlIFN1YnNjcmlwdGlvbiBzaWNoZXIgZW50ZmVybmVuXG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1t1c2VDYXRlZ29yaWVzIEVmZmVjdF0gUmVtb3ZlZCBwcmV2aW91cyBjaGFubmVsIGJlZm9yZSBuZXcgc3Vic2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsOyAvLyBXaWNodGlnOiBSZWYgenVyw7xja3NldHplblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhgW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBTZXR0aW5nIHVwIGNoYW5uZWw6ICR7Y2hhbm5lbE5hbWV9YCk7XG4gICAgICAgIGNoYW5uZWwgPSBzdXBhYmFzZS5jaGFubmVsKGNoYW5uZWxOYW1lKTtcblxuICAgICAgICBjaGFubmVsXG4gICAgICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgeyBldmVudDogJyonLCBzY2hlbWE6ICdwdWJsaWMnLCB0YWJsZTogJ2NhdGVnb3JpZXMnIH0sIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXMgUkFXIEVWRU5UIGNhdGVnb3JpZXNdJywgcGF5bG9hZCk7IC8vIDwtLSBMb2dnaW5nIGhpbnp1ZsO8Z2VuXG4gICAgICAgICAgICBoYW5kbGVDYXRlZ29yeUNoYW5nZShwYXlsb2FkKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICd6b25lcycgfSwgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbdXNlQ2F0ZWdvcmllcyBSQVcgRVZFTlQgem9uZXNdJywgcGF5bG9hZCk7IC8vIDwtLSBMb2dnaW5nIGhpbnp1ZsO8Z2VuXG4gICAgICAgICAgICBoYW5kbGVab25lQ2hhbmdlSW5DYXRlZ29yeShwYXlsb2FkKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjYXRlZ29yeV9kaXNjb3JkX3JvbGVfcGVybWlzc2lvbnMnIH0sIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXMgUkFXIEVWRU5UIGNhdGVnb3J5X3JvbGVzXScsIHBheWxvYWQpOyAvLyA8LS0gTG9nZ2luZyBoaW56dWbDvGdlblxuICAgICAgICAgICAgaGFuZGxlQ2F0ZWdvcnlSb2xlQ2hhbmdlKHBheWxvYWQpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnN1YnNjcmliZSgoc3RhdHVzLCBlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIFN1YiBzdGF0dXMgJHtjaGFubmVsTmFtZX06YCwgc3RhdHVzLCBlcnIgfHwgJycpO1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ1NVQlNDUklCRUQnKSB7XG4gICAgICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gY2hhbm5lbDsgLy8gUmVmIGVyc3QgYmVpIEVyZm9sZyBzZXR6ZW5cbiAgICAgICAgICAgICAgLy8gTmFjaCBlcmZvbGdyZWljaGVyIFN1YnNjcmlwdGlvbiBldnRsLiBub2NobWFscyBsYWRlbiwgZmFsbHMgaW5pdGlhbEZldGNoIGZlaGxnZXNjaGxhZ2VuXG4gICAgICAgICAgICAgIGlmIChsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgIT09IGN1cnJlbnRHdWlsZElkKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXMgRWZmZWN0XSBSZS1mZXRjaGluZyBkYXRhIGFmdGVyIHN1Y2Nlc3NmdWwgc3Vic2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgICAgICAgbG9hZENhdGVnb3JpZXMoY3VycmVudEd1aWxkSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gJ0NIQU5ORUxfRVJST1InIHx8IHN0YXR1cyA9PT0gJ1RJTUVEX09VVCcpIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFt1c2VDYXRlZ29yaWVzIEVmZmVjdF0gU3Vic2NyaXB0aW9uIGZhaWxlZCBmb3IgJHtjaGFubmVsTmFtZX06YCwgZXJyKTtcbiAgICAgICAgICAgICAgIHJlYWx0aW1lQ2hhbm5lbFJlZi5jdXJyZW50ID0gbnVsbDsgLy8gQmVpIEZlaGxlciBSZWYgenVyw7xja3NldHplblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIEFscmVhZHkgc3Vic2NyaWJlZCB0byAke2NoYW5uZWxOYW1lfWApO1xuICAgIH1cblxuICAgIC8vIENsZWFudXAtRnVua3Rpb25cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coYFt1c2VDYXRlZ29yaWVzIEVmZmVjdF0gQ2xlYW51cCBmb3IgZ3VpbGRJZDogJHtjdXJyZW50R3VpbGRJZH1gKTtcbiAgICAgIC8vIE51ciBkZW4gQ2hhbm5lbCBlbnRmZXJuZW4sIGRlciAqaW4gZGllc2VtIEVmZmVrdCogZXJzdGVsbHQgd3VyZGVcbiAgICAgIGlmIChjaGFubmVsICYmICghcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgfHwgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPT09IGNoYW5uZWwpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdXNlQ2F0ZWdvcmllcyBFZmZlY3RdIFJlbW92aW5nIGNoYW5uZWwgJHtjaGFubmVsLnRvcGljfWApO1xuICAgICAgICBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpO1xuICAgICAgICBpZiAocmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPT09IGNoYW5uZWwpIHtcbiAgICAgICAgICAgcmVhbHRpbWVDaGFubmVsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgLy8gQUNIVFVORzogRGllIEhhbmRsZXIgYWxzIEFiaMOkbmdpZ2tlaXRlbiBzdGVsbGVuIHNpY2hlciwgZGFzcyBkZXIgRWZmZWt0IG5ldSBsw6R1ZnQsIHdlbm5cbiAgLy8gc2ljaCBpaHJlIFJlZmVyZW56ZW4gw6RuZGVybiAod2FzIHNpZSBkYW5rIHVzZUNhbGxiYWNrIG51ciB0dW4gc29sbHRlbiwgd2VubiBzaWNoICppaHJlKiBEZXBzIMOkbmRlcm4pLlxuICAvLyBgbG9hZENhdGVnb3JpZXNgIGlzdCBlYmVuZmFsbHMgbWVtb2lzaWVydC5cbiAgfSwgW2N1cnJlbnRHdWlsZD8uaWQsIGxvYWRDYXRlZ29yaWVzLCBoYW5kbGVDYXRlZ29yeUNoYW5nZSwgaGFuZGxlWm9uZUNoYW5nZUluQ2F0ZWdvcnksIGhhbmRsZUNhdGVnb3J5Um9sZUNoYW5nZV0pO1xuXG4gIC8vIC0tLSBSZXN0bGljaGUgRnVua3Rpb25lbiAod2VpdGdlaGVuZCB1bnZlcsOkbmRlcnQsIG51dHplbiBqZXR6dCBzdGFiaWxlIGxvYWRDYXRlZ29yaWVzKSAtLS1cbiAgY29uc3QgdG9nZ2xlQ2F0ZWdvcnlFeHBhbmQgPSB1c2VDYWxsYmFjaygoY2F0ZWdvcnlJZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0RXhwYW5kZWRDYXRlZ29yaWVzKHByZXZFeHBhbmRlZCA9PlxuICAgICAgcHJldkV4cGFuZGVkLmluY2x1ZGVzKGNhdGVnb3J5SWQpXG4gICAgICAgID8gcHJldkV4cGFuZGVkLmZpbHRlcihpZCA9PiBpZCAhPT0gY2F0ZWdvcnlJZClcbiAgICAgICAgOiBbLi4ucHJldkV4cGFuZGVkLCBjYXRlZ29yeUlkXVxuICAgICk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzYXZlQ2F0ZWdvcnkgPSB1c2VDYWxsYmFjayhhc3luYyAoY2F0ZWdvcnlEYXRhOiBDYXRlZ29yeUlucHV0KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgaWYgKCFndWlsZElkKSB7XG4gICAgICAgIHRvYXN0LmVycm9yKCdLZWluZSBHdWlsZCBhdXNnZXfDpGhsdCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGNhdGVnb3J5RGF0YS5pZCkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlRGF0YTogVXBkYXRlQ2F0ZWdvcnlEdG8gPSB7XG4gICAgICAgICAgICAgIG5hbWU6IGNhdGVnb3J5RGF0YS5uYW1lLFxuICAgICAgICAgICAgICBpc1Zpc2libGVEZWZhdWx0OiBjYXRlZ29yeURhdGEuaXNWaXNpYmxlLFxuICAgICAgICAgICAgICBzZXR1cEZsb3dFbmFibGVkOiBjYXRlZ29yeURhdGEuc2VuZFNldHVwLFxuICAgICAgICAgICAgICBkZWZhdWx0VHJhY2tpbmdFbmFibGVkOiBjYXRlZ29yeURhdGEudHJhY2tpbmdBY3RpdmUsXG4gICAgICAgICAgICAgIHNldHVwQ2hhbm5lbE5hbWU6IGNhdGVnb3J5RGF0YS5zZXR1cFRleHRDaGFubmVsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgd2FydGVyYXVtQ2hhbm5lbE5hbWU6IGNhdGVnb3J5RGF0YS53YWl0aW5nUm9vbU5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBkaXNjb3JkUm9sZUlkczogY2F0ZWdvcnlEYXRhLmFsbG93ZWRSb2xlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLnVwZGF0ZUNhdGVnb3J5KGNhdGVnb3J5RGF0YS5pZCwgdXBkYXRlRGF0YSk7XG4gICAgICAgICAgICB0b2FzdC5zdWNjZXNzKCdLYXRlZ29yaWUgZXJmb2xncmVpY2ggYWt0dWFsaXNpZXJ0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVEYXRhOiBDcmVhdGVDYXRlZ29yeUR0byA9IHtcbiAgICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBpZDogZ3VpbGRJZCxcbiAgICAgICAgICAgICAgICBzY29wZVR5cGU6IFNjb3BlVHlwZS5HVUlMRCxcbiAgICAgICAgICAgICAgICBzY29wZUlkOiBndWlsZElkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG5hbWU6IGNhdGVnb3J5RGF0YS5uYW1lLFxuICAgICAgICAgICAgICBpc1Zpc2libGVEZWZhdWx0OiBjYXRlZ29yeURhdGEuaXNWaXNpYmxlLFxuICAgICAgICAgICAgICBzZXR1cEZsb3dFbmFibGVkOiBjYXRlZ29yeURhdGEuc2VuZFNldHVwLFxuICAgICAgICAgICAgICBkZWZhdWx0VHJhY2tpbmdFbmFibGVkOiBjYXRlZ29yeURhdGEudHJhY2tpbmdBY3RpdmUsXG4gICAgICAgICAgICAgIHNldHVwQ2hhbm5lbE5hbWU6IGNhdGVnb3J5RGF0YS5zZXR1cFRleHRDaGFubmVsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgd2FydGVyYXVtQ2hhbm5lbE5hbWU6IGNhdGVnb3J5RGF0YS53YWl0aW5nUm9vbU5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBkaXNjb3JkUm9sZUlkczogY2F0ZWdvcnlEYXRhLmFsbG93ZWRSb2xlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLmNyZWF0ZUNhdGVnb3J5KGNyZWF0ZURhdGEpO1xuICAgICAgICAgICAgdG9hc3Quc3VjY2VzcygnS2F0ZWdvcmllIGVyZm9sZ3JlaWNoIGVyc3RlbGx0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVhbHRpbWUgc29sbHRlIGRpZSBBa3R1YWxpc2llcnVuZyDDvGJlcm5laG1lbiwga2VpbiBtYW51ZWxsZXMgTGFkZW4gbsO2dGlnXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGZWhsZXIgYmVpbSBTcGVpY2hlcm4gZGVyIEthdGVnb3JpZTonLCBlcnIpO1xuICAgICAgdG9hc3QuZXJyb3IoZXJyLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8ICdGZWhsZXIgYmVpbSBTcGVpY2hlcm4gZGVyIEthdGVnb3JpZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtndWlsZElkXSk7IC8vIEFiaMOkbmdpZyB2b24gZ3VpbGRJZFxuXG4gIGNvbnN0IGRlbGV0ZUNhdGVnb3J5ID0gdXNlQ2FsbGJhY2soYXN5bmMgKGNhdGVnb3J5SWQ6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlPzogc3RyaW5nIH0+ID0+IHtcbiAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgdHJ5IHtcbiAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhdGVnb3JpZXNTZXJ2aWNlLmRlbGV0ZUNhdGVnb3J5KGNhdGVnb3J5SWQpO1xuICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgIHRvYXN0LnN1Y2Nlc3MoJ0thdGVnb3JpZSBlcmZvbGdyZWljaCBnZWzDtnNjaHQnKTtcbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgY29uc29sZS5lcnJvcignRmVobGVyIGJlaW0gTMO2c2NoZW4gZGVyIEthdGVnb3JpZTonLCBlcnIpO1xuICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnRmVobGVyIGJlaW0gTMO2c2NoZW4gZGVyIEthdGVnb3JpZSc7XG4gICAgICAgdG9hc3QuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogZXJyb3JNZXNzYWdlIH07XG4gICAgIH0gZmluYWxseSB7XG4gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgIH1cbiAgfSwgW10pOyAvLyBLZWluZSBBYmjDpG5naWdrZWl0ZW4gbsO2dGlnXG5cbiAgY29uc3QgcmVmZXRjaCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW3VzZUNhdGVnb3JpZXNdIHJlZmV0Y2g6IFN0YXJ0ZSBOZXVsYWRlbicpO1xuICAgIGlmIChjdXJyZW50R3VpbGQ/LmlkKSB7XG4gICAgICBsb2FkZWRHdWlsZElkUmVmLmN1cnJlbnQgPSAnJzsgLy8gRXJ6d2luZ3QgTmV1bGFkZW4gaW0gRWZmZWt0XG4gICAgICBsb2FkQ2F0ZWdvcmllcyhjdXJyZW50R3VpbGQuaWQpOyAvLyBMw7ZzdCBtYW51ZWxsZXMgTGFkZW4gYXVzXG4gICAgfVxuICB9LCBbY3VycmVudEd1aWxkPy5pZCwgbG9hZENhdGVnb3JpZXNdKTtcblxuICBjb25zdCBnZXRUb3RhbFN0YXRzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIC4uLiBCZXJlY2hudW5nIHdpZSBiaXNoZXIgLi4uXG4gICAgcmV0dXJuIHsgdG90YWxDYXRlZ29yaWVzOiAwLCB0b3RhbFVzZXJzOiAwLCB0b3RhbFRpbWU6IDB9OyAvLyBQbGFjZWhvbGRlclxuICB9LCBbY2F0ZWdvcmllc10pO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBjYXRlZ29yaWVzLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgZXhwYW5kZWRDYXRlZ29yaWVzLFxuICAgIHNlYXJjaFF1ZXJ5LFxuICAgIHNldFNlYXJjaFF1ZXJ5LFxuICAgIHRvZ2dsZUNhdGVnb3J5RXhwYW5kLFxuICAgIHNhdmVDYXRlZ29yeSxcbiAgICAvLyB1cGRhdGVDYXRlZ29yeVdpdGhab25lcywgLy8gV2lyZCBqZXR6dCBkdXJjaCBSZWFsdGltZSBIYW5kbGVyIGFiZ2VkZWNrdFxuICAgIGRlbGV0ZUNhdGVnb3J5LFxuICAgIGdldFRvdGFsU3RhdHMsXG4gICAgcmVmZXRjaFxuICB9O1xufTsiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsInRvYXN0IiwidXNlR3VpbGQiLCJjYXRlZ29yaWVzU2VydmljZSIsInpvbmVzU2VydmljZSIsIlNjb3BlVHlwZSIsInN1cGFiYXNlIiwidXNlQ2F0ZWdvcmllcyIsImN1cnJlbnRHdWlsZCIsImd1aWxkSWQiLCJpZCIsImNvbnNvbGUiLCJsb2ciLCJjYXRlZ29yaWVzIiwic2V0Q2F0ZWdvcmllcyIsImV4cGFuZGVkQ2F0ZWdvcmllcyIsInNldEV4cGFuZGVkQ2F0ZWdvcmllcyIsInNlYXJjaFF1ZXJ5Iiwic2V0U2VhcmNoUXVlcnkiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJyZWFsdGltZUNoYW5uZWxSZWYiLCJsb2FkZWRHdWlsZElkUmVmIiwibG9hZENhdGVnb3JpZXMiLCJndWlsZElkVG9Mb2FkIiwiY2F0ZWdvcmllc0RhdGEiLCJnZXRDYXRlZ29yaWVzIiwiR1VJTEQiLCJlbmhhbmNlZENhdGVnb3JpZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiY2F0ZWdvcnkiLCJ6b25lc0RhdGEiLCJnZXRab25lc0J5Q2F0ZWdvcnkiLCJlbmhhbmNlZFpvbmVzIiwiem9uZSIsIm5hbWUiLCJ6b25lS2V5IiwibWludXRlc1JlcXVpcmVkIiwiaW50ZXJ2YWxNaW51dGVzIiwicG9pbnRzR3JhbnRlZCIsInBvaW50c1BlckludGVydmFsIiwibGFzdEFjdGl2ZSIsInRvdGFsVGltZVNwZW50IiwidG90YWxVc2VycyIsImd1aWxkX2lkIiwiYWxsb3dlZFJvbGVzIiwiaXNWaXNpYmxlIiwiaXNWaXNpYmxlRGVmYXVsdCIsInNlbmRTZXR1cCIsInNldHVwRmxvd0VuYWJsZWQiLCJ0cmFja2luZ0FjdGl2ZSIsImRlZmF1bHRUcmFja2luZ0VuYWJsZWQiLCJzZXR1cFRleHRDaGFubmVsIiwic2V0dXBDaGFubmVsSWQiLCJ3YWl0aW5nUm9vbU5hbWUiLCJ3YXJ0ZXJhdW1DaGFubmVsSWQiLCJkaXNjb3JkQ2F0ZWdvcnlJZCIsImRlbGV0ZWRJbkRpc2NvcmQiLCJjcmVhdGVkQXQiLCJEYXRlIiwidXBkYXRlZEF0Iiwiem9uZXMiLCJjdXJyZW50IiwibGVuZ3RoIiwiZXJyIiwiaGFuZGxlQ2F0ZWdvcnlDaGFuZ2UiLCJwYXlsb2FkIiwiZXZlbnRUeXBlIiwibmV3IiwibmV3UmVjb3JkIiwib2xkIiwib2xkUmVjb3JkIiwidGFibGUiLCJyZWNvcmQiLCJjYXRlZ29yeUlkIiwiY2F0ZWdvcnlEYXRhIiwiZ2V0Q2F0ZWdvcnlCeUlkIiwiZW5oYW5jZWRDYXRlZ29yeSIsInByZXYiLCJpbmRleCIsImZpbmRJbmRleCIsImMiLCJuZXdTdGF0ZSIsInNldFRpbWVvdXQiLCJmaWx0ZXIiLCJoYW5kbGVab25lQ2hhbmdlSW5DYXRlZ29yeSIsImNhdGVnb3J5X2lkIiwiY2F0ZWdvcnlJbmRleCIsImhhbmRsZUNhdGVnb3J5Um9sZUNoYW5nZSIsImN1cnJlbnRHdWlsZElkIiwicmVtb3ZlQ2hhbm5lbCIsInRoZW4iLCJjaGFubmVsIiwiY2hhbm5lbE5hbWUiLCJ0b3BpYyIsIm9uIiwiZXZlbnQiLCJzY2hlbWEiLCJzdWJzY3JpYmUiLCJzdGF0dXMiLCJ0b2dnbGVDYXRlZ29yeUV4cGFuZCIsInByZXZFeHBhbmRlZCIsImluY2x1ZGVzIiwic2F2ZUNhdGVnb3J5IiwidXBkYXRlRGF0YSIsInNldHVwQ2hhbm5lbE5hbWUiLCJ1bmRlZmluZWQiLCJ3YXJ0ZXJhdW1DaGFubmVsTmFtZSIsImRpc2NvcmRSb2xlSWRzIiwidXBkYXRlQ2F0ZWdvcnkiLCJzdWNjZXNzIiwiY3JlYXRlRGF0YSIsInNjb3BlIiwic2NvcGVUeXBlIiwic2NvcGVJZCIsImNyZWF0ZUNhdGVnb3J5IiwicmVzcG9uc2UiLCJkYXRhIiwibWVzc2FnZSIsImRlbGV0ZUNhdGVnb3J5IiwicmVzdWx0IiwiZXJyb3JNZXNzYWdlIiwicmVmZXRjaCIsImdldFRvdGFsU3RhdHMiLCJ0b3RhbENhdGVnb3JpZXMiLCJ0b3RhbFRpbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/category-management/hooks/useCategories.ts\n"));

/***/ })

});